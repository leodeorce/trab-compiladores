Terminals unused in grammar

   ARROW
   TERNARY
   CHAIN
   PIPELINE
   SPREAD
   CASE
   CATCH
   DEBUGGER
   DEFAULT
   DELETE
   ENUM
   EXPORT
   EXTENDS
   FINALLY
   IMPLEMENTS
   IMPORT
   IN
   INSTANCEOF
   INTERFACE
   PACKAGE
   SUPER
   SWITCH
   THIS
   THROW
   TRY
   TYPEOF
   WITH
   AWAIT
   YIELD
   STATIC
   AS
   ASYNC
   FROM
   GET
   OF
   SET
   TARGET
   CONSTRUCTOR
   DECLARE
   MODULE
   REQUIRE
   SYMBOL
   TYPE


Grammar

    0 $accept: line $end

    1 line: stmt-list
    2     | %empty

    3 stmt-list: stmt-list stmt
    4          | stmt

    5 $@1: %empty

    6 stmt: var-declr $@1 SEMI
    7     | func-def
    8     | class-def
    9     | expr SEMI
   10     | assign-expr SEMI
   11     | if-stmt
   12     | while-stmt
   13     | do-while-stmt
   14     | for-stmt
   15     | RETURN SEMI
   16     | RETURN expr SEMI
   17     | BREAK SEMI
   18     | CONTINUE SEMI

   19 assign-expr: var-att assignment expr
   20            | ID assignment expr
   21            | vet-idx assignment expr

   22 for-stmt: FOR LPAR assign-expr SEMI expr SEMI expr RPAR LBRACE line RBRACE
   23         | FOR LPAR assign-expr SEMI expr SEMI assign-expr RPAR LBRACE line RBRACE
   24         | FOR LPAR assign-expr SEMI expr SEMI RPAR LBRACE line RBRACE
   25         | FOR LPAR assign-expr SEMI SEMI expr RPAR LBRACE line RBRACE
   26         | FOR LPAR assign-expr SEMI SEMI assign-expr RPAR LBRACE line RBRACE
   27         | FOR LPAR assign-expr SEMI SEMI RPAR LBRACE line RBRACE
   28         | FOR LPAR var-declr SEMI expr SEMI expr RPAR LBRACE line RBRACE
   29         | FOR LPAR var-declr SEMI expr SEMI assign-expr RPAR LBRACE line RBRACE
   30         | FOR LPAR var-declr SEMI expr SEMI RPAR LBRACE line RBRACE
   31         | FOR LPAR var-declr SEMI SEMI expr RPAR LBRACE line RBRACE
   32         | FOR LPAR var-declr SEMI SEMI assign-expr RPAR LBRACE line RBRACE
   33         | FOR LPAR var-declr SEMI SEMI RPAR LBRACE line RBRACE
   34         | FOR LPAR SEMI expr SEMI expr RPAR LBRACE line RBRACE
   35         | FOR LPAR SEMI expr SEMI assign-expr RPAR LBRACE line RBRACE
   36         | FOR LPAR SEMI expr SEMI RPAR LBRACE line RBRACE
   37         | FOR LPAR SEMI SEMI expr RPAR LBRACE line RBRACE
   38         | FOR LPAR SEMI SEMI assign-expr RPAR LBRACE line RBRACE
   39         | FOR LPAR SEMI SEMI RPAR LBRACE line RBRACE

   40 assignment: ASSIGN
   41           | LOGICAL_NULL_ASSIGN
   42           | LOGICAL_AND_ASSIGN
   43           | LOGICAL_OR_ASSIGN
   44           | PLUS_ASSIGN
   45           | SUB_ASSIGN
   46           | MULT_ASSIGN
   47           | DIV_ASSIGN
   48           | EXP_ASSIGN
   49           | REM_ASSIGN
   50           | BITWISE_AND_ASSIGN
   51           | BITWISE_OR_ASSIGN
   52           | BITWISE_XOR_ASSIGN
   53           | LSHIFT_ASSIGN
   54           | RSHIFT_ASSIGN
   55           | RSHIFT_UNSIGNED_ASSIGN

   56 do-while-stmt: DO LBRACE line RBRACE WHILE LPAR expr RPAR
   57              | DO LBRACE line RBRACE WHILE LPAR assign-expr RPAR

   58 while-stmt: WHILE LPAR expr RPAR LBRACE line RBRACE
   59           | WHILE LPAR assign-expr RPAR LBRACE line RBRACE

   60 if-stmt: IF LPAR expr RPAR LBRACE line RBRACE
   61        | IF LPAR expr RPAR LBRACE line RBRACE ELSE LBRACE line RBRACE
   62        | IF LPAR expr RPAR LBRACE line RBRACE ELSE stmt
   63        | IF LPAR assign-expr RPAR LBRACE line RBRACE
   64        | IF LPAR assign-expr RPAR LBRACE line RBRACE ELSE LBRACE line RBRACE
   65        | IF LPAR assign-expr RPAR LBRACE line RBRACE ELSE stmt

   66 logic-expr: expr EQ expr
   67           | expr EQ_STRICT expr
   68           | expr INEQ expr
   69           | expr INEQ_STRICT expr
   70           | expr LT expr
   71           | ID LT expr
   72           | expr LT_EQ expr
   73           | expr GT expr
   74           | expr GT_EQ expr
   75           | expr LOGICAL_NULL expr
   76           | expr LOGICAL_AND expr
   77           | expr LOGICAL_OR expr

   78 class-def: CLASS ID LBRACE class-att-list RBRACE

   79 class-att-list: SEMI class-att-list
   80               | class-att SEMI class-att-list
   81               | class-att
   82               | %empty

   83 class-att: ID COLON var-type
   84          | access-modif ID COLON var-type
   85          | ID LPAR params RPAR LBRACE line RBRACE
   86          | ID LPAR params RPAR COLON var-type LBRACE line RBRACE

   87 access-modif: PUBLIC
   88             | PRIVATE
   89             | PROTECTED

   90 func-def: FUNCTION ID LPAR params RPAR LBRACE line RBRACE
   91         | FUNCTION ID LPAR params RPAR COLON var-type LBRACE line RBRACE

   92 params: COMMA ID
   93       | COMMA ID COLON var-type
   94       | ID COMMA ID
   95       | ID COLON var-type COMMA ID COLON var-type
   96       | ID COLON var-type COMMA ID
   97       | ID COLON var-type
   98       | ID COMMA ID COLON var-type
   99       | %empty

  100 var-declr: LET id-list
  101          | LET id-list ASSIGN expr
  102          | LET id-list ASSIGN obj-def
  103          | LET ID COLON var-type
  104          | LET ID COLON var-type ASSIGN expr
  105          | LET ID COLON var-type LBRACKET RBRACKET
  106          | LET ID COLON var-type LBRACKET RBRACKET ASSIGN expr
  107          | VAR id-list
  108          | VAR id-list ASSIGN expr
  109          | VAR id-list ASSIGN obj-def
  110          | VAR ID COLON var-type
  111          | VAR ID COLON var-type ASSIGN expr
  112          | VAR ID COLON var-type LBRACKET RBRACKET
  113          | VAR ID COLON var-type LBRACKET RBRACKET ASSIGN expr
  114          | CONST_RW id-list ASSIGN expr
  115          | CONST_RW ID COLON var-type ASSIGN expr
  116          | CONST_RW ID COLON var-type LBRACKET RBRACKET ASSIGN expr
  117          | CONST_RW id-list ASSIGN obj-def

  118 $@2: %empty

  119 id-list: ID $@2 COMMA id-list
  120        | ID

  121 obj-def: LBRACE obj-att-list RBRACE

  122 obj-att-list: COMMA obj-att-list
  123             | obj-att COMMA obj-att-list
  124             | obj-att
  125             | %empty

  126 obj-att: ID COLON var-val

  127 var-type: NUMBER
  128         | STRING
  129         | UNKNOWN
  130         | BOOLTYPE
  131         | ANY
  132         | VOID_RW
  133         | NEVER

  134 expr: idx-safe-expr
  135     | idx-unsafe-expr
  136     | LPAR expr RPAR

  137 idx-unsafe-expr: array-expr
  138                | logic-expr
  139                | var-obj

  140 idx-safe-expr: var-val
  141              | var-att
  142              | arit-expr
  143              | bitw-expr
  144              | shift-expr
  145              | unary-expr
  146              | vet-idx
  147              | ID

  148 vet-idx: ID LBRACKET idx-safe-expr RBRACKET

  149 unary-expr: INCREMENT ID
  150           | INCREMENT var-att
  151           | DECREMENT ID
  152           | DECREMENT var-att
  153           | ID INCREMENT
  154           | var-att INCREMENT
  155           | ID DECREMENT
  156           | var-att DECREMENT
  157           | LOGICAL_NOT expr
  158           | BITWISE_NOT expr

  159 arit-expr: expr PLUS expr
  160          | expr SUB expr
  161          | expr MULT expr
  162          | expr DIV expr
  163          | expr EXP expr
  164          | expr REM expr

  165 bitw-expr: expr BITWISE_AND expr
  166          | expr BITWISE_OR expr
  167          | expr BITWISE_XOR expr

  168 shift-expr: expr LSHIFT expr
  169           | expr RSHIFT expr
  170           | expr RSHIFT_UNSIGNED expr

  171 var-att: ID DOT var-att
  172        | var-att DOT ID
  173        | ID DOT var-met
  174        | var-met DOT ID
  175        | var-met DOT var-att
  176        | var-att DOT var-met
  177        | ID DOT ID

  178 var-met: ID LPAR args-list RPAR

  179 args-list: COMMA args-list
  180          | expr COMMA args-list
  181          | assign-expr COMMA args-list
  182          | expr
  183          | assign-expr
  184          | %empty

  185 var-obj: ID LPAR args-list RPAR
  186        | ID LT var-type GT LPAR args-list RPAR
  187        | NEW ID LPAR args-list RPAR
  188        | NEW ID LT var-type GT LPAR args-list RPAR

  189 var-val: INT_VAL
  190        | REAL_VAL
  191        | STR_VAL
  192        | TRUE_RW
  193        | FALSE_RW
  194        | SUB INT_VAL
  195        | SUB REAL_VAL
  196        | SUB STR_VAL
  197        | SUB TRUE_RW
  198        | SUB FALSE_RW
  199        | NULL_RW
  200        | UNDEFINED

  201 array-expr: LBRACKET elmts-list RBRACKET

  202 elmts-list: COMMA elmts-list
  203           | var-val COMMA elmts-list
  204           | var-val
  205           | %empty


Terminals, with rules where they appear

$end (0) 0
error (256)
ASSIGN (258) 40 101 102 104 106 108 109 111 113 114 115 116 117
ARROW (259)
COMMA (260) 92 93 94 95 96 98 119 122 123 179 180 181 202 203
SEMI (261) 6 9 10 15 16 17 18 22 23 24 25 26 27 28 29 30 31 32 33 34
    35 36 37 38 39 79 80
COLON (262) 83 84 86 91 93 95 96 97 98 103 104 105 106 110 111 112
    113 115 116 126
TERNARY (263)
CHAIN (264)
PIPELINE (265)
DOT (266) 171 172 173 174 175 176 177
SPREAD (267)
PLUS (268) 159
INCREMENT (269) 149 150 153 154
PLUS_ASSIGN (270) 44
SUB (271) 160 194 195 196 197 198
DECREMENT (272) 151 152 155 156
SUB_ASSIGN (273) 45
MULT (274) 161
MULT_ASSIGN (275) 46
DIV (276) 162
DIV_ASSIGN (277) 47
EXP (278) 163
EXP_ASSIGN (279) 48
REM (280) 164
REM_ASSIGN (281) 49
BITWISE_NOT (282) 158
BITWISE_AND (283) 165
BITWISE_AND_ASSIGN (284) 50
BITWISE_OR (285) 166
BITWISE_OR_ASSIGN (286) 51
BITWISE_XOR (287) 167
BITWISE_XOR_ASSIGN (288) 52
LOGICAL_NOT (289) 157
LOGICAL_NULL (290) 75
LOGICAL_NULL_ASSIGN (291) 41
LOGICAL_AND (292) 76
LOGICAL_AND_ASSIGN (293) 42
LOGICAL_OR (294) 77
LOGICAL_OR_ASSIGN (295) 43
EQ (296) 66
EQ_STRICT (297) 67
INEQ (298) 68
INEQ_STRICT (299) 69
LT (300) 70 71 186 188
LT_EQ (301) 72
GT (302) 73 186 188
GT_EQ (303) 74
LSHIFT (304) 168
LSHIFT_ASSIGN (305) 53
RSHIFT (306) 169
RSHIFT_ASSIGN (307) 54
RSHIFT_UNSIGNED (308) 170
RSHIFT_UNSIGNED_ASSIGN (309) 55
LPAR (310) 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 56
    57 58 59 60 61 62 63 64 65 85 86 90 91 136 178 185 186 187 188
RPAR (311) 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 56
    57 58 59 60 61 62 63 64 65 85 86 90 91 136 178 185 186 187 188
LBRACE (312) 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39
    56 57 58 59 60 61 62 63 64 65 78 85 86 90 91 121
RBRACE (313) 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39
    56 57 58 59 60 61 62 63 64 65 78 85 86 90 91 121
LBRACKET (314) 105 106 112 113 116 148 201
RBRACKET (315) 105 106 112 113 116 148 201
INT_VAL (316) 189 194
REAL_VAL (317) 190 195
STR_VAL (318) 191 196
ID (319) 20 71 78 83 84 85 86 90 91 92 93 94 95 96 97 98 103 104 105
    106 110 111 112 113 115 116 119 120 126 147 148 149 151 153 155
    171 172 173 174 177 178 185 186 187 188
BREAK (320) 17
CASE (321)
CATCH (322)
CLASS (323) 78
CONST_RW (324) 114 115 116 117
CONTINUE (325) 18
DEBUGGER (326)
DEFAULT (327)
DELETE (328)
DO (329) 56 57
ELSE (330) 61 62 64 65
ENUM (331)
EXPORT (332)
EXTENDS (333)
FALSE_RW (334) 193 198
FINALLY (335)
FOR (336) 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39
FUNCTION (337) 90 91
IF (338) 60 61 62 63 64 65
IMPLEMENTS (339)
IMPORT (340)
IN (341)
INSTANCEOF (342)
INTERFACE (343)
LET (344) 100 101 102 103 104 105 106
NEW (345) 187 188
NULL_RW (346) 199
PACKAGE (347)
PRIVATE (348) 88
PROTECTED (349) 89
PUBLIC (350) 87
RETURN (351) 15 16
SUPER (352)
SWITCH (353)
THIS (354)
THROW (355)
TRUE_RW (356) 192 197
TRY (357)
TYPEOF (358)
VAR (359) 107 108 109 110 111 112 113
VOID_RW (360) 132
WHILE (361) 56 57 58 59
WITH (362)
AWAIT (363)
YIELD (364)
STATIC (365)
AS (366)
ASYNC (367)
FROM (368)
GET (369)
OF (370)
SET (371)
TARGET (372)
ANY (373) 131
BOOLTYPE (374) 130
CONSTRUCTOR (375)
DECLARE (376)
MODULE (377)
REQUIRE (378)
NEVER (379) 133
NUMBER (380) 127
STRING (381) 128
SYMBOL (382)
TYPE (383)
UNDEFINED (384) 200
UNKNOWN (385) 129
E_ID (386)


Nonterminals, with rules where they appear

$accept (132)
    on left: 0
line (133)
    on left: 1 2, on right: 0 22 23 24 25 26 27 28 29 30 31 32 33 34
    35 36 37 38 39 56 57 58 59 60 61 62 63 64 65 85 86 90 91
stmt-list (134)
    on left: 3 4, on right: 1 3
stmt (135)
    on left: 6 7 8 9 10 11 12 13 14 15 16 17 18, on right: 3 4 62 65
$@1 (136)
    on left: 5, on right: 6
assign-expr (137)
    on left: 19 20 21, on right: 10 22 23 24 25 26 27 29 32 35 38 57
    59 63 64 65 181 183
for-stmt (138)
    on left: 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39,
    on right: 14
assignment (139)
    on left: 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55, on right:
    19 20 21
do-while-stmt (140)
    on left: 56 57, on right: 13
while-stmt (141)
    on left: 58 59, on right: 12
if-stmt (142)
    on left: 60 61 62 63 64 65, on right: 11
logic-expr (143)
    on left: 66 67 68 69 70 71 72 73 74 75 76 77, on right: 138
class-def (144)
    on left: 78, on right: 8
class-att-list (145)
    on left: 79 80 81 82, on right: 78 79 80
class-att (146)
    on left: 83 84 85 86, on right: 80 81
access-modif (147)
    on left: 87 88 89, on right: 84
func-def (148)
    on left: 90 91, on right: 7
params (149)
    on left: 92 93 94 95 96 97 98 99, on right: 85 86 90 91
var-declr (150)
    on left: 100 101 102 103 104 105 106 107 108 109 110 111 112 113
    114 115 116 117, on right: 6 28 29 30 31 32 33
id-list (151)
    on left: 119 120, on right: 100 101 102 107 108 109 114 117 119
$@2 (152)
    on left: 118, on right: 119
obj-def (153)
    on left: 121, on right: 102 109 117
obj-att-list (154)
    on left: 122 123 124 125, on right: 121 122 123
obj-att (155)
    on left: 126, on right: 123 124
var-type (156)
    on left: 127 128 129 130 131 132 133, on right: 83 84 86 91 93
    95 96 97 98 103 104 105 106 110 111 112 113 115 116 186 188
expr (157)
    on left: 134 135 136, on right: 9 16 19 20 21 22 23 24 25 28 29
    30 31 34 35 36 37 56 58 60 61 62 66 67 68 69 70 71 72 73 74 75
    76 77 101 104 106 108 111 113 114 115 116 136 157 158 159 160 161
    162 163 164 165 166 167 168 169 170 180 182
idx-unsafe-expr (158)
    on left: 137 138 139, on right: 135
idx-safe-expr (159)
    on left: 140 141 142 143 144 145 146 147, on right: 134 148
vet-idx (160)
    on left: 148, on right: 21 146
unary-expr (161)
    on left: 149 150 151 152 153 154 155 156 157 158, on right: 145
arit-expr (162)
    on left: 159 160 161 162 163 164, on right: 142
bitw-expr (163)
    on left: 165 166 167, on right: 143
shift-expr (164)
    on left: 168 169 170, on right: 144
var-att (165)
    on left: 171 172 173 174 175 176 177, on right: 19 141 150 152
    154 156 171 172 175 176
var-met (166)
    on left: 178, on right: 173 174 175 176
args-list (167)
    on left: 179 180 181 182 183 184, on right: 178 179 180 181 185
    186 187 188
var-obj (168)
    on left: 185 186 187 188, on right: 139
var-val (169)
    on left: 189 190 191 192 193 194 195 196 197 198 199 200, on right:
    126 140 203 204
array-expr (170)
    on left: 201, on right: 137
elmts-list (171)
    on left: 202 203 204 205, on right: 201 202 203


State 0

    0 $accept: . line $end

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 2 (line)

    line             go to state 29
    stmt-list        go to state 30
    stmt             go to state 31
    assign-expr      go to state 32
    for-stmt         go to state 33
    do-while-stmt    go to state 34
    while-stmt       go to state 35
    if-stmt          go to state 36
    logic-expr       go to state 37
    class-def        go to state 38
    func-def         go to state 39
    var-declr        go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 1

  149 unary-expr: INCREMENT . ID
  150           | INCREMENT . var-att

    ID  shift, and go to state 54

    var-att  go to state 55
    var-met  go to state 50


State 2

  194 var-val: SUB . INT_VAL
  195        | SUB . REAL_VAL
  196        | SUB . STR_VAL
  197        | SUB . TRUE_RW
  198        | SUB . FALSE_RW

    INT_VAL   shift, and go to state 56
    REAL_VAL  shift, and go to state 57
    STR_VAL   shift, and go to state 58
    FALSE_RW  shift, and go to state 59
    TRUE_RW   shift, and go to state 60


State 3

  151 unary-expr: DECREMENT . ID
  152           | DECREMENT . var-att

    ID  shift, and go to state 61

    var-att  go to state 62
    var-met  go to state 50


State 4

  158 unary-expr: BITWISE_NOT . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 37
    expr             go to state 64
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 5

  157 unary-expr: LOGICAL_NOT . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 37
    expr             go to state 67
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 6

  136 expr: LPAR . expr RPAR

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 37
    expr             go to state 68
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 7

  201 array-expr: LBRACKET . elmts-list RBRACKET

    COMMA      shift, and go to state 69
    SUB        shift, and go to state 2
    INT_VAL    shift, and go to state 8
    REAL_VAL   shift, and go to state 9
    STR_VAL    shift, and go to state 10
    FALSE_RW   shift, and go to state 17
    NULL_RW    shift, and go to state 23
    TRUE_RW    shift, and go to state 25
    UNDEFINED  shift, and go to state 28

    $default  reduce using rule 205 (elmts-list)

    var-val     go to state 70
    elmts-list  go to state 71


State 8

  189 var-val: INT_VAL .

    $default  reduce using rule 189 (var-val)


State 9

  190 var-val: REAL_VAL .

    $default  reduce using rule 190 (var-val)


State 10

  191 var-val: STR_VAL .

    $default  reduce using rule 191 (var-val)


State 11

   20 assign-expr: ID . assignment expr
   71 logic-expr: ID . LT expr
  147 idx-safe-expr: ID .
  148 vet-idx: ID . LBRACKET idx-safe-expr RBRACKET
  153 unary-expr: ID . INCREMENT
  155           | ID . DECREMENT
  171 var-att: ID . DOT var-att
  173        | ID . DOT var-met
  177        | ID . DOT ID
  178 var-met: ID . LPAR args-list RPAR
  185 var-obj: ID . LPAR args-list RPAR
  186        | ID . LT var-type GT LPAR args-list RPAR

    ASSIGN                  shift, and go to state 72
    DOT                     shift, and go to state 73
    INCREMENT               shift, and go to state 74
    PLUS_ASSIGN             shift, and go to state 75
    DECREMENT               shift, and go to state 76
    SUB_ASSIGN              shift, and go to state 77
    MULT_ASSIGN             shift, and go to state 78
    DIV_ASSIGN              shift, and go to state 79
    EXP_ASSIGN              shift, and go to state 80
    REM_ASSIGN              shift, and go to state 81
    BITWISE_AND_ASSIGN      shift, and go to state 82
    BITWISE_OR_ASSIGN       shift, and go to state 83
    BITWISE_XOR_ASSIGN      shift, and go to state 84
    LOGICAL_NULL_ASSIGN     shift, and go to state 85
    LOGICAL_AND_ASSIGN      shift, and go to state 86
    LOGICAL_OR_ASSIGN       shift, and go to state 87
    LT                      shift, and go to state 88
    LSHIFT_ASSIGN           shift, and go to state 89
    RSHIFT_ASSIGN           shift, and go to state 90
    RSHIFT_UNSIGNED_ASSIGN  shift, and go to state 91
    LPAR                    shift, and go to state 92
    LBRACKET                shift, and go to state 93

    $default  reduce using rule 147 (idx-safe-expr)

    assignment  go to state 94


State 12

   17 stmt: BREAK . SEMI

    SEMI  shift, and go to state 95


State 13

   78 class-def: CLASS . ID LBRACE class-att-list RBRACE

    ID  shift, and go to state 96


State 14

  114 var-declr: CONST_RW . id-list ASSIGN expr
  115          | CONST_RW . ID COLON var-type ASSIGN expr
  116          | CONST_RW . ID COLON var-type LBRACKET RBRACKET ASSIGN expr
  117          | CONST_RW . id-list ASSIGN obj-def

    ID  shift, and go to state 97

    id-list  go to state 98


State 15

   18 stmt: CONTINUE . SEMI

    SEMI  shift, and go to state 99


State 16

   56 do-while-stmt: DO . LBRACE line RBRACE WHILE LPAR expr RPAR
   57              | DO . LBRACE line RBRACE WHILE LPAR assign-expr RPAR

    LBRACE  shift, and go to state 100


State 17

  193 var-val: FALSE_RW .

    $default  reduce using rule 193 (var-val)


State 18

   22 for-stmt: FOR . LPAR assign-expr SEMI expr SEMI expr RPAR LBRACE line RBRACE
   23         | FOR . LPAR assign-expr SEMI expr SEMI assign-expr RPAR LBRACE line RBRACE
   24         | FOR . LPAR assign-expr SEMI expr SEMI RPAR LBRACE line RBRACE
   25         | FOR . LPAR assign-expr SEMI SEMI expr RPAR LBRACE line RBRACE
   26         | FOR . LPAR assign-expr SEMI SEMI assign-expr RPAR LBRACE line RBRACE
   27         | FOR . LPAR assign-expr SEMI SEMI RPAR LBRACE line RBRACE
   28         | FOR . LPAR var-declr SEMI expr SEMI expr RPAR LBRACE line RBRACE
   29         | FOR . LPAR var-declr SEMI expr SEMI assign-expr RPAR LBRACE line RBRACE
   30         | FOR . LPAR var-declr SEMI expr SEMI RPAR LBRACE line RBRACE
   31         | FOR . LPAR var-declr SEMI SEMI expr RPAR LBRACE line RBRACE
   32         | FOR . LPAR var-declr SEMI SEMI assign-expr RPAR LBRACE line RBRACE
   33         | FOR . LPAR var-declr SEMI SEMI RPAR LBRACE line RBRACE
   34         | FOR . LPAR SEMI expr SEMI expr RPAR LBRACE line RBRACE
   35         | FOR . LPAR SEMI expr SEMI assign-expr RPAR LBRACE line RBRACE
   36         | FOR . LPAR SEMI expr SEMI RPAR LBRACE line RBRACE
   37         | FOR . LPAR SEMI SEMI expr RPAR LBRACE line RBRACE
   38         | FOR . LPAR SEMI SEMI assign-expr RPAR LBRACE line RBRACE
   39         | FOR . LPAR SEMI SEMI RPAR LBRACE line RBRACE

    LPAR  shift, and go to state 101


State 19

   90 func-def: FUNCTION . ID LPAR params RPAR LBRACE line RBRACE
   91         | FUNCTION . ID LPAR params RPAR COLON var-type LBRACE line RBRACE

    ID  shift, and go to state 102


State 20

   60 if-stmt: IF . LPAR expr RPAR LBRACE line RBRACE
   61        | IF . LPAR expr RPAR LBRACE line RBRACE ELSE LBRACE line RBRACE
   62        | IF . LPAR expr RPAR LBRACE line RBRACE ELSE stmt
   63        | IF . LPAR assign-expr RPAR LBRACE line RBRACE
   64        | IF . LPAR assign-expr RPAR LBRACE line RBRACE ELSE LBRACE line RBRACE
   65        | IF . LPAR assign-expr RPAR LBRACE line RBRACE ELSE stmt

    LPAR  shift, and go to state 103


State 21

  100 var-declr: LET . id-list
  101          | LET . id-list ASSIGN expr
  102          | LET . id-list ASSIGN obj-def
  103          | LET . ID COLON var-type
  104          | LET . ID COLON var-type ASSIGN expr
  105          | LET . ID COLON var-type LBRACKET RBRACKET
  106          | LET . ID COLON var-type LBRACKET RBRACKET ASSIGN expr

    ID  shift, and go to state 104

    id-list  go to state 105


State 22

  187 var-obj: NEW . ID LPAR args-list RPAR
  188        | NEW . ID LT var-type GT LPAR args-list RPAR

    ID  shift, and go to state 106


State 23

  199 var-val: NULL_RW .

    $default  reduce using rule 199 (var-val)


State 24

   15 stmt: RETURN . SEMI
   16     | RETURN . expr SEMI

    SEMI         shift, and go to state 107
    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 37
    expr             go to state 108
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 25

  192 var-val: TRUE_RW .

    $default  reduce using rule 192 (var-val)


State 26

  107 var-declr: VAR . id-list
  108          | VAR . id-list ASSIGN expr
  109          | VAR . id-list ASSIGN obj-def
  110          | VAR . ID COLON var-type
  111          | VAR . ID COLON var-type ASSIGN expr
  112          | VAR . ID COLON var-type LBRACKET RBRACKET
  113          | VAR . ID COLON var-type LBRACKET RBRACKET ASSIGN expr

    ID  shift, and go to state 109

    id-list  go to state 110


State 27

   58 while-stmt: WHILE . LPAR expr RPAR LBRACE line RBRACE
   59           | WHILE . LPAR assign-expr RPAR LBRACE line RBRACE

    LPAR  shift, and go to state 111


State 28

  200 var-val: UNDEFINED .

    $default  reduce using rule 200 (var-val)


State 29

    0 $accept: line . $end

    $end  shift, and go to state 112


State 30

    1 line: stmt-list .
    3 stmt-list: stmt-list . stmt

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 1 (line)

    stmt             go to state 113
    assign-expr      go to state 32
    for-stmt         go to state 33
    do-while-stmt    go to state 34
    while-stmt       go to state 35
    if-stmt          go to state 36
    logic-expr       go to state 37
    class-def        go to state 38
    func-def         go to state 39
    var-declr        go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 31

    4 stmt-list: stmt .

    $default  reduce using rule 4 (stmt-list)


State 32

   10 stmt: assign-expr . SEMI

    SEMI  shift, and go to state 114


State 33

   14 stmt: for-stmt .

    $default  reduce using rule 14 (stmt)


State 34

   13 stmt: do-while-stmt .

    $default  reduce using rule 13 (stmt)


State 35

   12 stmt: while-stmt .

    $default  reduce using rule 12 (stmt)


State 36

   11 stmt: if-stmt .

    $default  reduce using rule 11 (stmt)


State 37

  138 idx-unsafe-expr: logic-expr .

    $default  reduce using rule 138 (idx-unsafe-expr)


State 38

    8 stmt: class-def .

    $default  reduce using rule 8 (stmt)


State 39

    7 stmt: func-def .

    $default  reduce using rule 7 (stmt)


State 40

    6 stmt: var-declr . $@1 SEMI

    $default  reduce using rule 5 ($@1)

    $@1  go to state 115


State 41

    9 stmt: expr . SEMI
   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  159 arit-expr: expr . PLUS expr
  160          | expr . SUB expr
  161          | expr . MULT expr
  162          | expr . DIV expr
  163          | expr . EXP expr
  164          | expr . REM expr
  165 bitw-expr: expr . BITWISE_AND expr
  166          | expr . BITWISE_OR expr
  167          | expr . BITWISE_XOR expr
  168 shift-expr: expr . LSHIFT expr
  169           | expr . RSHIFT expr
  170           | expr . RSHIFT_UNSIGNED expr

    SEMI             shift, and go to state 116
    PLUS             shift, and go to state 117
    SUB              shift, and go to state 118
    MULT             shift, and go to state 119
    DIV              shift, and go to state 120
    EXP              shift, and go to state 121
    REM              shift, and go to state 122
    BITWISE_AND      shift, and go to state 123
    BITWISE_OR       shift, and go to state 124
    BITWISE_XOR      shift, and go to state 125
    LOGICAL_NULL     shift, and go to state 126
    LOGICAL_AND      shift, and go to state 127
    LOGICAL_OR       shift, and go to state 128
    EQ               shift, and go to state 129
    EQ_STRICT        shift, and go to state 130
    INEQ             shift, and go to state 131
    INEQ_STRICT      shift, and go to state 132
    LT               shift, and go to state 133
    LT_EQ            shift, and go to state 134
    GT               shift, and go to state 135
    GT_EQ            shift, and go to state 136
    LSHIFT           shift, and go to state 137
    RSHIFT           shift, and go to state 138
    RSHIFT_UNSIGNED  shift, and go to state 139


State 42

  135 expr: idx-unsafe-expr .

    $default  reduce using rule 135 (expr)


State 43

  134 expr: idx-safe-expr .

    $default  reduce using rule 134 (expr)


State 44

   21 assign-expr: vet-idx . assignment expr
  146 idx-safe-expr: vet-idx .

    ASSIGN                  shift, and go to state 72
    PLUS_ASSIGN             shift, and go to state 75
    SUB_ASSIGN              shift, and go to state 77
    MULT_ASSIGN             shift, and go to state 78
    DIV_ASSIGN              shift, and go to state 79
    EXP_ASSIGN              shift, and go to state 80
    REM_ASSIGN              shift, and go to state 81
    BITWISE_AND_ASSIGN      shift, and go to state 82
    BITWISE_OR_ASSIGN       shift, and go to state 83
    BITWISE_XOR_ASSIGN      shift, and go to state 84
    LOGICAL_NULL_ASSIGN     shift, and go to state 85
    LOGICAL_AND_ASSIGN      shift, and go to state 86
    LOGICAL_OR_ASSIGN       shift, and go to state 87
    LSHIFT_ASSIGN           shift, and go to state 89
    RSHIFT_ASSIGN           shift, and go to state 90
    RSHIFT_UNSIGNED_ASSIGN  shift, and go to state 91

    $default  reduce using rule 146 (idx-safe-expr)

    assignment  go to state 140


State 45

  145 idx-safe-expr: unary-expr .

    $default  reduce using rule 145 (idx-safe-expr)


State 46

  142 idx-safe-expr: arit-expr .

    $default  reduce using rule 142 (idx-safe-expr)


State 47

  143 idx-safe-expr: bitw-expr .

    $default  reduce using rule 143 (idx-safe-expr)


State 48

  144 idx-safe-expr: shift-expr .

    $default  reduce using rule 144 (idx-safe-expr)


State 49

   19 assign-expr: var-att . assignment expr
  141 idx-safe-expr: var-att .
  154 unary-expr: var-att . INCREMENT
  156           | var-att . DECREMENT
  172 var-att: var-att . DOT ID
  176        | var-att . DOT var-met

    ASSIGN                  shift, and go to state 72
    DOT                     shift, and go to state 141
    INCREMENT               shift, and go to state 142
    PLUS_ASSIGN             shift, and go to state 75
    DECREMENT               shift, and go to state 143
    SUB_ASSIGN              shift, and go to state 77
    MULT_ASSIGN             shift, and go to state 78
    DIV_ASSIGN              shift, and go to state 79
    EXP_ASSIGN              shift, and go to state 80
    REM_ASSIGN              shift, and go to state 81
    BITWISE_AND_ASSIGN      shift, and go to state 82
    BITWISE_OR_ASSIGN       shift, and go to state 83
    BITWISE_XOR_ASSIGN      shift, and go to state 84
    LOGICAL_NULL_ASSIGN     shift, and go to state 85
    LOGICAL_AND_ASSIGN      shift, and go to state 86
    LOGICAL_OR_ASSIGN       shift, and go to state 87
    LSHIFT_ASSIGN           shift, and go to state 89
    RSHIFT_ASSIGN           shift, and go to state 90
    RSHIFT_UNSIGNED_ASSIGN  shift, and go to state 91

    $default  reduce using rule 141 (idx-safe-expr)

    assignment  go to state 144


State 50

  174 var-att: var-met . DOT ID
  175        | var-met . DOT var-att

    DOT  shift, and go to state 145


State 51

  139 idx-unsafe-expr: var-obj .

    $default  reduce using rule 139 (idx-unsafe-expr)


State 52

  140 idx-safe-expr: var-val .

    $default  reduce using rule 140 (idx-safe-expr)


State 53

  137 idx-unsafe-expr: array-expr .

    $default  reduce using rule 137 (idx-unsafe-expr)


State 54

  149 unary-expr: INCREMENT ID .
  171 var-att: ID . DOT var-att
  173        | ID . DOT var-met
  177        | ID . DOT ID
  178 var-met: ID . LPAR args-list RPAR

    DOT   shift, and go to state 73
    LPAR  shift, and go to state 146

    $default  reduce using rule 149 (unary-expr)


State 55

  150 unary-expr: INCREMENT var-att .
  172 var-att: var-att . DOT ID
  176        | var-att . DOT var-met

    DOT  shift, and go to state 141

    $default  reduce using rule 150 (unary-expr)


State 56

  194 var-val: SUB INT_VAL .

    $default  reduce using rule 194 (var-val)


State 57

  195 var-val: SUB REAL_VAL .

    $default  reduce using rule 195 (var-val)


State 58

  196 var-val: SUB STR_VAL .

    $default  reduce using rule 196 (var-val)


State 59

  198 var-val: SUB FALSE_RW .

    $default  reduce using rule 198 (var-val)


State 60

  197 var-val: SUB TRUE_RW .

    $default  reduce using rule 197 (var-val)


State 61

  151 unary-expr: DECREMENT ID .
  171 var-att: ID . DOT var-att
  173        | ID . DOT var-met
  177        | ID . DOT ID
  178 var-met: ID . LPAR args-list RPAR

    DOT   shift, and go to state 73
    LPAR  shift, and go to state 146

    $default  reduce using rule 151 (unary-expr)


State 62

  152 unary-expr: DECREMENT var-att .
  172 var-att: var-att . DOT ID
  176        | var-att . DOT var-met

    DOT  shift, and go to state 141

    $default  reduce using rule 152 (unary-expr)


State 63

   71 logic-expr: ID . LT expr
  147 idx-safe-expr: ID .
  148 vet-idx: ID . LBRACKET idx-safe-expr RBRACKET
  153 unary-expr: ID . INCREMENT
  155           | ID . DECREMENT
  171 var-att: ID . DOT var-att
  173        | ID . DOT var-met
  177        | ID . DOT ID
  178 var-met: ID . LPAR args-list RPAR
  185 var-obj: ID . LPAR args-list RPAR
  186        | ID . LT var-type GT LPAR args-list RPAR

    DOT        shift, and go to state 73
    INCREMENT  shift, and go to state 74
    DECREMENT  shift, and go to state 76
    LT         shift, and go to state 88
    LPAR       shift, and go to state 92
    LBRACKET   shift, and go to state 93

    $default  reduce using rule 147 (idx-safe-expr)


State 64

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  158 unary-expr: BITWISE_NOT expr .
  159 arit-expr: expr . PLUS expr
  160          | expr . SUB expr
  161          | expr . MULT expr
  162          | expr . DIV expr
  163          | expr . EXP expr
  164          | expr . REM expr
  165 bitw-expr: expr . BITWISE_AND expr
  166          | expr . BITWISE_OR expr
  167          | expr . BITWISE_XOR expr
  168 shift-expr: expr . LSHIFT expr
  169           | expr . RSHIFT expr
  170           | expr . RSHIFT_UNSIGNED expr

    $default  reduce using rule 158 (unary-expr)


State 65

  146 idx-safe-expr: vet-idx .

    $default  reduce using rule 146 (idx-safe-expr)


State 66

  141 idx-safe-expr: var-att .
  154 unary-expr: var-att . INCREMENT
  156           | var-att . DECREMENT
  172 var-att: var-att . DOT ID
  176        | var-att . DOT var-met

    DOT        shift, and go to state 141
    INCREMENT  shift, and go to state 142
    DECREMENT  shift, and go to state 143

    $default  reduce using rule 141 (idx-safe-expr)


State 67

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  157 unary-expr: LOGICAL_NOT expr .
  159 arit-expr: expr . PLUS expr
  160          | expr . SUB expr
  161          | expr . MULT expr
  162          | expr . DIV expr
  163          | expr . EXP expr
  164          | expr . REM expr
  165 bitw-expr: expr . BITWISE_AND expr
  166          | expr . BITWISE_OR expr
  167          | expr . BITWISE_XOR expr
  168 shift-expr: expr . LSHIFT expr
  169           | expr . RSHIFT expr
  170           | expr . RSHIFT_UNSIGNED expr

    $default  reduce using rule 157 (unary-expr)


State 68

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  136 expr: LPAR expr . RPAR
  159 arit-expr: expr . PLUS expr
  160          | expr . SUB expr
  161          | expr . MULT expr
  162          | expr . DIV expr
  163          | expr . EXP expr
  164          | expr . REM expr
  165 bitw-expr: expr . BITWISE_AND expr
  166          | expr . BITWISE_OR expr
  167          | expr . BITWISE_XOR expr
  168 shift-expr: expr . LSHIFT expr
  169           | expr . RSHIFT expr
  170           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 117
    SUB              shift, and go to state 118
    MULT             shift, and go to state 119
    DIV              shift, and go to state 120
    EXP              shift, and go to state 121
    REM              shift, and go to state 122
    BITWISE_AND      shift, and go to state 123
    BITWISE_OR       shift, and go to state 124
    BITWISE_XOR      shift, and go to state 125
    LOGICAL_NULL     shift, and go to state 126
    LOGICAL_AND      shift, and go to state 127
    LOGICAL_OR       shift, and go to state 128
    EQ               shift, and go to state 129
    EQ_STRICT        shift, and go to state 130
    INEQ             shift, and go to state 131
    INEQ_STRICT      shift, and go to state 132
    LT               shift, and go to state 133
    LT_EQ            shift, and go to state 134
    GT               shift, and go to state 135
    GT_EQ            shift, and go to state 136
    LSHIFT           shift, and go to state 137
    RSHIFT           shift, and go to state 138
    RSHIFT_UNSIGNED  shift, and go to state 139
    RPAR             shift, and go to state 147


State 69

  202 elmts-list: COMMA . elmts-list

    COMMA      shift, and go to state 69
    SUB        shift, and go to state 2
    INT_VAL    shift, and go to state 8
    REAL_VAL   shift, and go to state 9
    STR_VAL    shift, and go to state 10
    FALSE_RW   shift, and go to state 17
    NULL_RW    shift, and go to state 23
    TRUE_RW    shift, and go to state 25
    UNDEFINED  shift, and go to state 28

    $default  reduce using rule 205 (elmts-list)

    var-val     go to state 70
    elmts-list  go to state 148


State 70

  203 elmts-list: var-val . COMMA elmts-list
  204           | var-val .

    COMMA  shift, and go to state 149

    $default  reduce using rule 204 (elmts-list)


State 71

  201 array-expr: LBRACKET elmts-list . RBRACKET

    RBRACKET  shift, and go to state 150


State 72

   40 assignment: ASSIGN .

    $default  reduce using rule 40 (assignment)


State 73

  171 var-att: ID DOT . var-att
  173        | ID DOT . var-met
  177        | ID DOT . ID

    ID  shift, and go to state 151

    var-att  go to state 152
    var-met  go to state 153


State 74

  153 unary-expr: ID INCREMENT .

    $default  reduce using rule 153 (unary-expr)


State 75

   44 assignment: PLUS_ASSIGN .

    $default  reduce using rule 44 (assignment)


State 76

  155 unary-expr: ID DECREMENT .

    $default  reduce using rule 155 (unary-expr)


State 77

   45 assignment: SUB_ASSIGN .

    $default  reduce using rule 45 (assignment)


State 78

   46 assignment: MULT_ASSIGN .

    $default  reduce using rule 46 (assignment)


State 79

   47 assignment: DIV_ASSIGN .

    $default  reduce using rule 47 (assignment)


State 80

   48 assignment: EXP_ASSIGN .

    $default  reduce using rule 48 (assignment)


State 81

   49 assignment: REM_ASSIGN .

    $default  reduce using rule 49 (assignment)


State 82

   50 assignment: BITWISE_AND_ASSIGN .

    $default  reduce using rule 50 (assignment)


State 83

   51 assignment: BITWISE_OR_ASSIGN .

    $default  reduce using rule 51 (assignment)


State 84

   52 assignment: BITWISE_XOR_ASSIGN .

    $default  reduce using rule 52 (assignment)


State 85

   41 assignment: LOGICAL_NULL_ASSIGN .

    $default  reduce using rule 41 (assignment)


State 86

   42 assignment: LOGICAL_AND_ASSIGN .

    $default  reduce using rule 42 (assignment)


State 87

   43 assignment: LOGICAL_OR_ASSIGN .

    $default  reduce using rule 43 (assignment)


State 88

   71 logic-expr: ID LT . expr
  186 var-obj: ID LT . var-type GT LPAR args-list RPAR

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    VOID_RW      shift, and go to state 154
    ANY          shift, and go to state 155
    BOOLTYPE     shift, and go to state 156
    NEVER        shift, and go to state 157
    NUMBER       shift, and go to state 158
    STRING       shift, and go to state 159
    UNDEFINED    shift, and go to state 28
    UNKNOWN      shift, and go to state 160

    logic-expr       go to state 37
    var-type         go to state 161
    expr             go to state 162
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 89

   53 assignment: LSHIFT_ASSIGN .

    $default  reduce using rule 53 (assignment)


State 90

   54 assignment: RSHIFT_ASSIGN .

    $default  reduce using rule 54 (assignment)


State 91

   55 assignment: RSHIFT_UNSIGNED_ASSIGN .

    $default  reduce using rule 55 (assignment)


State 92

  178 var-met: ID LPAR . args-list RPAR
  185 var-obj: ID LPAR . args-list RPAR

    COMMA        shift, and go to state 163
    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 184 (args-list)

    assign-expr      go to state 164
    logic-expr       go to state 37
    expr             go to state 165
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    args-list        go to state 166
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 93

  148 vet-idx: ID LBRACKET . idx-safe-expr RBRACKET

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 37
    expr             go to state 167
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 168
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 94

   20 assign-expr: ID assignment . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 37
    expr             go to state 169
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 95

   17 stmt: BREAK SEMI .

    $default  reduce using rule 17 (stmt)


State 96

   78 class-def: CLASS ID . LBRACE class-att-list RBRACE

    LBRACE  shift, and go to state 170


State 97

  115 var-declr: CONST_RW ID . COLON var-type ASSIGN expr
  116          | CONST_RW ID . COLON var-type LBRACKET RBRACKET ASSIGN expr
  119 id-list: ID . $@2 COMMA id-list
  120        | ID .

    COLON  shift, and go to state 171

    ASSIGN    reduce using rule 120 (id-list)
    $default  reduce using rule 118 ($@2)

    $@2  go to state 172


State 98

  114 var-declr: CONST_RW id-list . ASSIGN expr
  117          | CONST_RW id-list . ASSIGN obj-def

    ASSIGN  shift, and go to state 173


State 99

   18 stmt: CONTINUE SEMI .

    $default  reduce using rule 18 (stmt)


State 100

   56 do-while-stmt: DO LBRACE . line RBRACE WHILE LPAR expr RPAR
   57              | DO LBRACE . line RBRACE WHILE LPAR assign-expr RPAR

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 2 (line)

    line             go to state 174
    stmt-list        go to state 30
    stmt             go to state 31
    assign-expr      go to state 32
    for-stmt         go to state 33
    do-while-stmt    go to state 34
    while-stmt       go to state 35
    if-stmt          go to state 36
    logic-expr       go to state 37
    class-def        go to state 38
    func-def         go to state 39
    var-declr        go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 101

   22 for-stmt: FOR LPAR . assign-expr SEMI expr SEMI expr RPAR LBRACE line RBRACE
   23         | FOR LPAR . assign-expr SEMI expr SEMI assign-expr RPAR LBRACE line RBRACE
   24         | FOR LPAR . assign-expr SEMI expr SEMI RPAR LBRACE line RBRACE
   25         | FOR LPAR . assign-expr SEMI SEMI expr RPAR LBRACE line RBRACE
   26         | FOR LPAR . assign-expr SEMI SEMI assign-expr RPAR LBRACE line RBRACE
   27         | FOR LPAR . assign-expr SEMI SEMI RPAR LBRACE line RBRACE
   28         | FOR LPAR . var-declr SEMI expr SEMI expr RPAR LBRACE line RBRACE
   29         | FOR LPAR . var-declr SEMI expr SEMI assign-expr RPAR LBRACE line RBRACE
   30         | FOR LPAR . var-declr SEMI expr SEMI RPAR LBRACE line RBRACE
   31         | FOR LPAR . var-declr SEMI SEMI expr RPAR LBRACE line RBRACE
   32         | FOR LPAR . var-declr SEMI SEMI assign-expr RPAR LBRACE line RBRACE
   33         | FOR LPAR . var-declr SEMI SEMI RPAR LBRACE line RBRACE
   34         | FOR LPAR . SEMI expr SEMI expr RPAR LBRACE line RBRACE
   35         | FOR LPAR . SEMI expr SEMI assign-expr RPAR LBRACE line RBRACE
   36         | FOR LPAR . SEMI expr SEMI RPAR LBRACE line RBRACE
   37         | FOR LPAR . SEMI SEMI expr RPAR LBRACE line RBRACE
   38         | FOR LPAR . SEMI SEMI assign-expr RPAR LBRACE line RBRACE
   39         | FOR LPAR . SEMI SEMI RPAR LBRACE line RBRACE

    SEMI      shift, and go to state 175
    ID        shift, and go to state 176
    CONST_RW  shift, and go to state 14
    LET       shift, and go to state 21
    VAR       shift, and go to state 26

    assign-expr  go to state 177
    var-declr    go to state 178
    vet-idx      go to state 179
    var-att      go to state 180
    var-met      go to state 50


State 102

   90 func-def: FUNCTION ID . LPAR params RPAR LBRACE line RBRACE
   91         | FUNCTION ID . LPAR params RPAR COLON var-type LBRACE line RBRACE

    LPAR  shift, and go to state 181


State 103

   60 if-stmt: IF LPAR . expr RPAR LBRACE line RBRACE
   61        | IF LPAR . expr RPAR LBRACE line RBRACE ELSE LBRACE line RBRACE
   62        | IF LPAR . expr RPAR LBRACE line RBRACE ELSE stmt
   63        | IF LPAR . assign-expr RPAR LBRACE line RBRACE
   64        | IF LPAR . assign-expr RPAR LBRACE line RBRACE ELSE LBRACE line RBRACE
   65        | IF LPAR . assign-expr RPAR LBRACE line RBRACE ELSE stmt

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    assign-expr      go to state 182
    logic-expr       go to state 37
    expr             go to state 183
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 104

  103 var-declr: LET ID . COLON var-type
  104          | LET ID . COLON var-type ASSIGN expr
  105          | LET ID . COLON var-type LBRACKET RBRACKET
  106          | LET ID . COLON var-type LBRACKET RBRACKET ASSIGN expr
  119 id-list: ID . $@2 COMMA id-list
  120        | ID .

    COLON  shift, and go to state 184

    COMMA     reduce using rule 118 ($@2)
    $default  reduce using rule 120 (id-list)

    $@2  go to state 172


State 105

  100 var-declr: LET id-list .
  101          | LET id-list . ASSIGN expr
  102          | LET id-list . ASSIGN obj-def

    ASSIGN  shift, and go to state 185

    $default  reduce using rule 100 (var-declr)


State 106

  187 var-obj: NEW ID . LPAR args-list RPAR
  188        | NEW ID . LT var-type GT LPAR args-list RPAR

    LT    shift, and go to state 186
    LPAR  shift, and go to state 187


State 107

   15 stmt: RETURN SEMI .

    $default  reduce using rule 15 (stmt)


State 108

   16 stmt: RETURN expr . SEMI
   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  159 arit-expr: expr . PLUS expr
  160          | expr . SUB expr
  161          | expr . MULT expr
  162          | expr . DIV expr
  163          | expr . EXP expr
  164          | expr . REM expr
  165 bitw-expr: expr . BITWISE_AND expr
  166          | expr . BITWISE_OR expr
  167          | expr . BITWISE_XOR expr
  168 shift-expr: expr . LSHIFT expr
  169           | expr . RSHIFT expr
  170           | expr . RSHIFT_UNSIGNED expr

    SEMI             shift, and go to state 188
    PLUS             shift, and go to state 117
    SUB              shift, and go to state 118
    MULT             shift, and go to state 119
    DIV              shift, and go to state 120
    EXP              shift, and go to state 121
    REM              shift, and go to state 122
    BITWISE_AND      shift, and go to state 123
    BITWISE_OR       shift, and go to state 124
    BITWISE_XOR      shift, and go to state 125
    LOGICAL_NULL     shift, and go to state 126
    LOGICAL_AND      shift, and go to state 127
    LOGICAL_OR       shift, and go to state 128
    EQ               shift, and go to state 129
    EQ_STRICT        shift, and go to state 130
    INEQ             shift, and go to state 131
    INEQ_STRICT      shift, and go to state 132
    LT               shift, and go to state 133
    LT_EQ            shift, and go to state 134
    GT               shift, and go to state 135
    GT_EQ            shift, and go to state 136
    LSHIFT           shift, and go to state 137
    RSHIFT           shift, and go to state 138
    RSHIFT_UNSIGNED  shift, and go to state 139


State 109

  110 var-declr: VAR ID . COLON var-type
  111          | VAR ID . COLON var-type ASSIGN expr
  112          | VAR ID . COLON var-type LBRACKET RBRACKET
  113          | VAR ID . COLON var-type LBRACKET RBRACKET ASSIGN expr
  119 id-list: ID . $@2 COMMA id-list
  120        | ID .

    COLON  shift, and go to state 189

    COMMA     reduce using rule 118 ($@2)
    $default  reduce using rule 120 (id-list)

    $@2  go to state 172


State 110

  107 var-declr: VAR id-list .
  108          | VAR id-list . ASSIGN expr
  109          | VAR id-list . ASSIGN obj-def

    ASSIGN  shift, and go to state 190

    $default  reduce using rule 107 (var-declr)


State 111

   58 while-stmt: WHILE LPAR . expr RPAR LBRACE line RBRACE
   59           | WHILE LPAR . assign-expr RPAR LBRACE line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    assign-expr      go to state 191
    logic-expr       go to state 37
    expr             go to state 192
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 112

    0 $accept: line $end .

    $default  accept


State 113

    3 stmt-list: stmt-list stmt .

    $default  reduce using rule 3 (stmt-list)


State 114

   10 stmt: assign-expr SEMI .

    $default  reduce using rule 10 (stmt)


State 115

    6 stmt: var-declr $@1 . SEMI

    SEMI  shift, and go to state 193


State 116

    9 stmt: expr SEMI .

    $default  reduce using rule 9 (stmt)


State 117

  159 arit-expr: expr PLUS . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 37
    expr             go to state 194
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 118

  160 arit-expr: expr SUB . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 37
    expr             go to state 195
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 119

  161 arit-expr: expr MULT . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 37
    expr             go to state 196
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 120

  162 arit-expr: expr DIV . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 37
    expr             go to state 197
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 121

  163 arit-expr: expr EXP . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 37
    expr             go to state 198
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 122

  164 arit-expr: expr REM . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 37
    expr             go to state 199
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 123

  165 bitw-expr: expr BITWISE_AND . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 37
    expr             go to state 200
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 124

  166 bitw-expr: expr BITWISE_OR . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 37
    expr             go to state 201
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 125

  167 bitw-expr: expr BITWISE_XOR . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 37
    expr             go to state 202
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 126

   75 logic-expr: expr LOGICAL_NULL . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 37
    expr             go to state 203
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 127

   76 logic-expr: expr LOGICAL_AND . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 37
    expr             go to state 204
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 128

   77 logic-expr: expr LOGICAL_OR . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 37
    expr             go to state 205
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 129

   66 logic-expr: expr EQ . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 37
    expr             go to state 206
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 130

   67 logic-expr: expr EQ_STRICT . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 37
    expr             go to state 207
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 131

   68 logic-expr: expr INEQ . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 37
    expr             go to state 208
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 132

   69 logic-expr: expr INEQ_STRICT . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 37
    expr             go to state 209
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 133

   70 logic-expr: expr LT . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 37
    expr             go to state 210
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 134

   72 logic-expr: expr LT_EQ . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 37
    expr             go to state 211
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 135

   73 logic-expr: expr GT . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 37
    expr             go to state 212
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 136

   74 logic-expr: expr GT_EQ . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 37
    expr             go to state 213
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 137

  168 shift-expr: expr LSHIFT . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 37
    expr             go to state 214
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 138

  169 shift-expr: expr RSHIFT . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 37
    expr             go to state 215
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 139

  170 shift-expr: expr RSHIFT_UNSIGNED . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 37
    expr             go to state 216
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 140

   21 assign-expr: vet-idx assignment . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 37
    expr             go to state 217
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 141

  172 var-att: var-att DOT . ID
  176        | var-att DOT . var-met

    ID  shift, and go to state 218

    var-met  go to state 219


State 142

  154 unary-expr: var-att INCREMENT .

    $default  reduce using rule 154 (unary-expr)


State 143

  156 unary-expr: var-att DECREMENT .

    $default  reduce using rule 156 (unary-expr)


State 144

   19 assign-expr: var-att assignment . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 37
    expr             go to state 220
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 145

  174 var-att: var-met DOT . ID
  175        | var-met DOT . var-att

    ID  shift, and go to state 221

    var-att  go to state 222
    var-met  go to state 50


State 146

  178 var-met: ID LPAR . args-list RPAR

    COMMA        shift, and go to state 163
    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 184 (args-list)

    assign-expr      go to state 164
    logic-expr       go to state 37
    expr             go to state 165
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    args-list        go to state 223
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 147

  136 expr: LPAR expr RPAR .

    $default  reduce using rule 136 (expr)


State 148

  202 elmts-list: COMMA elmts-list .

    $default  reduce using rule 202 (elmts-list)


State 149

  203 elmts-list: var-val COMMA . elmts-list

    COMMA      shift, and go to state 69
    SUB        shift, and go to state 2
    INT_VAL    shift, and go to state 8
    REAL_VAL   shift, and go to state 9
    STR_VAL    shift, and go to state 10
    FALSE_RW   shift, and go to state 17
    NULL_RW    shift, and go to state 23
    TRUE_RW    shift, and go to state 25
    UNDEFINED  shift, and go to state 28

    $default  reduce using rule 205 (elmts-list)

    var-val     go to state 70
    elmts-list  go to state 224


State 150

  201 array-expr: LBRACKET elmts-list RBRACKET .

    $default  reduce using rule 201 (array-expr)


State 151

  171 var-att: ID . DOT var-att
  173        | ID . DOT var-met
  177        | ID . DOT ID
  177        | ID DOT ID .
  178 var-met: ID . LPAR args-list RPAR

    DOT   shift, and go to state 73
    LPAR  shift, and go to state 146

    $default  reduce using rule 177 (var-att)


State 152

  171 var-att: ID DOT var-att .
  172        | var-att . DOT ID
  176        | var-att . DOT var-met

    DOT  shift, and go to state 141

    $default  reduce using rule 171 (var-att)


State 153

  173 var-att: ID DOT var-met .
  174        | var-met . DOT ID
  175        | var-met . DOT var-att

    DOT  shift, and go to state 145

    $default  reduce using rule 173 (var-att)


State 154

  132 var-type: VOID_RW .

    $default  reduce using rule 132 (var-type)


State 155

  131 var-type: ANY .

    $default  reduce using rule 131 (var-type)


State 156

  130 var-type: BOOLTYPE .

    $default  reduce using rule 130 (var-type)


State 157

  133 var-type: NEVER .

    $default  reduce using rule 133 (var-type)


State 158

  127 var-type: NUMBER .

    $default  reduce using rule 127 (var-type)


State 159

  128 var-type: STRING .

    $default  reduce using rule 128 (var-type)


State 160

  129 var-type: UNKNOWN .

    $default  reduce using rule 129 (var-type)


State 161

  186 var-obj: ID LT var-type . GT LPAR args-list RPAR

    GT  shift, and go to state 225


State 162

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   71           | ID LT expr .
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  159 arit-expr: expr . PLUS expr
  160          | expr . SUB expr
  161          | expr . MULT expr
  162          | expr . DIV expr
  163          | expr . EXP expr
  164          | expr . REM expr
  165 bitw-expr: expr . BITWISE_AND expr
  166          | expr . BITWISE_OR expr
  167          | expr . BITWISE_XOR expr
  168 shift-expr: expr . LSHIFT expr
  169           | expr . RSHIFT expr
  170           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 117
    SUB              shift, and go to state 118
    MULT             shift, and go to state 119
    DIV              shift, and go to state 120
    EXP              shift, and go to state 121
    REM              shift, and go to state 122
    BITWISE_AND      shift, and go to state 123
    BITWISE_OR       shift, and go to state 124
    BITWISE_XOR      shift, and go to state 125
    LSHIFT           shift, and go to state 137
    RSHIFT           shift, and go to state 138
    RSHIFT_UNSIGNED  shift, and go to state 139

    $default  reduce using rule 71 (logic-expr)


State 163

  179 args-list: COMMA . args-list

    COMMA        shift, and go to state 163
    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 184 (args-list)

    assign-expr      go to state 164
    logic-expr       go to state 37
    expr             go to state 165
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    args-list        go to state 226
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 164

  181 args-list: assign-expr . COMMA args-list
  183          | assign-expr .

    COMMA  shift, and go to state 227

    $default  reduce using rule 183 (args-list)


State 165

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  159 arit-expr: expr . PLUS expr
  160          | expr . SUB expr
  161          | expr . MULT expr
  162          | expr . DIV expr
  163          | expr . EXP expr
  164          | expr . REM expr
  165 bitw-expr: expr . BITWISE_AND expr
  166          | expr . BITWISE_OR expr
  167          | expr . BITWISE_XOR expr
  168 shift-expr: expr . LSHIFT expr
  169           | expr . RSHIFT expr
  170           | expr . RSHIFT_UNSIGNED expr
  180 args-list: expr . COMMA args-list
  182          | expr .

    COMMA            shift, and go to state 228
    PLUS             shift, and go to state 117
    SUB              shift, and go to state 118
    MULT             shift, and go to state 119
    DIV              shift, and go to state 120
    EXP              shift, and go to state 121
    REM              shift, and go to state 122
    BITWISE_AND      shift, and go to state 123
    BITWISE_OR       shift, and go to state 124
    BITWISE_XOR      shift, and go to state 125
    LOGICAL_NULL     shift, and go to state 126
    LOGICAL_AND      shift, and go to state 127
    LOGICAL_OR       shift, and go to state 128
    EQ               shift, and go to state 129
    EQ_STRICT        shift, and go to state 130
    INEQ             shift, and go to state 131
    INEQ_STRICT      shift, and go to state 132
    LT               shift, and go to state 133
    LT_EQ            shift, and go to state 134
    GT               shift, and go to state 135
    GT_EQ            shift, and go to state 136
    LSHIFT           shift, and go to state 137
    RSHIFT           shift, and go to state 138
    RSHIFT_UNSIGNED  shift, and go to state 139

    $default  reduce using rule 182 (args-list)


State 166

  178 var-met: ID LPAR args-list . RPAR
  185 var-obj: ID LPAR args-list . RPAR

    RPAR  shift, and go to state 229


State 167

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  159 arit-expr: expr . PLUS expr
  160          | expr . SUB expr
  161          | expr . MULT expr
  162          | expr . DIV expr
  163          | expr . EXP expr
  164          | expr . REM expr
  165 bitw-expr: expr . BITWISE_AND expr
  166          | expr . BITWISE_OR expr
  167          | expr . BITWISE_XOR expr
  168 shift-expr: expr . LSHIFT expr
  169           | expr . RSHIFT expr
  170           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 117
    SUB              shift, and go to state 118
    MULT             shift, and go to state 119
    DIV              shift, and go to state 120
    EXP              shift, and go to state 121
    REM              shift, and go to state 122
    BITWISE_AND      shift, and go to state 123
    BITWISE_OR       shift, and go to state 124
    BITWISE_XOR      shift, and go to state 125
    LOGICAL_NULL     shift, and go to state 126
    LOGICAL_AND      shift, and go to state 127
    LOGICAL_OR       shift, and go to state 128
    EQ               shift, and go to state 129
    EQ_STRICT        shift, and go to state 130
    INEQ             shift, and go to state 131
    INEQ_STRICT      shift, and go to state 132
    LT               shift, and go to state 133
    LT_EQ            shift, and go to state 134
    GT               shift, and go to state 135
    GT_EQ            shift, and go to state 136
    LSHIFT           shift, and go to state 137
    RSHIFT           shift, and go to state 138
    RSHIFT_UNSIGNED  shift, and go to state 139


State 168

  134 expr: idx-safe-expr .
  148 vet-idx: ID LBRACKET idx-safe-expr . RBRACKET

    RBRACKET  shift, and go to state 230

    $default  reduce using rule 134 (expr)


State 169

   20 assign-expr: ID assignment expr .
   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  159 arit-expr: expr . PLUS expr
  160          | expr . SUB expr
  161          | expr . MULT expr
  162          | expr . DIV expr
  163          | expr . EXP expr
  164          | expr . REM expr
  165 bitw-expr: expr . BITWISE_AND expr
  166          | expr . BITWISE_OR expr
  167          | expr . BITWISE_XOR expr
  168 shift-expr: expr . LSHIFT expr
  169           | expr . RSHIFT expr
  170           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 117
    SUB              shift, and go to state 118
    MULT             shift, and go to state 119
    DIV              shift, and go to state 120
    EXP              shift, and go to state 121
    REM              shift, and go to state 122
    BITWISE_AND      shift, and go to state 123
    BITWISE_OR       shift, and go to state 124
    BITWISE_XOR      shift, and go to state 125
    LOGICAL_NULL     shift, and go to state 126
    LOGICAL_AND      shift, and go to state 127
    LOGICAL_OR       shift, and go to state 128
    EQ               shift, and go to state 129
    EQ_STRICT        shift, and go to state 130
    INEQ             shift, and go to state 131
    INEQ_STRICT      shift, and go to state 132
    LT               shift, and go to state 133
    LT_EQ            shift, and go to state 134
    GT               shift, and go to state 135
    GT_EQ            shift, and go to state 136
    LSHIFT           shift, and go to state 137
    RSHIFT           shift, and go to state 138
    RSHIFT_UNSIGNED  shift, and go to state 139

    $default  reduce using rule 20 (assign-expr)


State 170

   78 class-def: CLASS ID LBRACE . class-att-list RBRACE

    SEMI       shift, and go to state 231
    ID         shift, and go to state 232
    PRIVATE    shift, and go to state 233
    PROTECTED  shift, and go to state 234
    PUBLIC     shift, and go to state 235

    $default  reduce using rule 82 (class-att-list)

    class-att-list  go to state 236
    class-att       go to state 237
    access-modif    go to state 238


State 171

  115 var-declr: CONST_RW ID COLON . var-type ASSIGN expr
  116          | CONST_RW ID COLON . var-type LBRACKET RBRACKET ASSIGN expr

    VOID_RW   shift, and go to state 154
    ANY       shift, and go to state 155
    BOOLTYPE  shift, and go to state 156
    NEVER     shift, and go to state 157
    NUMBER    shift, and go to state 158
    STRING    shift, and go to state 159
    UNKNOWN   shift, and go to state 160

    var-type  go to state 239


State 172

  119 id-list: ID $@2 . COMMA id-list

    COMMA  shift, and go to state 240


State 173

  114 var-declr: CONST_RW id-list ASSIGN . expr
  117          | CONST_RW id-list ASSIGN . obj-def

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACE       shift, and go to state 241
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 37
    obj-def          go to state 242
    expr             go to state 243
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 174

   56 do-while-stmt: DO LBRACE line . RBRACE WHILE LPAR expr RPAR
   57              | DO LBRACE line . RBRACE WHILE LPAR assign-expr RPAR

    RBRACE  shift, and go to state 244


State 175

   34 for-stmt: FOR LPAR SEMI . expr SEMI expr RPAR LBRACE line RBRACE
   35         | FOR LPAR SEMI . expr SEMI assign-expr RPAR LBRACE line RBRACE
   36         | FOR LPAR SEMI . expr SEMI RPAR LBRACE line RBRACE
   37         | FOR LPAR SEMI . SEMI expr RPAR LBRACE line RBRACE
   38         | FOR LPAR SEMI . SEMI assign-expr RPAR LBRACE line RBRACE
   39         | FOR LPAR SEMI . SEMI RPAR LBRACE line RBRACE

    SEMI         shift, and go to state 245
    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 37
    expr             go to state 246
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 176

   20 assign-expr: ID . assignment expr
  148 vet-idx: ID . LBRACKET idx-safe-expr RBRACKET
  171 var-att: ID . DOT var-att
  173        | ID . DOT var-met
  177        | ID . DOT ID
  178 var-met: ID . LPAR args-list RPAR

    ASSIGN                  shift, and go to state 72
    DOT                     shift, and go to state 73
    PLUS_ASSIGN             shift, and go to state 75
    SUB_ASSIGN              shift, and go to state 77
    MULT_ASSIGN             shift, and go to state 78
    DIV_ASSIGN              shift, and go to state 79
    EXP_ASSIGN              shift, and go to state 80
    REM_ASSIGN              shift, and go to state 81
    BITWISE_AND_ASSIGN      shift, and go to state 82
    BITWISE_OR_ASSIGN       shift, and go to state 83
    BITWISE_XOR_ASSIGN      shift, and go to state 84
    LOGICAL_NULL_ASSIGN     shift, and go to state 85
    LOGICAL_AND_ASSIGN      shift, and go to state 86
    LOGICAL_OR_ASSIGN       shift, and go to state 87
    LSHIFT_ASSIGN           shift, and go to state 89
    RSHIFT_ASSIGN           shift, and go to state 90
    RSHIFT_UNSIGNED_ASSIGN  shift, and go to state 91
    LPAR                    shift, and go to state 146
    LBRACKET                shift, and go to state 93

    assignment  go to state 94


State 177

   22 for-stmt: FOR LPAR assign-expr . SEMI expr SEMI expr RPAR LBRACE line RBRACE
   23         | FOR LPAR assign-expr . SEMI expr SEMI assign-expr RPAR LBRACE line RBRACE
   24         | FOR LPAR assign-expr . SEMI expr SEMI RPAR LBRACE line RBRACE
   25         | FOR LPAR assign-expr . SEMI SEMI expr RPAR LBRACE line RBRACE
   26         | FOR LPAR assign-expr . SEMI SEMI assign-expr RPAR LBRACE line RBRACE
   27         | FOR LPAR assign-expr . SEMI SEMI RPAR LBRACE line RBRACE

    SEMI  shift, and go to state 247


State 178

   28 for-stmt: FOR LPAR var-declr . SEMI expr SEMI expr RPAR LBRACE line RBRACE
   29         | FOR LPAR var-declr . SEMI expr SEMI assign-expr RPAR LBRACE line RBRACE
   30         | FOR LPAR var-declr . SEMI expr SEMI RPAR LBRACE line RBRACE
   31         | FOR LPAR var-declr . SEMI SEMI expr RPAR LBRACE line RBRACE
   32         | FOR LPAR var-declr . SEMI SEMI assign-expr RPAR LBRACE line RBRACE
   33         | FOR LPAR var-declr . SEMI SEMI RPAR LBRACE line RBRACE

    SEMI  shift, and go to state 248


State 179

   21 assign-expr: vet-idx . assignment expr

    ASSIGN                  shift, and go to state 72
    PLUS_ASSIGN             shift, and go to state 75
    SUB_ASSIGN              shift, and go to state 77
    MULT_ASSIGN             shift, and go to state 78
    DIV_ASSIGN              shift, and go to state 79
    EXP_ASSIGN              shift, and go to state 80
    REM_ASSIGN              shift, and go to state 81
    BITWISE_AND_ASSIGN      shift, and go to state 82
    BITWISE_OR_ASSIGN       shift, and go to state 83
    BITWISE_XOR_ASSIGN      shift, and go to state 84
    LOGICAL_NULL_ASSIGN     shift, and go to state 85
    LOGICAL_AND_ASSIGN      shift, and go to state 86
    LOGICAL_OR_ASSIGN       shift, and go to state 87
    LSHIFT_ASSIGN           shift, and go to state 89
    RSHIFT_ASSIGN           shift, and go to state 90
    RSHIFT_UNSIGNED_ASSIGN  shift, and go to state 91

    assignment  go to state 140


State 180

   19 assign-expr: var-att . assignment expr
  172 var-att: var-att . DOT ID
  176        | var-att . DOT var-met

    ASSIGN                  shift, and go to state 72
    DOT                     shift, and go to state 141
    PLUS_ASSIGN             shift, and go to state 75
    SUB_ASSIGN              shift, and go to state 77
    MULT_ASSIGN             shift, and go to state 78
    DIV_ASSIGN              shift, and go to state 79
    EXP_ASSIGN              shift, and go to state 80
    REM_ASSIGN              shift, and go to state 81
    BITWISE_AND_ASSIGN      shift, and go to state 82
    BITWISE_OR_ASSIGN       shift, and go to state 83
    BITWISE_XOR_ASSIGN      shift, and go to state 84
    LOGICAL_NULL_ASSIGN     shift, and go to state 85
    LOGICAL_AND_ASSIGN      shift, and go to state 86
    LOGICAL_OR_ASSIGN       shift, and go to state 87
    LSHIFT_ASSIGN           shift, and go to state 89
    RSHIFT_ASSIGN           shift, and go to state 90
    RSHIFT_UNSIGNED_ASSIGN  shift, and go to state 91

    assignment  go to state 144


State 181

   90 func-def: FUNCTION ID LPAR . params RPAR LBRACE line RBRACE
   91         | FUNCTION ID LPAR . params RPAR COLON var-type LBRACE line RBRACE

    COMMA  shift, and go to state 249
    ID     shift, and go to state 250

    $default  reduce using rule 99 (params)

    params  go to state 251


State 182

   63 if-stmt: IF LPAR assign-expr . RPAR LBRACE line RBRACE
   64        | IF LPAR assign-expr . RPAR LBRACE line RBRACE ELSE LBRACE line RBRACE
   65        | IF LPAR assign-expr . RPAR LBRACE line RBRACE ELSE stmt

    RPAR  shift, and go to state 252


State 183

   60 if-stmt: IF LPAR expr . RPAR LBRACE line RBRACE
   61        | IF LPAR expr . RPAR LBRACE line RBRACE ELSE LBRACE line RBRACE
   62        | IF LPAR expr . RPAR LBRACE line RBRACE ELSE stmt
   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  159 arit-expr: expr . PLUS expr
  160          | expr . SUB expr
  161          | expr . MULT expr
  162          | expr . DIV expr
  163          | expr . EXP expr
  164          | expr . REM expr
  165 bitw-expr: expr . BITWISE_AND expr
  166          | expr . BITWISE_OR expr
  167          | expr . BITWISE_XOR expr
  168 shift-expr: expr . LSHIFT expr
  169           | expr . RSHIFT expr
  170           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 117
    SUB              shift, and go to state 118
    MULT             shift, and go to state 119
    DIV              shift, and go to state 120
    EXP              shift, and go to state 121
    REM              shift, and go to state 122
    BITWISE_AND      shift, and go to state 123
    BITWISE_OR       shift, and go to state 124
    BITWISE_XOR      shift, and go to state 125
    LOGICAL_NULL     shift, and go to state 126
    LOGICAL_AND      shift, and go to state 127
    LOGICAL_OR       shift, and go to state 128
    EQ               shift, and go to state 129
    EQ_STRICT        shift, and go to state 130
    INEQ             shift, and go to state 131
    INEQ_STRICT      shift, and go to state 132
    LT               shift, and go to state 133
    LT_EQ            shift, and go to state 134
    GT               shift, and go to state 135
    GT_EQ            shift, and go to state 136
    LSHIFT           shift, and go to state 137
    RSHIFT           shift, and go to state 138
    RSHIFT_UNSIGNED  shift, and go to state 139
    RPAR             shift, and go to state 253


State 184

  103 var-declr: LET ID COLON . var-type
  104          | LET ID COLON . var-type ASSIGN expr
  105          | LET ID COLON . var-type LBRACKET RBRACKET
  106          | LET ID COLON . var-type LBRACKET RBRACKET ASSIGN expr

    VOID_RW   shift, and go to state 154
    ANY       shift, and go to state 155
    BOOLTYPE  shift, and go to state 156
    NEVER     shift, and go to state 157
    NUMBER    shift, and go to state 158
    STRING    shift, and go to state 159
    UNKNOWN   shift, and go to state 160

    var-type  go to state 254


State 185

  101 var-declr: LET id-list ASSIGN . expr
  102          | LET id-list ASSIGN . obj-def

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACE       shift, and go to state 241
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 37
    obj-def          go to state 255
    expr             go to state 256
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 186

  188 var-obj: NEW ID LT . var-type GT LPAR args-list RPAR

    VOID_RW   shift, and go to state 154
    ANY       shift, and go to state 155
    BOOLTYPE  shift, and go to state 156
    NEVER     shift, and go to state 157
    NUMBER    shift, and go to state 158
    STRING    shift, and go to state 159
    UNKNOWN   shift, and go to state 160

    var-type  go to state 257


State 187

  187 var-obj: NEW ID LPAR . args-list RPAR

    COMMA        shift, and go to state 163
    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 184 (args-list)

    assign-expr      go to state 164
    logic-expr       go to state 37
    expr             go to state 165
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    args-list        go to state 258
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 188

   16 stmt: RETURN expr SEMI .

    $default  reduce using rule 16 (stmt)


State 189

  110 var-declr: VAR ID COLON . var-type
  111          | VAR ID COLON . var-type ASSIGN expr
  112          | VAR ID COLON . var-type LBRACKET RBRACKET
  113          | VAR ID COLON . var-type LBRACKET RBRACKET ASSIGN expr

    VOID_RW   shift, and go to state 154
    ANY       shift, and go to state 155
    BOOLTYPE  shift, and go to state 156
    NEVER     shift, and go to state 157
    NUMBER    shift, and go to state 158
    STRING    shift, and go to state 159
    UNKNOWN   shift, and go to state 160

    var-type  go to state 259


State 190

  108 var-declr: VAR id-list ASSIGN . expr
  109          | VAR id-list ASSIGN . obj-def

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACE       shift, and go to state 241
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 37
    obj-def          go to state 260
    expr             go to state 261
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 191

   59 while-stmt: WHILE LPAR assign-expr . RPAR LBRACE line RBRACE

    RPAR  shift, and go to state 262


State 192

   58 while-stmt: WHILE LPAR expr . RPAR LBRACE line RBRACE
   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  159 arit-expr: expr . PLUS expr
  160          | expr . SUB expr
  161          | expr . MULT expr
  162          | expr . DIV expr
  163          | expr . EXP expr
  164          | expr . REM expr
  165 bitw-expr: expr . BITWISE_AND expr
  166          | expr . BITWISE_OR expr
  167          | expr . BITWISE_XOR expr
  168 shift-expr: expr . LSHIFT expr
  169           | expr . RSHIFT expr
  170           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 117
    SUB              shift, and go to state 118
    MULT             shift, and go to state 119
    DIV              shift, and go to state 120
    EXP              shift, and go to state 121
    REM              shift, and go to state 122
    BITWISE_AND      shift, and go to state 123
    BITWISE_OR       shift, and go to state 124
    BITWISE_XOR      shift, and go to state 125
    LOGICAL_NULL     shift, and go to state 126
    LOGICAL_AND      shift, and go to state 127
    LOGICAL_OR       shift, and go to state 128
    EQ               shift, and go to state 129
    EQ_STRICT        shift, and go to state 130
    INEQ             shift, and go to state 131
    INEQ_STRICT      shift, and go to state 132
    LT               shift, and go to state 133
    LT_EQ            shift, and go to state 134
    GT               shift, and go to state 135
    GT_EQ            shift, and go to state 136
    LSHIFT           shift, and go to state 137
    RSHIFT           shift, and go to state 138
    RSHIFT_UNSIGNED  shift, and go to state 139
    RPAR             shift, and go to state 263


State 193

    6 stmt: var-declr $@1 SEMI .

    $default  reduce using rule 6 (stmt)


State 194

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  159 arit-expr: expr . PLUS expr
  159          | expr PLUS expr .
  160          | expr . SUB expr
  161          | expr . MULT expr
  162          | expr . DIV expr
  163          | expr . EXP expr
  164          | expr . REM expr
  165 bitw-expr: expr . BITWISE_AND expr
  166          | expr . BITWISE_OR expr
  167          | expr . BITWISE_XOR expr
  168 shift-expr: expr . LSHIFT expr
  169           | expr . RSHIFT expr
  170           | expr . RSHIFT_UNSIGNED expr

    MULT  shift, and go to state 119
    DIV   shift, and go to state 120
    EXP   shift, and go to state 121
    REM   shift, and go to state 122

    $default  reduce using rule 159 (arit-expr)


State 195

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  159 arit-expr: expr . PLUS expr
  160          | expr . SUB expr
  160          | expr SUB expr .
  161          | expr . MULT expr
  162          | expr . DIV expr
  163          | expr . EXP expr
  164          | expr . REM expr
  165 bitw-expr: expr . BITWISE_AND expr
  166          | expr . BITWISE_OR expr
  167          | expr . BITWISE_XOR expr
  168 shift-expr: expr . LSHIFT expr
  169           | expr . RSHIFT expr
  170           | expr . RSHIFT_UNSIGNED expr

    MULT  shift, and go to state 119
    DIV   shift, and go to state 120
    EXP   shift, and go to state 121
    REM   shift, and go to state 122

    $default  reduce using rule 160 (arit-expr)


State 196

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  159 arit-expr: expr . PLUS expr
  160          | expr . SUB expr
  161          | expr . MULT expr
  161          | expr MULT expr .
  162          | expr . DIV expr
  163          | expr . EXP expr
  164          | expr . REM expr
  165 bitw-expr: expr . BITWISE_AND expr
  166          | expr . BITWISE_OR expr
  167          | expr . BITWISE_XOR expr
  168 shift-expr: expr . LSHIFT expr
  169           | expr . RSHIFT expr
  170           | expr . RSHIFT_UNSIGNED expr

    EXP  shift, and go to state 121

    $default  reduce using rule 161 (arit-expr)


State 197

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  159 arit-expr: expr . PLUS expr
  160          | expr . SUB expr
  161          | expr . MULT expr
  162          | expr . DIV expr
  162          | expr DIV expr .
  163          | expr . EXP expr
  164          | expr . REM expr
  165 bitw-expr: expr . BITWISE_AND expr
  166          | expr . BITWISE_OR expr
  167          | expr . BITWISE_XOR expr
  168 shift-expr: expr . LSHIFT expr
  169           | expr . RSHIFT expr
  170           | expr . RSHIFT_UNSIGNED expr

    EXP  shift, and go to state 121

    $default  reduce using rule 162 (arit-expr)


State 198

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  159 arit-expr: expr . PLUS expr
  160          | expr . SUB expr
  161          | expr . MULT expr
  162          | expr . DIV expr
  163          | expr . EXP expr
  163          | expr EXP expr .
  164          | expr . REM expr
  165 bitw-expr: expr . BITWISE_AND expr
  166          | expr . BITWISE_OR expr
  167          | expr . BITWISE_XOR expr
  168 shift-expr: expr . LSHIFT expr
  169           | expr . RSHIFT expr
  170           | expr . RSHIFT_UNSIGNED expr

    EXP  shift, and go to state 121

    $default  reduce using rule 163 (arit-expr)


State 199

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  159 arit-expr: expr . PLUS expr
  160          | expr . SUB expr
  161          | expr . MULT expr
  162          | expr . DIV expr
  163          | expr . EXP expr
  164          | expr . REM expr
  164          | expr REM expr .
  165 bitw-expr: expr . BITWISE_AND expr
  166          | expr . BITWISE_OR expr
  167          | expr . BITWISE_XOR expr
  168 shift-expr: expr . LSHIFT expr
  169           | expr . RSHIFT expr
  170           | expr . RSHIFT_UNSIGNED expr

    EXP  shift, and go to state 121

    $default  reduce using rule 164 (arit-expr)


State 200

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  159 arit-expr: expr . PLUS expr
  160          | expr . SUB expr
  161          | expr . MULT expr
  162          | expr . DIV expr
  163          | expr . EXP expr
  164          | expr . REM expr
  165 bitw-expr: expr . BITWISE_AND expr
  165          | expr BITWISE_AND expr .
  166          | expr . BITWISE_OR expr
  167          | expr . BITWISE_XOR expr
  168 shift-expr: expr . LSHIFT expr
  169           | expr . RSHIFT expr
  170           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 117
    SUB              shift, and go to state 118
    MULT             shift, and go to state 119
    DIV              shift, and go to state 120
    EXP              shift, and go to state 121
    REM              shift, and go to state 122
    LSHIFT           shift, and go to state 137
    RSHIFT           shift, and go to state 138
    RSHIFT_UNSIGNED  shift, and go to state 139

    $default  reduce using rule 165 (bitw-expr)


State 201

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  159 arit-expr: expr . PLUS expr
  160          | expr . SUB expr
  161          | expr . MULT expr
  162          | expr . DIV expr
  163          | expr . EXP expr
  164          | expr . REM expr
  165 bitw-expr: expr . BITWISE_AND expr
  166          | expr . BITWISE_OR expr
  166          | expr BITWISE_OR expr .
  167          | expr . BITWISE_XOR expr
  168 shift-expr: expr . LSHIFT expr
  169           | expr . RSHIFT expr
  170           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 117
    SUB              shift, and go to state 118
    MULT             shift, and go to state 119
    DIV              shift, and go to state 120
    EXP              shift, and go to state 121
    REM              shift, and go to state 122
    BITWISE_AND      shift, and go to state 123
    BITWISE_XOR      shift, and go to state 125
    LSHIFT           shift, and go to state 137
    RSHIFT           shift, and go to state 138
    RSHIFT_UNSIGNED  shift, and go to state 139

    $default  reduce using rule 166 (bitw-expr)


State 202

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  159 arit-expr: expr . PLUS expr
  160          | expr . SUB expr
  161          | expr . MULT expr
  162          | expr . DIV expr
  163          | expr . EXP expr
  164          | expr . REM expr
  165 bitw-expr: expr . BITWISE_AND expr
  166          | expr . BITWISE_OR expr
  167          | expr . BITWISE_XOR expr
  167          | expr BITWISE_XOR expr .
  168 shift-expr: expr . LSHIFT expr
  169           | expr . RSHIFT expr
  170           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 117
    SUB              shift, and go to state 118
    MULT             shift, and go to state 119
    DIV              shift, and go to state 120
    EXP              shift, and go to state 121
    REM              shift, and go to state 122
    BITWISE_AND      shift, and go to state 123
    LSHIFT           shift, and go to state 137
    RSHIFT           shift, and go to state 138
    RSHIFT_UNSIGNED  shift, and go to state 139

    $default  reduce using rule 167 (bitw-expr)


State 203

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   75           | expr LOGICAL_NULL expr .
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  159 arit-expr: expr . PLUS expr
  160          | expr . SUB expr
  161          | expr . MULT expr
  162          | expr . DIV expr
  163          | expr . EXP expr
  164          | expr . REM expr
  165 bitw-expr: expr . BITWISE_AND expr
  166          | expr . BITWISE_OR expr
  167          | expr . BITWISE_XOR expr
  168 shift-expr: expr . LSHIFT expr
  169           | expr . RSHIFT expr
  170           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 117
    SUB              shift, and go to state 118
    MULT             shift, and go to state 119
    DIV              shift, and go to state 120
    EXP              shift, and go to state 121
    REM              shift, and go to state 122
    BITWISE_AND      shift, and go to state 123
    BITWISE_OR       shift, and go to state 124
    BITWISE_XOR      shift, and go to state 125
    LSHIFT           shift, and go to state 137
    RSHIFT           shift, and go to state 138
    RSHIFT_UNSIGNED  shift, and go to state 139

    $default  reduce using rule 75 (logic-expr)


State 204

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   76           | expr LOGICAL_AND expr .
   77           | expr . LOGICAL_OR expr
  159 arit-expr: expr . PLUS expr
  160          | expr . SUB expr
  161          | expr . MULT expr
  162          | expr . DIV expr
  163          | expr . EXP expr
  164          | expr . REM expr
  165 bitw-expr: expr . BITWISE_AND expr
  166          | expr . BITWISE_OR expr
  167          | expr . BITWISE_XOR expr
  168 shift-expr: expr . LSHIFT expr
  169           | expr . RSHIFT expr
  170           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 117
    SUB              shift, and go to state 118
    MULT             shift, and go to state 119
    DIV              shift, and go to state 120
    EXP              shift, and go to state 121
    REM              shift, and go to state 122
    BITWISE_AND      shift, and go to state 123
    BITWISE_OR       shift, and go to state 124
    BITWISE_XOR      shift, and go to state 125
    LSHIFT           shift, and go to state 137
    RSHIFT           shift, and go to state 138
    RSHIFT_UNSIGNED  shift, and go to state 139

    $default  reduce using rule 76 (logic-expr)


State 205

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
   77           | expr LOGICAL_OR expr .
  159 arit-expr: expr . PLUS expr
  160          | expr . SUB expr
  161          | expr . MULT expr
  162          | expr . DIV expr
  163          | expr . EXP expr
  164          | expr . REM expr
  165 bitw-expr: expr . BITWISE_AND expr
  166          | expr . BITWISE_OR expr
  167          | expr . BITWISE_XOR expr
  168 shift-expr: expr . LSHIFT expr
  169           | expr . RSHIFT expr
  170           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 117
    SUB              shift, and go to state 118
    MULT             shift, and go to state 119
    DIV              shift, and go to state 120
    EXP              shift, and go to state 121
    REM              shift, and go to state 122
    BITWISE_AND      shift, and go to state 123
    BITWISE_OR       shift, and go to state 124
    BITWISE_XOR      shift, and go to state 125
    LSHIFT           shift, and go to state 137
    RSHIFT           shift, and go to state 138
    RSHIFT_UNSIGNED  shift, and go to state 139

    $default  reduce using rule 77 (logic-expr)


State 206

   66 logic-expr: expr . EQ expr
   66           | expr EQ expr .
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  159 arit-expr: expr . PLUS expr
  160          | expr . SUB expr
  161          | expr . MULT expr
  162          | expr . DIV expr
  163          | expr . EXP expr
  164          | expr . REM expr
  165 bitw-expr: expr . BITWISE_AND expr
  166          | expr . BITWISE_OR expr
  167          | expr . BITWISE_XOR expr
  168 shift-expr: expr . LSHIFT expr
  169           | expr . RSHIFT expr
  170           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 117
    SUB              shift, and go to state 118
    MULT             shift, and go to state 119
    DIV              shift, and go to state 120
    EXP              shift, and go to state 121
    REM              shift, and go to state 122
    BITWISE_AND      shift, and go to state 123
    BITWISE_OR       shift, and go to state 124
    BITWISE_XOR      shift, and go to state 125
    LSHIFT           shift, and go to state 137
    RSHIFT           shift, and go to state 138
    RSHIFT_UNSIGNED  shift, and go to state 139

    $default  reduce using rule 66 (logic-expr)


State 207

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   67           | expr EQ_STRICT expr .
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  159 arit-expr: expr . PLUS expr
  160          | expr . SUB expr
  161          | expr . MULT expr
  162          | expr . DIV expr
  163          | expr . EXP expr
  164          | expr . REM expr
  165 bitw-expr: expr . BITWISE_AND expr
  166          | expr . BITWISE_OR expr
  167          | expr . BITWISE_XOR expr
  168 shift-expr: expr . LSHIFT expr
  169           | expr . RSHIFT expr
  170           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 117
    SUB              shift, and go to state 118
    MULT             shift, and go to state 119
    DIV              shift, and go to state 120
    EXP              shift, and go to state 121
    REM              shift, and go to state 122
    BITWISE_AND      shift, and go to state 123
    BITWISE_OR       shift, and go to state 124
    BITWISE_XOR      shift, and go to state 125
    LSHIFT           shift, and go to state 137
    RSHIFT           shift, and go to state 138
    RSHIFT_UNSIGNED  shift, and go to state 139

    $default  reduce using rule 67 (logic-expr)


State 208

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   68           | expr INEQ expr .
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  159 arit-expr: expr . PLUS expr
  160          | expr . SUB expr
  161          | expr . MULT expr
  162          | expr . DIV expr
  163          | expr . EXP expr
  164          | expr . REM expr
  165 bitw-expr: expr . BITWISE_AND expr
  166          | expr . BITWISE_OR expr
  167          | expr . BITWISE_XOR expr
  168 shift-expr: expr . LSHIFT expr
  169           | expr . RSHIFT expr
  170           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 117
    SUB              shift, and go to state 118
    MULT             shift, and go to state 119
    DIV              shift, and go to state 120
    EXP              shift, and go to state 121
    REM              shift, and go to state 122
    BITWISE_AND      shift, and go to state 123
    BITWISE_OR       shift, and go to state 124
    BITWISE_XOR      shift, and go to state 125
    LSHIFT           shift, and go to state 137
    RSHIFT           shift, and go to state 138
    RSHIFT_UNSIGNED  shift, and go to state 139

    $default  reduce using rule 68 (logic-expr)


State 209

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   69           | expr INEQ_STRICT expr .
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  159 arit-expr: expr . PLUS expr
  160          | expr . SUB expr
  161          | expr . MULT expr
  162          | expr . DIV expr
  163          | expr . EXP expr
  164          | expr . REM expr
  165 bitw-expr: expr . BITWISE_AND expr
  166          | expr . BITWISE_OR expr
  167          | expr . BITWISE_XOR expr
  168 shift-expr: expr . LSHIFT expr
  169           | expr . RSHIFT expr
  170           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 117
    SUB              shift, and go to state 118
    MULT             shift, and go to state 119
    DIV              shift, and go to state 120
    EXP              shift, and go to state 121
    REM              shift, and go to state 122
    BITWISE_AND      shift, and go to state 123
    BITWISE_OR       shift, and go to state 124
    BITWISE_XOR      shift, and go to state 125
    LSHIFT           shift, and go to state 137
    RSHIFT           shift, and go to state 138
    RSHIFT_UNSIGNED  shift, and go to state 139

    $default  reduce using rule 69 (logic-expr)


State 210

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   70           | expr LT expr .
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  159 arit-expr: expr . PLUS expr
  160          | expr . SUB expr
  161          | expr . MULT expr
  162          | expr . DIV expr
  163          | expr . EXP expr
  164          | expr . REM expr
  165 bitw-expr: expr . BITWISE_AND expr
  166          | expr . BITWISE_OR expr
  167          | expr . BITWISE_XOR expr
  168 shift-expr: expr . LSHIFT expr
  169           | expr . RSHIFT expr
  170           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 117
    SUB              shift, and go to state 118
    MULT             shift, and go to state 119
    DIV              shift, and go to state 120
    EXP              shift, and go to state 121
    REM              shift, and go to state 122
    BITWISE_AND      shift, and go to state 123
    BITWISE_OR       shift, and go to state 124
    BITWISE_XOR      shift, and go to state 125
    LSHIFT           shift, and go to state 137
    RSHIFT           shift, and go to state 138
    RSHIFT_UNSIGNED  shift, and go to state 139

    $default  reduce using rule 70 (logic-expr)


State 211

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   72           | expr LT_EQ expr .
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  159 arit-expr: expr . PLUS expr
  160          | expr . SUB expr
  161          | expr . MULT expr
  162          | expr . DIV expr
  163          | expr . EXP expr
  164          | expr . REM expr
  165 bitw-expr: expr . BITWISE_AND expr
  166          | expr . BITWISE_OR expr
  167          | expr . BITWISE_XOR expr
  168 shift-expr: expr . LSHIFT expr
  169           | expr . RSHIFT expr
  170           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 117
    SUB              shift, and go to state 118
    MULT             shift, and go to state 119
    DIV              shift, and go to state 120
    EXP              shift, and go to state 121
    REM              shift, and go to state 122
    BITWISE_AND      shift, and go to state 123
    BITWISE_OR       shift, and go to state 124
    BITWISE_XOR      shift, and go to state 125
    LSHIFT           shift, and go to state 137
    RSHIFT           shift, and go to state 138
    RSHIFT_UNSIGNED  shift, and go to state 139

    $default  reduce using rule 72 (logic-expr)


State 212

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   73           | expr GT expr .
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  159 arit-expr: expr . PLUS expr
  160          | expr . SUB expr
  161          | expr . MULT expr
  162          | expr . DIV expr
  163          | expr . EXP expr
  164          | expr . REM expr
  165 bitw-expr: expr . BITWISE_AND expr
  166          | expr . BITWISE_OR expr
  167          | expr . BITWISE_XOR expr
  168 shift-expr: expr . LSHIFT expr
  169           | expr . RSHIFT expr
  170           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 117
    SUB              shift, and go to state 118
    MULT             shift, and go to state 119
    DIV              shift, and go to state 120
    EXP              shift, and go to state 121
    REM              shift, and go to state 122
    BITWISE_AND      shift, and go to state 123
    BITWISE_OR       shift, and go to state 124
    BITWISE_XOR      shift, and go to state 125
    LSHIFT           shift, and go to state 137
    RSHIFT           shift, and go to state 138
    RSHIFT_UNSIGNED  shift, and go to state 139

    $default  reduce using rule 73 (logic-expr)


State 213

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   74           | expr GT_EQ expr .
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  159 arit-expr: expr . PLUS expr
  160          | expr . SUB expr
  161          | expr . MULT expr
  162          | expr . DIV expr
  163          | expr . EXP expr
  164          | expr . REM expr
  165 bitw-expr: expr . BITWISE_AND expr
  166          | expr . BITWISE_OR expr
  167          | expr . BITWISE_XOR expr
  168 shift-expr: expr . LSHIFT expr
  169           | expr . RSHIFT expr
  170           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 117
    SUB              shift, and go to state 118
    MULT             shift, and go to state 119
    DIV              shift, and go to state 120
    EXP              shift, and go to state 121
    REM              shift, and go to state 122
    BITWISE_AND      shift, and go to state 123
    BITWISE_OR       shift, and go to state 124
    BITWISE_XOR      shift, and go to state 125
    LSHIFT           shift, and go to state 137
    RSHIFT           shift, and go to state 138
    RSHIFT_UNSIGNED  shift, and go to state 139

    $default  reduce using rule 74 (logic-expr)


State 214

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  159 arit-expr: expr . PLUS expr
  160          | expr . SUB expr
  161          | expr . MULT expr
  162          | expr . DIV expr
  163          | expr . EXP expr
  164          | expr . REM expr
  165 bitw-expr: expr . BITWISE_AND expr
  166          | expr . BITWISE_OR expr
  167          | expr . BITWISE_XOR expr
  168 shift-expr: expr . LSHIFT expr
  168           | expr LSHIFT expr .
  169           | expr . RSHIFT expr
  170           | expr . RSHIFT_UNSIGNED expr

    PLUS  shift, and go to state 117
    SUB   shift, and go to state 118
    MULT  shift, and go to state 119
    DIV   shift, and go to state 120
    EXP   shift, and go to state 121
    REM   shift, and go to state 122

    $default  reduce using rule 168 (shift-expr)


State 215

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  159 arit-expr: expr . PLUS expr
  160          | expr . SUB expr
  161          | expr . MULT expr
  162          | expr . DIV expr
  163          | expr . EXP expr
  164          | expr . REM expr
  165 bitw-expr: expr . BITWISE_AND expr
  166          | expr . BITWISE_OR expr
  167          | expr . BITWISE_XOR expr
  168 shift-expr: expr . LSHIFT expr
  169           | expr . RSHIFT expr
  169           | expr RSHIFT expr .
  170           | expr . RSHIFT_UNSIGNED expr

    PLUS  shift, and go to state 117
    SUB   shift, and go to state 118
    MULT  shift, and go to state 119
    DIV   shift, and go to state 120
    EXP   shift, and go to state 121
    REM   shift, and go to state 122

    $default  reduce using rule 169 (shift-expr)


State 216

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  159 arit-expr: expr . PLUS expr
  160          | expr . SUB expr
  161          | expr . MULT expr
  162          | expr . DIV expr
  163          | expr . EXP expr
  164          | expr . REM expr
  165 bitw-expr: expr . BITWISE_AND expr
  166          | expr . BITWISE_OR expr
  167          | expr . BITWISE_XOR expr
  168 shift-expr: expr . LSHIFT expr
  169           | expr . RSHIFT expr
  170           | expr . RSHIFT_UNSIGNED expr
  170           | expr RSHIFT_UNSIGNED expr .

    PLUS  shift, and go to state 117
    SUB   shift, and go to state 118
    MULT  shift, and go to state 119
    DIV   shift, and go to state 120
    EXP   shift, and go to state 121
    REM   shift, and go to state 122

    $default  reduce using rule 170 (shift-expr)


State 217

   21 assign-expr: vet-idx assignment expr .
   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  159 arit-expr: expr . PLUS expr
  160          | expr . SUB expr
  161          | expr . MULT expr
  162          | expr . DIV expr
  163          | expr . EXP expr
  164          | expr . REM expr
  165 bitw-expr: expr . BITWISE_AND expr
  166          | expr . BITWISE_OR expr
  167          | expr . BITWISE_XOR expr
  168 shift-expr: expr . LSHIFT expr
  169           | expr . RSHIFT expr
  170           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 117
    SUB              shift, and go to state 118
    MULT             shift, and go to state 119
    DIV              shift, and go to state 120
    EXP              shift, and go to state 121
    REM              shift, and go to state 122
    BITWISE_AND      shift, and go to state 123
    BITWISE_OR       shift, and go to state 124
    BITWISE_XOR      shift, and go to state 125
    LOGICAL_NULL     shift, and go to state 126
    LOGICAL_AND      shift, and go to state 127
    LOGICAL_OR       shift, and go to state 128
    EQ               shift, and go to state 129
    EQ_STRICT        shift, and go to state 130
    INEQ             shift, and go to state 131
    INEQ_STRICT      shift, and go to state 132
    LT               shift, and go to state 133
    LT_EQ            shift, and go to state 134
    GT               shift, and go to state 135
    GT_EQ            shift, and go to state 136
    LSHIFT           shift, and go to state 137
    RSHIFT           shift, and go to state 138
    RSHIFT_UNSIGNED  shift, and go to state 139

    $default  reduce using rule 21 (assign-expr)


State 218

  172 var-att: var-att DOT ID .
  178 var-met: ID . LPAR args-list RPAR

    LPAR  shift, and go to state 146

    $default  reduce using rule 172 (var-att)


State 219

  176 var-att: var-att DOT var-met .

    $default  reduce using rule 176 (var-att)


State 220

   19 assign-expr: var-att assignment expr .
   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  159 arit-expr: expr . PLUS expr
  160          | expr . SUB expr
  161          | expr . MULT expr
  162          | expr . DIV expr
  163          | expr . EXP expr
  164          | expr . REM expr
  165 bitw-expr: expr . BITWISE_AND expr
  166          | expr . BITWISE_OR expr
  167          | expr . BITWISE_XOR expr
  168 shift-expr: expr . LSHIFT expr
  169           | expr . RSHIFT expr
  170           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 117
    SUB              shift, and go to state 118
    MULT             shift, and go to state 119
    DIV              shift, and go to state 120
    EXP              shift, and go to state 121
    REM              shift, and go to state 122
    BITWISE_AND      shift, and go to state 123
    BITWISE_OR       shift, and go to state 124
    BITWISE_XOR      shift, and go to state 125
    LOGICAL_NULL     shift, and go to state 126
    LOGICAL_AND      shift, and go to state 127
    LOGICAL_OR       shift, and go to state 128
    EQ               shift, and go to state 129
    EQ_STRICT        shift, and go to state 130
    INEQ             shift, and go to state 131
    INEQ_STRICT      shift, and go to state 132
    LT               shift, and go to state 133
    LT_EQ            shift, and go to state 134
    GT               shift, and go to state 135
    GT_EQ            shift, and go to state 136
    LSHIFT           shift, and go to state 137
    RSHIFT           shift, and go to state 138
    RSHIFT_UNSIGNED  shift, and go to state 139

    $default  reduce using rule 19 (assign-expr)


State 221

  171 var-att: ID . DOT var-att
  173        | ID . DOT var-met
  174        | var-met DOT ID .
  177        | ID . DOT ID
  178 var-met: ID . LPAR args-list RPAR

    DOT   shift, and go to state 73
    LPAR  shift, and go to state 146

    $default  reduce using rule 174 (var-att)


State 222

  172 var-att: var-att . DOT ID
  175        | var-met DOT var-att .
  176        | var-att . DOT var-met

    DOT  shift, and go to state 141

    $default  reduce using rule 175 (var-att)


State 223

  178 var-met: ID LPAR args-list . RPAR

    RPAR  shift, and go to state 264


State 224

  203 elmts-list: var-val COMMA elmts-list .

    $default  reduce using rule 203 (elmts-list)


State 225

  186 var-obj: ID LT var-type GT . LPAR args-list RPAR

    LPAR  shift, and go to state 265


State 226

  179 args-list: COMMA args-list .

    $default  reduce using rule 179 (args-list)


State 227

  181 args-list: assign-expr COMMA . args-list

    COMMA        shift, and go to state 163
    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 184 (args-list)

    assign-expr      go to state 164
    logic-expr       go to state 37
    expr             go to state 165
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    args-list        go to state 266
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 228

  180 args-list: expr COMMA . args-list

    COMMA        shift, and go to state 163
    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 184 (args-list)

    assign-expr      go to state 164
    logic-expr       go to state 37
    expr             go to state 165
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    args-list        go to state 267
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 229

  178 var-met: ID LPAR args-list RPAR .
  185 var-obj: ID LPAR args-list RPAR .

    DOT       reduce using rule 178 (var-met)
    $default  reduce using rule 185 (var-obj)


State 230

  148 vet-idx: ID LBRACKET idx-safe-expr RBRACKET .

    $default  reduce using rule 148 (vet-idx)


State 231

   79 class-att-list: SEMI . class-att-list

    SEMI       shift, and go to state 231
    ID         shift, and go to state 232
    PRIVATE    shift, and go to state 233
    PROTECTED  shift, and go to state 234
    PUBLIC     shift, and go to state 235

    $default  reduce using rule 82 (class-att-list)

    class-att-list  go to state 268
    class-att       go to state 237
    access-modif    go to state 238


State 232

   83 class-att: ID . COLON var-type
   85          | ID . LPAR params RPAR LBRACE line RBRACE
   86          | ID . LPAR params RPAR COLON var-type LBRACE line RBRACE

    COLON  shift, and go to state 269
    LPAR   shift, and go to state 270


State 233

   88 access-modif: PRIVATE .

    $default  reduce using rule 88 (access-modif)


State 234

   89 access-modif: PROTECTED .

    $default  reduce using rule 89 (access-modif)


State 235

   87 access-modif: PUBLIC .

    $default  reduce using rule 87 (access-modif)


State 236

   78 class-def: CLASS ID LBRACE class-att-list . RBRACE

    RBRACE  shift, and go to state 271


State 237

   80 class-att-list: class-att . SEMI class-att-list
   81               | class-att .

    SEMI  shift, and go to state 272

    $default  reduce using rule 81 (class-att-list)


State 238

   84 class-att: access-modif . ID COLON var-type

    ID  shift, and go to state 273


State 239

  115 var-declr: CONST_RW ID COLON var-type . ASSIGN expr
  116          | CONST_RW ID COLON var-type . LBRACKET RBRACKET ASSIGN expr

    ASSIGN    shift, and go to state 274
    LBRACKET  shift, and go to state 275


State 240

  119 id-list: ID $@2 COMMA . id-list

    ID  shift, and go to state 276

    id-list  go to state 277


State 241

  121 obj-def: LBRACE . obj-att-list RBRACE

    COMMA  shift, and go to state 278
    ID     shift, and go to state 279

    $default  reduce using rule 125 (obj-att-list)

    obj-att-list  go to state 280
    obj-att       go to state 281


State 242

  117 var-declr: CONST_RW id-list ASSIGN obj-def .

    $default  reduce using rule 117 (var-declr)


State 243

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  114 var-declr: CONST_RW id-list ASSIGN expr .
  159 arit-expr: expr . PLUS expr
  160          | expr . SUB expr
  161          | expr . MULT expr
  162          | expr . DIV expr
  163          | expr . EXP expr
  164          | expr . REM expr
  165 bitw-expr: expr . BITWISE_AND expr
  166          | expr . BITWISE_OR expr
  167          | expr . BITWISE_XOR expr
  168 shift-expr: expr . LSHIFT expr
  169           | expr . RSHIFT expr
  170           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 117
    SUB              shift, and go to state 118
    MULT             shift, and go to state 119
    DIV              shift, and go to state 120
    EXP              shift, and go to state 121
    REM              shift, and go to state 122
    BITWISE_AND      shift, and go to state 123
    BITWISE_OR       shift, and go to state 124
    BITWISE_XOR      shift, and go to state 125
    LOGICAL_NULL     shift, and go to state 126
    LOGICAL_AND      shift, and go to state 127
    LOGICAL_OR       shift, and go to state 128
    EQ               shift, and go to state 129
    EQ_STRICT        shift, and go to state 130
    INEQ             shift, and go to state 131
    INEQ_STRICT      shift, and go to state 132
    LT               shift, and go to state 133
    LT_EQ            shift, and go to state 134
    GT               shift, and go to state 135
    GT_EQ            shift, and go to state 136
    LSHIFT           shift, and go to state 137
    RSHIFT           shift, and go to state 138
    RSHIFT_UNSIGNED  shift, and go to state 139

    $default  reduce using rule 114 (var-declr)


State 244

   56 do-while-stmt: DO LBRACE line RBRACE . WHILE LPAR expr RPAR
   57              | DO LBRACE line RBRACE . WHILE LPAR assign-expr RPAR

    WHILE  shift, and go to state 282


State 245

   37 for-stmt: FOR LPAR SEMI SEMI . expr RPAR LBRACE line RBRACE
   38         | FOR LPAR SEMI SEMI . assign-expr RPAR LBRACE line RBRACE
   39         | FOR LPAR SEMI SEMI . RPAR LBRACE line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    RPAR         shift, and go to state 283
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    assign-expr      go to state 284
    logic-expr       go to state 37
    expr             go to state 285
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 246

   34 for-stmt: FOR LPAR SEMI expr . SEMI expr RPAR LBRACE line RBRACE
   35         | FOR LPAR SEMI expr . SEMI assign-expr RPAR LBRACE line RBRACE
   36         | FOR LPAR SEMI expr . SEMI RPAR LBRACE line RBRACE
   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  159 arit-expr: expr . PLUS expr
  160          | expr . SUB expr
  161          | expr . MULT expr
  162          | expr . DIV expr
  163          | expr . EXP expr
  164          | expr . REM expr
  165 bitw-expr: expr . BITWISE_AND expr
  166          | expr . BITWISE_OR expr
  167          | expr . BITWISE_XOR expr
  168 shift-expr: expr . LSHIFT expr
  169           | expr . RSHIFT expr
  170           | expr . RSHIFT_UNSIGNED expr

    SEMI             shift, and go to state 286
    PLUS             shift, and go to state 117
    SUB              shift, and go to state 118
    MULT             shift, and go to state 119
    DIV              shift, and go to state 120
    EXP              shift, and go to state 121
    REM              shift, and go to state 122
    BITWISE_AND      shift, and go to state 123
    BITWISE_OR       shift, and go to state 124
    BITWISE_XOR      shift, and go to state 125
    LOGICAL_NULL     shift, and go to state 126
    LOGICAL_AND      shift, and go to state 127
    LOGICAL_OR       shift, and go to state 128
    EQ               shift, and go to state 129
    EQ_STRICT        shift, and go to state 130
    INEQ             shift, and go to state 131
    INEQ_STRICT      shift, and go to state 132
    LT               shift, and go to state 133
    LT_EQ            shift, and go to state 134
    GT               shift, and go to state 135
    GT_EQ            shift, and go to state 136
    LSHIFT           shift, and go to state 137
    RSHIFT           shift, and go to state 138
    RSHIFT_UNSIGNED  shift, and go to state 139


State 247

   22 for-stmt: FOR LPAR assign-expr SEMI . expr SEMI expr RPAR LBRACE line RBRACE
   23         | FOR LPAR assign-expr SEMI . expr SEMI assign-expr RPAR LBRACE line RBRACE
   24         | FOR LPAR assign-expr SEMI . expr SEMI RPAR LBRACE line RBRACE
   25         | FOR LPAR assign-expr SEMI . SEMI expr RPAR LBRACE line RBRACE
   26         | FOR LPAR assign-expr SEMI . SEMI assign-expr RPAR LBRACE line RBRACE
   27         | FOR LPAR assign-expr SEMI . SEMI RPAR LBRACE line RBRACE

    SEMI         shift, and go to state 287
    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 37
    expr             go to state 288
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 248

   28 for-stmt: FOR LPAR var-declr SEMI . expr SEMI expr RPAR LBRACE line RBRACE
   29         | FOR LPAR var-declr SEMI . expr SEMI assign-expr RPAR LBRACE line RBRACE
   30         | FOR LPAR var-declr SEMI . expr SEMI RPAR LBRACE line RBRACE
   31         | FOR LPAR var-declr SEMI . SEMI expr RPAR LBRACE line RBRACE
   32         | FOR LPAR var-declr SEMI . SEMI assign-expr RPAR LBRACE line RBRACE
   33         | FOR LPAR var-declr SEMI . SEMI RPAR LBRACE line RBRACE

    SEMI         shift, and go to state 289
    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 37
    expr             go to state 290
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 249

   92 params: COMMA . ID
   93       | COMMA . ID COLON var-type

    ID  shift, and go to state 291


State 250

   94 params: ID . COMMA ID
   95       | ID . COLON var-type COMMA ID COLON var-type
   96       | ID . COLON var-type COMMA ID
   97       | ID . COLON var-type
   98       | ID . COMMA ID COLON var-type

    COMMA  shift, and go to state 292
    COLON  shift, and go to state 293


State 251

   90 func-def: FUNCTION ID LPAR params . RPAR LBRACE line RBRACE
   91         | FUNCTION ID LPAR params . RPAR COLON var-type LBRACE line RBRACE

    RPAR  shift, and go to state 294


State 252

   63 if-stmt: IF LPAR assign-expr RPAR . LBRACE line RBRACE
   64        | IF LPAR assign-expr RPAR . LBRACE line RBRACE ELSE LBRACE line RBRACE
   65        | IF LPAR assign-expr RPAR . LBRACE line RBRACE ELSE stmt

    LBRACE  shift, and go to state 295


State 253

   60 if-stmt: IF LPAR expr RPAR . LBRACE line RBRACE
   61        | IF LPAR expr RPAR . LBRACE line RBRACE ELSE LBRACE line RBRACE
   62        | IF LPAR expr RPAR . LBRACE line RBRACE ELSE stmt

    LBRACE  shift, and go to state 296


State 254

  103 var-declr: LET ID COLON var-type .
  104          | LET ID COLON var-type . ASSIGN expr
  105          | LET ID COLON var-type . LBRACKET RBRACKET
  106          | LET ID COLON var-type . LBRACKET RBRACKET ASSIGN expr

    ASSIGN    shift, and go to state 297
    LBRACKET  shift, and go to state 298

    $default  reduce using rule 103 (var-declr)


State 255

  102 var-declr: LET id-list ASSIGN obj-def .

    $default  reduce using rule 102 (var-declr)


State 256

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  101 var-declr: LET id-list ASSIGN expr .
  159 arit-expr: expr . PLUS expr
  160          | expr . SUB expr
  161          | expr . MULT expr
  162          | expr . DIV expr
  163          | expr . EXP expr
  164          | expr . REM expr
  165 bitw-expr: expr . BITWISE_AND expr
  166          | expr . BITWISE_OR expr
  167          | expr . BITWISE_XOR expr
  168 shift-expr: expr . LSHIFT expr
  169           | expr . RSHIFT expr
  170           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 117
    SUB              shift, and go to state 118
    MULT             shift, and go to state 119
    DIV              shift, and go to state 120
    EXP              shift, and go to state 121
    REM              shift, and go to state 122
    BITWISE_AND      shift, and go to state 123
    BITWISE_OR       shift, and go to state 124
    BITWISE_XOR      shift, and go to state 125
    LOGICAL_NULL     shift, and go to state 126
    LOGICAL_AND      shift, and go to state 127
    LOGICAL_OR       shift, and go to state 128
    EQ               shift, and go to state 129
    EQ_STRICT        shift, and go to state 130
    INEQ             shift, and go to state 131
    INEQ_STRICT      shift, and go to state 132
    LT               shift, and go to state 133
    LT_EQ            shift, and go to state 134
    GT               shift, and go to state 135
    GT_EQ            shift, and go to state 136
    LSHIFT           shift, and go to state 137
    RSHIFT           shift, and go to state 138
    RSHIFT_UNSIGNED  shift, and go to state 139

    $default  reduce using rule 101 (var-declr)


State 257

  188 var-obj: NEW ID LT var-type . GT LPAR args-list RPAR

    GT  shift, and go to state 299


State 258

  187 var-obj: NEW ID LPAR args-list . RPAR

    RPAR  shift, and go to state 300


State 259

  110 var-declr: VAR ID COLON var-type .
  111          | VAR ID COLON var-type . ASSIGN expr
  112          | VAR ID COLON var-type . LBRACKET RBRACKET
  113          | VAR ID COLON var-type . LBRACKET RBRACKET ASSIGN expr

    ASSIGN    shift, and go to state 301
    LBRACKET  shift, and go to state 302

    $default  reduce using rule 110 (var-declr)


State 260

  109 var-declr: VAR id-list ASSIGN obj-def .

    $default  reduce using rule 109 (var-declr)


State 261

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  108 var-declr: VAR id-list ASSIGN expr .
  159 arit-expr: expr . PLUS expr
  160          | expr . SUB expr
  161          | expr . MULT expr
  162          | expr . DIV expr
  163          | expr . EXP expr
  164          | expr . REM expr
  165 bitw-expr: expr . BITWISE_AND expr
  166          | expr . BITWISE_OR expr
  167          | expr . BITWISE_XOR expr
  168 shift-expr: expr . LSHIFT expr
  169           | expr . RSHIFT expr
  170           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 117
    SUB              shift, and go to state 118
    MULT             shift, and go to state 119
    DIV              shift, and go to state 120
    EXP              shift, and go to state 121
    REM              shift, and go to state 122
    BITWISE_AND      shift, and go to state 123
    BITWISE_OR       shift, and go to state 124
    BITWISE_XOR      shift, and go to state 125
    LOGICAL_NULL     shift, and go to state 126
    LOGICAL_AND      shift, and go to state 127
    LOGICAL_OR       shift, and go to state 128
    EQ               shift, and go to state 129
    EQ_STRICT        shift, and go to state 130
    INEQ             shift, and go to state 131
    INEQ_STRICT      shift, and go to state 132
    LT               shift, and go to state 133
    LT_EQ            shift, and go to state 134
    GT               shift, and go to state 135
    GT_EQ            shift, and go to state 136
    LSHIFT           shift, and go to state 137
    RSHIFT           shift, and go to state 138
    RSHIFT_UNSIGNED  shift, and go to state 139

    $default  reduce using rule 108 (var-declr)


State 262

   59 while-stmt: WHILE LPAR assign-expr RPAR . LBRACE line RBRACE

    LBRACE  shift, and go to state 303


State 263

   58 while-stmt: WHILE LPAR expr RPAR . LBRACE line RBRACE

    LBRACE  shift, and go to state 304


State 264

  178 var-met: ID LPAR args-list RPAR .

    $default  reduce using rule 178 (var-met)


State 265

  186 var-obj: ID LT var-type GT LPAR . args-list RPAR

    COMMA        shift, and go to state 163
    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 184 (args-list)

    assign-expr      go to state 164
    logic-expr       go to state 37
    expr             go to state 165
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    args-list        go to state 305
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 266

  181 args-list: assign-expr COMMA args-list .

    $default  reduce using rule 181 (args-list)


State 267

  180 args-list: expr COMMA args-list .

    $default  reduce using rule 180 (args-list)


State 268

   79 class-att-list: SEMI class-att-list .

    $default  reduce using rule 79 (class-att-list)


State 269

   83 class-att: ID COLON . var-type

    VOID_RW   shift, and go to state 154
    ANY       shift, and go to state 155
    BOOLTYPE  shift, and go to state 156
    NEVER     shift, and go to state 157
    NUMBER    shift, and go to state 158
    STRING    shift, and go to state 159
    UNKNOWN   shift, and go to state 160

    var-type  go to state 306


State 270

   85 class-att: ID LPAR . params RPAR LBRACE line RBRACE
   86          | ID LPAR . params RPAR COLON var-type LBRACE line RBRACE

    COMMA  shift, and go to state 249
    ID     shift, and go to state 250

    $default  reduce using rule 99 (params)

    params  go to state 307


State 271

   78 class-def: CLASS ID LBRACE class-att-list RBRACE .

    $default  reduce using rule 78 (class-def)


State 272

   80 class-att-list: class-att SEMI . class-att-list

    SEMI       shift, and go to state 231
    ID         shift, and go to state 232
    PRIVATE    shift, and go to state 233
    PROTECTED  shift, and go to state 234
    PUBLIC     shift, and go to state 235

    $default  reduce using rule 82 (class-att-list)

    class-att-list  go to state 308
    class-att       go to state 237
    access-modif    go to state 238


State 273

   84 class-att: access-modif ID . COLON var-type

    COLON  shift, and go to state 309


State 274

  115 var-declr: CONST_RW ID COLON var-type ASSIGN . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 37
    expr             go to state 310
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 275

  116 var-declr: CONST_RW ID COLON var-type LBRACKET . RBRACKET ASSIGN expr

    RBRACKET  shift, and go to state 311


State 276

  119 id-list: ID . $@2 COMMA id-list
  120        | ID .

    COMMA     reduce using rule 118 ($@2)
    $default  reduce using rule 120 (id-list)

    $@2  go to state 172


State 277

  119 id-list: ID $@2 COMMA id-list .

    $default  reduce using rule 119 (id-list)


State 278

  122 obj-att-list: COMMA . obj-att-list

    COMMA  shift, and go to state 278
    ID     shift, and go to state 279

    $default  reduce using rule 125 (obj-att-list)

    obj-att-list  go to state 312
    obj-att       go to state 281


State 279

  126 obj-att: ID . COLON var-val

    COLON  shift, and go to state 313


State 280

  121 obj-def: LBRACE obj-att-list . RBRACE

    RBRACE  shift, and go to state 314


State 281

  123 obj-att-list: obj-att . COMMA obj-att-list
  124             | obj-att .

    COMMA  shift, and go to state 315

    $default  reduce using rule 124 (obj-att-list)


State 282

   56 do-while-stmt: DO LBRACE line RBRACE WHILE . LPAR expr RPAR
   57              | DO LBRACE line RBRACE WHILE . LPAR assign-expr RPAR

    LPAR  shift, and go to state 316


State 283

   39 for-stmt: FOR LPAR SEMI SEMI RPAR . LBRACE line RBRACE

    LBRACE  shift, and go to state 317


State 284

   38 for-stmt: FOR LPAR SEMI SEMI assign-expr . RPAR LBRACE line RBRACE

    RPAR  shift, and go to state 318


State 285

   37 for-stmt: FOR LPAR SEMI SEMI expr . RPAR LBRACE line RBRACE
   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  159 arit-expr: expr . PLUS expr
  160          | expr . SUB expr
  161          | expr . MULT expr
  162          | expr . DIV expr
  163          | expr . EXP expr
  164          | expr . REM expr
  165 bitw-expr: expr . BITWISE_AND expr
  166          | expr . BITWISE_OR expr
  167          | expr . BITWISE_XOR expr
  168 shift-expr: expr . LSHIFT expr
  169           | expr . RSHIFT expr
  170           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 117
    SUB              shift, and go to state 118
    MULT             shift, and go to state 119
    DIV              shift, and go to state 120
    EXP              shift, and go to state 121
    REM              shift, and go to state 122
    BITWISE_AND      shift, and go to state 123
    BITWISE_OR       shift, and go to state 124
    BITWISE_XOR      shift, and go to state 125
    LOGICAL_NULL     shift, and go to state 126
    LOGICAL_AND      shift, and go to state 127
    LOGICAL_OR       shift, and go to state 128
    EQ               shift, and go to state 129
    EQ_STRICT        shift, and go to state 130
    INEQ             shift, and go to state 131
    INEQ_STRICT      shift, and go to state 132
    LT               shift, and go to state 133
    LT_EQ            shift, and go to state 134
    GT               shift, and go to state 135
    GT_EQ            shift, and go to state 136
    LSHIFT           shift, and go to state 137
    RSHIFT           shift, and go to state 138
    RSHIFT_UNSIGNED  shift, and go to state 139
    RPAR             shift, and go to state 319


State 286

   34 for-stmt: FOR LPAR SEMI expr SEMI . expr RPAR LBRACE line RBRACE
   35         | FOR LPAR SEMI expr SEMI . assign-expr RPAR LBRACE line RBRACE
   36         | FOR LPAR SEMI expr SEMI . RPAR LBRACE line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    RPAR         shift, and go to state 320
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    assign-expr      go to state 321
    logic-expr       go to state 37
    expr             go to state 322
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 287

   25 for-stmt: FOR LPAR assign-expr SEMI SEMI . expr RPAR LBRACE line RBRACE
   26         | FOR LPAR assign-expr SEMI SEMI . assign-expr RPAR LBRACE line RBRACE
   27         | FOR LPAR assign-expr SEMI SEMI . RPAR LBRACE line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    RPAR         shift, and go to state 323
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    assign-expr      go to state 324
    logic-expr       go to state 37
    expr             go to state 325
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 288

   22 for-stmt: FOR LPAR assign-expr SEMI expr . SEMI expr RPAR LBRACE line RBRACE
   23         | FOR LPAR assign-expr SEMI expr . SEMI assign-expr RPAR LBRACE line RBRACE
   24         | FOR LPAR assign-expr SEMI expr . SEMI RPAR LBRACE line RBRACE
   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  159 arit-expr: expr . PLUS expr
  160          | expr . SUB expr
  161          | expr . MULT expr
  162          | expr . DIV expr
  163          | expr . EXP expr
  164          | expr . REM expr
  165 bitw-expr: expr . BITWISE_AND expr
  166          | expr . BITWISE_OR expr
  167          | expr . BITWISE_XOR expr
  168 shift-expr: expr . LSHIFT expr
  169           | expr . RSHIFT expr
  170           | expr . RSHIFT_UNSIGNED expr

    SEMI             shift, and go to state 326
    PLUS             shift, and go to state 117
    SUB              shift, and go to state 118
    MULT             shift, and go to state 119
    DIV              shift, and go to state 120
    EXP              shift, and go to state 121
    REM              shift, and go to state 122
    BITWISE_AND      shift, and go to state 123
    BITWISE_OR       shift, and go to state 124
    BITWISE_XOR      shift, and go to state 125
    LOGICAL_NULL     shift, and go to state 126
    LOGICAL_AND      shift, and go to state 127
    LOGICAL_OR       shift, and go to state 128
    EQ               shift, and go to state 129
    EQ_STRICT        shift, and go to state 130
    INEQ             shift, and go to state 131
    INEQ_STRICT      shift, and go to state 132
    LT               shift, and go to state 133
    LT_EQ            shift, and go to state 134
    GT               shift, and go to state 135
    GT_EQ            shift, and go to state 136
    LSHIFT           shift, and go to state 137
    RSHIFT           shift, and go to state 138
    RSHIFT_UNSIGNED  shift, and go to state 139


State 289

   31 for-stmt: FOR LPAR var-declr SEMI SEMI . expr RPAR LBRACE line RBRACE
   32         | FOR LPAR var-declr SEMI SEMI . assign-expr RPAR LBRACE line RBRACE
   33         | FOR LPAR var-declr SEMI SEMI . RPAR LBRACE line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    RPAR         shift, and go to state 327
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    assign-expr      go to state 328
    logic-expr       go to state 37
    expr             go to state 329
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 290

   28 for-stmt: FOR LPAR var-declr SEMI expr . SEMI expr RPAR LBRACE line RBRACE
   29         | FOR LPAR var-declr SEMI expr . SEMI assign-expr RPAR LBRACE line RBRACE
   30         | FOR LPAR var-declr SEMI expr . SEMI RPAR LBRACE line RBRACE
   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  159 arit-expr: expr . PLUS expr
  160          | expr . SUB expr
  161          | expr . MULT expr
  162          | expr . DIV expr
  163          | expr . EXP expr
  164          | expr . REM expr
  165 bitw-expr: expr . BITWISE_AND expr
  166          | expr . BITWISE_OR expr
  167          | expr . BITWISE_XOR expr
  168 shift-expr: expr . LSHIFT expr
  169           | expr . RSHIFT expr
  170           | expr . RSHIFT_UNSIGNED expr

    SEMI             shift, and go to state 330
    PLUS             shift, and go to state 117
    SUB              shift, and go to state 118
    MULT             shift, and go to state 119
    DIV              shift, and go to state 120
    EXP              shift, and go to state 121
    REM              shift, and go to state 122
    BITWISE_AND      shift, and go to state 123
    BITWISE_OR       shift, and go to state 124
    BITWISE_XOR      shift, and go to state 125
    LOGICAL_NULL     shift, and go to state 126
    LOGICAL_AND      shift, and go to state 127
    LOGICAL_OR       shift, and go to state 128
    EQ               shift, and go to state 129
    EQ_STRICT        shift, and go to state 130
    INEQ             shift, and go to state 131
    INEQ_STRICT      shift, and go to state 132
    LT               shift, and go to state 133
    LT_EQ            shift, and go to state 134
    GT               shift, and go to state 135
    GT_EQ            shift, and go to state 136
    LSHIFT           shift, and go to state 137
    RSHIFT           shift, and go to state 138
    RSHIFT_UNSIGNED  shift, and go to state 139


State 291

   92 params: COMMA ID .
   93       | COMMA ID . COLON var-type

    COLON  shift, and go to state 331

    $default  reduce using rule 92 (params)


State 292

   94 params: ID COMMA . ID
   98       | ID COMMA . ID COLON var-type

    ID  shift, and go to state 332


State 293

   95 params: ID COLON . var-type COMMA ID COLON var-type
   96       | ID COLON . var-type COMMA ID
   97       | ID COLON . var-type

    VOID_RW   shift, and go to state 154
    ANY       shift, and go to state 155
    BOOLTYPE  shift, and go to state 156
    NEVER     shift, and go to state 157
    NUMBER    shift, and go to state 158
    STRING    shift, and go to state 159
    UNKNOWN   shift, and go to state 160

    var-type  go to state 333


State 294

   90 func-def: FUNCTION ID LPAR params RPAR . LBRACE line RBRACE
   91         | FUNCTION ID LPAR params RPAR . COLON var-type LBRACE line RBRACE

    COLON   shift, and go to state 334
    LBRACE  shift, and go to state 335


State 295

   63 if-stmt: IF LPAR assign-expr RPAR LBRACE . line RBRACE
   64        | IF LPAR assign-expr RPAR LBRACE . line RBRACE ELSE LBRACE line RBRACE
   65        | IF LPAR assign-expr RPAR LBRACE . line RBRACE ELSE stmt

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 2 (line)

    line             go to state 336
    stmt-list        go to state 30
    stmt             go to state 31
    assign-expr      go to state 32
    for-stmt         go to state 33
    do-while-stmt    go to state 34
    while-stmt       go to state 35
    if-stmt          go to state 36
    logic-expr       go to state 37
    class-def        go to state 38
    func-def         go to state 39
    var-declr        go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 296

   60 if-stmt: IF LPAR expr RPAR LBRACE . line RBRACE
   61        | IF LPAR expr RPAR LBRACE . line RBRACE ELSE LBRACE line RBRACE
   62        | IF LPAR expr RPAR LBRACE . line RBRACE ELSE stmt

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 2 (line)

    line             go to state 337
    stmt-list        go to state 30
    stmt             go to state 31
    assign-expr      go to state 32
    for-stmt         go to state 33
    do-while-stmt    go to state 34
    while-stmt       go to state 35
    if-stmt          go to state 36
    logic-expr       go to state 37
    class-def        go to state 38
    func-def         go to state 39
    var-declr        go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 297

  104 var-declr: LET ID COLON var-type ASSIGN . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 37
    expr             go to state 338
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 298

  105 var-declr: LET ID COLON var-type LBRACKET . RBRACKET
  106          | LET ID COLON var-type LBRACKET . RBRACKET ASSIGN expr

    RBRACKET  shift, and go to state 339


State 299

  188 var-obj: NEW ID LT var-type GT . LPAR args-list RPAR

    LPAR  shift, and go to state 340


State 300

  187 var-obj: NEW ID LPAR args-list RPAR .

    $default  reduce using rule 187 (var-obj)


State 301

  111 var-declr: VAR ID COLON var-type ASSIGN . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 37
    expr             go to state 341
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 302

  112 var-declr: VAR ID COLON var-type LBRACKET . RBRACKET
  113          | VAR ID COLON var-type LBRACKET . RBRACKET ASSIGN expr

    RBRACKET  shift, and go to state 342


State 303

   59 while-stmt: WHILE LPAR assign-expr RPAR LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 2 (line)

    line             go to state 343
    stmt-list        go to state 30
    stmt             go to state 31
    assign-expr      go to state 32
    for-stmt         go to state 33
    do-while-stmt    go to state 34
    while-stmt       go to state 35
    if-stmt          go to state 36
    logic-expr       go to state 37
    class-def        go to state 38
    func-def         go to state 39
    var-declr        go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 304

   58 while-stmt: WHILE LPAR expr RPAR LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 2 (line)

    line             go to state 344
    stmt-list        go to state 30
    stmt             go to state 31
    assign-expr      go to state 32
    for-stmt         go to state 33
    do-while-stmt    go to state 34
    while-stmt       go to state 35
    if-stmt          go to state 36
    logic-expr       go to state 37
    class-def        go to state 38
    func-def         go to state 39
    var-declr        go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 305

  186 var-obj: ID LT var-type GT LPAR args-list . RPAR

    RPAR  shift, and go to state 345


State 306

   83 class-att: ID COLON var-type .

    $default  reduce using rule 83 (class-att)


State 307

   85 class-att: ID LPAR params . RPAR LBRACE line RBRACE
   86          | ID LPAR params . RPAR COLON var-type LBRACE line RBRACE

    RPAR  shift, and go to state 346


State 308

   80 class-att-list: class-att SEMI class-att-list .

    $default  reduce using rule 80 (class-att-list)


State 309

   84 class-att: access-modif ID COLON . var-type

    VOID_RW   shift, and go to state 154
    ANY       shift, and go to state 155
    BOOLTYPE  shift, and go to state 156
    NEVER     shift, and go to state 157
    NUMBER    shift, and go to state 158
    STRING    shift, and go to state 159
    UNKNOWN   shift, and go to state 160

    var-type  go to state 347


State 310

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  115 var-declr: CONST_RW ID COLON var-type ASSIGN expr .
  159 arit-expr: expr . PLUS expr
  160          | expr . SUB expr
  161          | expr . MULT expr
  162          | expr . DIV expr
  163          | expr . EXP expr
  164          | expr . REM expr
  165 bitw-expr: expr . BITWISE_AND expr
  166          | expr . BITWISE_OR expr
  167          | expr . BITWISE_XOR expr
  168 shift-expr: expr . LSHIFT expr
  169           | expr . RSHIFT expr
  170           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 117
    SUB              shift, and go to state 118
    MULT             shift, and go to state 119
    DIV              shift, and go to state 120
    EXP              shift, and go to state 121
    REM              shift, and go to state 122
    BITWISE_AND      shift, and go to state 123
    BITWISE_OR       shift, and go to state 124
    BITWISE_XOR      shift, and go to state 125
    LOGICAL_NULL     shift, and go to state 126
    LOGICAL_AND      shift, and go to state 127
    LOGICAL_OR       shift, and go to state 128
    EQ               shift, and go to state 129
    EQ_STRICT        shift, and go to state 130
    INEQ             shift, and go to state 131
    INEQ_STRICT      shift, and go to state 132
    LT               shift, and go to state 133
    LT_EQ            shift, and go to state 134
    GT               shift, and go to state 135
    GT_EQ            shift, and go to state 136
    LSHIFT           shift, and go to state 137
    RSHIFT           shift, and go to state 138
    RSHIFT_UNSIGNED  shift, and go to state 139

    $default  reduce using rule 115 (var-declr)


State 311

  116 var-declr: CONST_RW ID COLON var-type LBRACKET RBRACKET . ASSIGN expr

    ASSIGN  shift, and go to state 348


State 312

  122 obj-att-list: COMMA obj-att-list .

    $default  reduce using rule 122 (obj-att-list)


State 313

  126 obj-att: ID COLON . var-val

    SUB        shift, and go to state 2
    INT_VAL    shift, and go to state 8
    REAL_VAL   shift, and go to state 9
    STR_VAL    shift, and go to state 10
    FALSE_RW   shift, and go to state 17
    NULL_RW    shift, and go to state 23
    TRUE_RW    shift, and go to state 25
    UNDEFINED  shift, and go to state 28

    var-val  go to state 349


State 314

  121 obj-def: LBRACE obj-att-list RBRACE .

    $default  reduce using rule 121 (obj-def)


State 315

  123 obj-att-list: obj-att COMMA . obj-att-list

    COMMA  shift, and go to state 278
    ID     shift, and go to state 279

    $default  reduce using rule 125 (obj-att-list)

    obj-att-list  go to state 350
    obj-att       go to state 281


State 316

   56 do-while-stmt: DO LBRACE line RBRACE WHILE LPAR . expr RPAR
   57              | DO LBRACE line RBRACE WHILE LPAR . assign-expr RPAR

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    assign-expr      go to state 351
    logic-expr       go to state 37
    expr             go to state 352
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 317

   39 for-stmt: FOR LPAR SEMI SEMI RPAR LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 2 (line)

    line             go to state 353
    stmt-list        go to state 30
    stmt             go to state 31
    assign-expr      go to state 32
    for-stmt         go to state 33
    do-while-stmt    go to state 34
    while-stmt       go to state 35
    if-stmt          go to state 36
    logic-expr       go to state 37
    class-def        go to state 38
    func-def         go to state 39
    var-declr        go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 318

   38 for-stmt: FOR LPAR SEMI SEMI assign-expr RPAR . LBRACE line RBRACE

    LBRACE  shift, and go to state 354


State 319

   37 for-stmt: FOR LPAR SEMI SEMI expr RPAR . LBRACE line RBRACE

    LBRACE  shift, and go to state 355


State 320

   36 for-stmt: FOR LPAR SEMI expr SEMI RPAR . LBRACE line RBRACE

    LBRACE  shift, and go to state 356


State 321

   35 for-stmt: FOR LPAR SEMI expr SEMI assign-expr . RPAR LBRACE line RBRACE

    RPAR  shift, and go to state 357


State 322

   34 for-stmt: FOR LPAR SEMI expr SEMI expr . RPAR LBRACE line RBRACE
   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  159 arit-expr: expr . PLUS expr
  160          | expr . SUB expr
  161          | expr . MULT expr
  162          | expr . DIV expr
  163          | expr . EXP expr
  164          | expr . REM expr
  165 bitw-expr: expr . BITWISE_AND expr
  166          | expr . BITWISE_OR expr
  167          | expr . BITWISE_XOR expr
  168 shift-expr: expr . LSHIFT expr
  169           | expr . RSHIFT expr
  170           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 117
    SUB              shift, and go to state 118
    MULT             shift, and go to state 119
    DIV              shift, and go to state 120
    EXP              shift, and go to state 121
    REM              shift, and go to state 122
    BITWISE_AND      shift, and go to state 123
    BITWISE_OR       shift, and go to state 124
    BITWISE_XOR      shift, and go to state 125
    LOGICAL_NULL     shift, and go to state 126
    LOGICAL_AND      shift, and go to state 127
    LOGICAL_OR       shift, and go to state 128
    EQ               shift, and go to state 129
    EQ_STRICT        shift, and go to state 130
    INEQ             shift, and go to state 131
    INEQ_STRICT      shift, and go to state 132
    LT               shift, and go to state 133
    LT_EQ            shift, and go to state 134
    GT               shift, and go to state 135
    GT_EQ            shift, and go to state 136
    LSHIFT           shift, and go to state 137
    RSHIFT           shift, and go to state 138
    RSHIFT_UNSIGNED  shift, and go to state 139
    RPAR             shift, and go to state 358


State 323

   27 for-stmt: FOR LPAR assign-expr SEMI SEMI RPAR . LBRACE line RBRACE

    LBRACE  shift, and go to state 359


State 324

   26 for-stmt: FOR LPAR assign-expr SEMI SEMI assign-expr . RPAR LBRACE line RBRACE

    RPAR  shift, and go to state 360


State 325

   25 for-stmt: FOR LPAR assign-expr SEMI SEMI expr . RPAR LBRACE line RBRACE
   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  159 arit-expr: expr . PLUS expr
  160          | expr . SUB expr
  161          | expr . MULT expr
  162          | expr . DIV expr
  163          | expr . EXP expr
  164          | expr . REM expr
  165 bitw-expr: expr . BITWISE_AND expr
  166          | expr . BITWISE_OR expr
  167          | expr . BITWISE_XOR expr
  168 shift-expr: expr . LSHIFT expr
  169           | expr . RSHIFT expr
  170           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 117
    SUB              shift, and go to state 118
    MULT             shift, and go to state 119
    DIV              shift, and go to state 120
    EXP              shift, and go to state 121
    REM              shift, and go to state 122
    BITWISE_AND      shift, and go to state 123
    BITWISE_OR       shift, and go to state 124
    BITWISE_XOR      shift, and go to state 125
    LOGICAL_NULL     shift, and go to state 126
    LOGICAL_AND      shift, and go to state 127
    LOGICAL_OR       shift, and go to state 128
    EQ               shift, and go to state 129
    EQ_STRICT        shift, and go to state 130
    INEQ             shift, and go to state 131
    INEQ_STRICT      shift, and go to state 132
    LT               shift, and go to state 133
    LT_EQ            shift, and go to state 134
    GT               shift, and go to state 135
    GT_EQ            shift, and go to state 136
    LSHIFT           shift, and go to state 137
    RSHIFT           shift, and go to state 138
    RSHIFT_UNSIGNED  shift, and go to state 139
    RPAR             shift, and go to state 361


State 326

   22 for-stmt: FOR LPAR assign-expr SEMI expr SEMI . expr RPAR LBRACE line RBRACE
   23         | FOR LPAR assign-expr SEMI expr SEMI . assign-expr RPAR LBRACE line RBRACE
   24         | FOR LPAR assign-expr SEMI expr SEMI . RPAR LBRACE line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    RPAR         shift, and go to state 362
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    assign-expr      go to state 363
    logic-expr       go to state 37
    expr             go to state 364
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 327

   33 for-stmt: FOR LPAR var-declr SEMI SEMI RPAR . LBRACE line RBRACE

    LBRACE  shift, and go to state 365


State 328

   32 for-stmt: FOR LPAR var-declr SEMI SEMI assign-expr . RPAR LBRACE line RBRACE

    RPAR  shift, and go to state 366


State 329

   31 for-stmt: FOR LPAR var-declr SEMI SEMI expr . RPAR LBRACE line RBRACE
   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  159 arit-expr: expr . PLUS expr
  160          | expr . SUB expr
  161          | expr . MULT expr
  162          | expr . DIV expr
  163          | expr . EXP expr
  164          | expr . REM expr
  165 bitw-expr: expr . BITWISE_AND expr
  166          | expr . BITWISE_OR expr
  167          | expr . BITWISE_XOR expr
  168 shift-expr: expr . LSHIFT expr
  169           | expr . RSHIFT expr
  170           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 117
    SUB              shift, and go to state 118
    MULT             shift, and go to state 119
    DIV              shift, and go to state 120
    EXP              shift, and go to state 121
    REM              shift, and go to state 122
    BITWISE_AND      shift, and go to state 123
    BITWISE_OR       shift, and go to state 124
    BITWISE_XOR      shift, and go to state 125
    LOGICAL_NULL     shift, and go to state 126
    LOGICAL_AND      shift, and go to state 127
    LOGICAL_OR       shift, and go to state 128
    EQ               shift, and go to state 129
    EQ_STRICT        shift, and go to state 130
    INEQ             shift, and go to state 131
    INEQ_STRICT      shift, and go to state 132
    LT               shift, and go to state 133
    LT_EQ            shift, and go to state 134
    GT               shift, and go to state 135
    GT_EQ            shift, and go to state 136
    LSHIFT           shift, and go to state 137
    RSHIFT           shift, and go to state 138
    RSHIFT_UNSIGNED  shift, and go to state 139
    RPAR             shift, and go to state 367


State 330

   28 for-stmt: FOR LPAR var-declr SEMI expr SEMI . expr RPAR LBRACE line RBRACE
   29         | FOR LPAR var-declr SEMI expr SEMI . assign-expr RPAR LBRACE line RBRACE
   30         | FOR LPAR var-declr SEMI expr SEMI . RPAR LBRACE line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    RPAR         shift, and go to state 368
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    assign-expr      go to state 369
    logic-expr       go to state 37
    expr             go to state 370
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 331

   93 params: COMMA ID COLON . var-type

    VOID_RW   shift, and go to state 154
    ANY       shift, and go to state 155
    BOOLTYPE  shift, and go to state 156
    NEVER     shift, and go to state 157
    NUMBER    shift, and go to state 158
    STRING    shift, and go to state 159
    UNKNOWN   shift, and go to state 160

    var-type  go to state 371


State 332

   94 params: ID COMMA ID .
   98       | ID COMMA ID . COLON var-type

    COLON  shift, and go to state 372

    $default  reduce using rule 94 (params)


State 333

   95 params: ID COLON var-type . COMMA ID COLON var-type
   96       | ID COLON var-type . COMMA ID
   97       | ID COLON var-type .

    COMMA  shift, and go to state 373

    $default  reduce using rule 97 (params)


State 334

   91 func-def: FUNCTION ID LPAR params RPAR COLON . var-type LBRACE line RBRACE

    VOID_RW   shift, and go to state 154
    ANY       shift, and go to state 155
    BOOLTYPE  shift, and go to state 156
    NEVER     shift, and go to state 157
    NUMBER    shift, and go to state 158
    STRING    shift, and go to state 159
    UNKNOWN   shift, and go to state 160

    var-type  go to state 374


State 335

   90 func-def: FUNCTION ID LPAR params RPAR LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 2 (line)

    line             go to state 375
    stmt-list        go to state 30
    stmt             go to state 31
    assign-expr      go to state 32
    for-stmt         go to state 33
    do-while-stmt    go to state 34
    while-stmt       go to state 35
    if-stmt          go to state 36
    logic-expr       go to state 37
    class-def        go to state 38
    func-def         go to state 39
    var-declr        go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 336

   63 if-stmt: IF LPAR assign-expr RPAR LBRACE line . RBRACE
   64        | IF LPAR assign-expr RPAR LBRACE line . RBRACE ELSE LBRACE line RBRACE
   65        | IF LPAR assign-expr RPAR LBRACE line . RBRACE ELSE stmt

    RBRACE  shift, and go to state 376


State 337

   60 if-stmt: IF LPAR expr RPAR LBRACE line . RBRACE
   61        | IF LPAR expr RPAR LBRACE line . RBRACE ELSE LBRACE line RBRACE
   62        | IF LPAR expr RPAR LBRACE line . RBRACE ELSE stmt

    RBRACE  shift, and go to state 377


State 338

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  104 var-declr: LET ID COLON var-type ASSIGN expr .
  159 arit-expr: expr . PLUS expr
  160          | expr . SUB expr
  161          | expr . MULT expr
  162          | expr . DIV expr
  163          | expr . EXP expr
  164          | expr . REM expr
  165 bitw-expr: expr . BITWISE_AND expr
  166          | expr . BITWISE_OR expr
  167          | expr . BITWISE_XOR expr
  168 shift-expr: expr . LSHIFT expr
  169           | expr . RSHIFT expr
  170           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 117
    SUB              shift, and go to state 118
    MULT             shift, and go to state 119
    DIV              shift, and go to state 120
    EXP              shift, and go to state 121
    REM              shift, and go to state 122
    BITWISE_AND      shift, and go to state 123
    BITWISE_OR       shift, and go to state 124
    BITWISE_XOR      shift, and go to state 125
    LOGICAL_NULL     shift, and go to state 126
    LOGICAL_AND      shift, and go to state 127
    LOGICAL_OR       shift, and go to state 128
    EQ               shift, and go to state 129
    EQ_STRICT        shift, and go to state 130
    INEQ             shift, and go to state 131
    INEQ_STRICT      shift, and go to state 132
    LT               shift, and go to state 133
    LT_EQ            shift, and go to state 134
    GT               shift, and go to state 135
    GT_EQ            shift, and go to state 136
    LSHIFT           shift, and go to state 137
    RSHIFT           shift, and go to state 138
    RSHIFT_UNSIGNED  shift, and go to state 139

    $default  reduce using rule 104 (var-declr)


State 339

  105 var-declr: LET ID COLON var-type LBRACKET RBRACKET .
  106          | LET ID COLON var-type LBRACKET RBRACKET . ASSIGN expr

    ASSIGN  shift, and go to state 378

    $default  reduce using rule 105 (var-declr)


State 340

  188 var-obj: NEW ID LT var-type GT LPAR . args-list RPAR

    COMMA        shift, and go to state 163
    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 184 (args-list)

    assign-expr      go to state 164
    logic-expr       go to state 37
    expr             go to state 165
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    args-list        go to state 379
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 341

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  111 var-declr: VAR ID COLON var-type ASSIGN expr .
  159 arit-expr: expr . PLUS expr
  160          | expr . SUB expr
  161          | expr . MULT expr
  162          | expr . DIV expr
  163          | expr . EXP expr
  164          | expr . REM expr
  165 bitw-expr: expr . BITWISE_AND expr
  166          | expr . BITWISE_OR expr
  167          | expr . BITWISE_XOR expr
  168 shift-expr: expr . LSHIFT expr
  169           | expr . RSHIFT expr
  170           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 117
    SUB              shift, and go to state 118
    MULT             shift, and go to state 119
    DIV              shift, and go to state 120
    EXP              shift, and go to state 121
    REM              shift, and go to state 122
    BITWISE_AND      shift, and go to state 123
    BITWISE_OR       shift, and go to state 124
    BITWISE_XOR      shift, and go to state 125
    LOGICAL_NULL     shift, and go to state 126
    LOGICAL_AND      shift, and go to state 127
    LOGICAL_OR       shift, and go to state 128
    EQ               shift, and go to state 129
    EQ_STRICT        shift, and go to state 130
    INEQ             shift, and go to state 131
    INEQ_STRICT      shift, and go to state 132
    LT               shift, and go to state 133
    LT_EQ            shift, and go to state 134
    GT               shift, and go to state 135
    GT_EQ            shift, and go to state 136
    LSHIFT           shift, and go to state 137
    RSHIFT           shift, and go to state 138
    RSHIFT_UNSIGNED  shift, and go to state 139

    $default  reduce using rule 111 (var-declr)


State 342

  112 var-declr: VAR ID COLON var-type LBRACKET RBRACKET .
  113          | VAR ID COLON var-type LBRACKET RBRACKET . ASSIGN expr

    ASSIGN  shift, and go to state 380

    $default  reduce using rule 112 (var-declr)


State 343

   59 while-stmt: WHILE LPAR assign-expr RPAR LBRACE line . RBRACE

    RBRACE  shift, and go to state 381


State 344

   58 while-stmt: WHILE LPAR expr RPAR LBRACE line . RBRACE

    RBRACE  shift, and go to state 382


State 345

  186 var-obj: ID LT var-type GT LPAR args-list RPAR .

    $default  reduce using rule 186 (var-obj)


State 346

   85 class-att: ID LPAR params RPAR . LBRACE line RBRACE
   86          | ID LPAR params RPAR . COLON var-type LBRACE line RBRACE

    COLON   shift, and go to state 383
    LBRACE  shift, and go to state 384


State 347

   84 class-att: access-modif ID COLON var-type .

    $default  reduce using rule 84 (class-att)


State 348

  116 var-declr: CONST_RW ID COLON var-type LBRACKET RBRACKET ASSIGN . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 37
    expr             go to state 385
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 349

  126 obj-att: ID COLON var-val .

    $default  reduce using rule 126 (obj-att)


State 350

  123 obj-att-list: obj-att COMMA obj-att-list .

    $default  reduce using rule 123 (obj-att-list)


State 351

   57 do-while-stmt: DO LBRACE line RBRACE WHILE LPAR assign-expr . RPAR

    RPAR  shift, and go to state 386


State 352

   56 do-while-stmt: DO LBRACE line RBRACE WHILE LPAR expr . RPAR
   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  159 arit-expr: expr . PLUS expr
  160          | expr . SUB expr
  161          | expr . MULT expr
  162          | expr . DIV expr
  163          | expr . EXP expr
  164          | expr . REM expr
  165 bitw-expr: expr . BITWISE_AND expr
  166          | expr . BITWISE_OR expr
  167          | expr . BITWISE_XOR expr
  168 shift-expr: expr . LSHIFT expr
  169           | expr . RSHIFT expr
  170           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 117
    SUB              shift, and go to state 118
    MULT             shift, and go to state 119
    DIV              shift, and go to state 120
    EXP              shift, and go to state 121
    REM              shift, and go to state 122
    BITWISE_AND      shift, and go to state 123
    BITWISE_OR       shift, and go to state 124
    BITWISE_XOR      shift, and go to state 125
    LOGICAL_NULL     shift, and go to state 126
    LOGICAL_AND      shift, and go to state 127
    LOGICAL_OR       shift, and go to state 128
    EQ               shift, and go to state 129
    EQ_STRICT        shift, and go to state 130
    INEQ             shift, and go to state 131
    INEQ_STRICT      shift, and go to state 132
    LT               shift, and go to state 133
    LT_EQ            shift, and go to state 134
    GT               shift, and go to state 135
    GT_EQ            shift, and go to state 136
    LSHIFT           shift, and go to state 137
    RSHIFT           shift, and go to state 138
    RSHIFT_UNSIGNED  shift, and go to state 139
    RPAR             shift, and go to state 387


State 353

   39 for-stmt: FOR LPAR SEMI SEMI RPAR LBRACE line . RBRACE

    RBRACE  shift, and go to state 388


State 354

   38 for-stmt: FOR LPAR SEMI SEMI assign-expr RPAR LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 2 (line)

    line             go to state 389
    stmt-list        go to state 30
    stmt             go to state 31
    assign-expr      go to state 32
    for-stmt         go to state 33
    do-while-stmt    go to state 34
    while-stmt       go to state 35
    if-stmt          go to state 36
    logic-expr       go to state 37
    class-def        go to state 38
    func-def         go to state 39
    var-declr        go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 355

   37 for-stmt: FOR LPAR SEMI SEMI expr RPAR LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 2 (line)

    line             go to state 390
    stmt-list        go to state 30
    stmt             go to state 31
    assign-expr      go to state 32
    for-stmt         go to state 33
    do-while-stmt    go to state 34
    while-stmt       go to state 35
    if-stmt          go to state 36
    logic-expr       go to state 37
    class-def        go to state 38
    func-def         go to state 39
    var-declr        go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 356

   36 for-stmt: FOR LPAR SEMI expr SEMI RPAR LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 2 (line)

    line             go to state 391
    stmt-list        go to state 30
    stmt             go to state 31
    assign-expr      go to state 32
    for-stmt         go to state 33
    do-while-stmt    go to state 34
    while-stmt       go to state 35
    if-stmt          go to state 36
    logic-expr       go to state 37
    class-def        go to state 38
    func-def         go to state 39
    var-declr        go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 357

   35 for-stmt: FOR LPAR SEMI expr SEMI assign-expr RPAR . LBRACE line RBRACE

    LBRACE  shift, and go to state 392


State 358

   34 for-stmt: FOR LPAR SEMI expr SEMI expr RPAR . LBRACE line RBRACE

    LBRACE  shift, and go to state 393


State 359

   27 for-stmt: FOR LPAR assign-expr SEMI SEMI RPAR LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 2 (line)

    line             go to state 394
    stmt-list        go to state 30
    stmt             go to state 31
    assign-expr      go to state 32
    for-stmt         go to state 33
    do-while-stmt    go to state 34
    while-stmt       go to state 35
    if-stmt          go to state 36
    logic-expr       go to state 37
    class-def        go to state 38
    func-def         go to state 39
    var-declr        go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 360

   26 for-stmt: FOR LPAR assign-expr SEMI SEMI assign-expr RPAR . LBRACE line RBRACE

    LBRACE  shift, and go to state 395


State 361

   25 for-stmt: FOR LPAR assign-expr SEMI SEMI expr RPAR . LBRACE line RBRACE

    LBRACE  shift, and go to state 396


State 362

   24 for-stmt: FOR LPAR assign-expr SEMI expr SEMI RPAR . LBRACE line RBRACE

    LBRACE  shift, and go to state 397


State 363

   23 for-stmt: FOR LPAR assign-expr SEMI expr SEMI assign-expr . RPAR LBRACE line RBRACE

    RPAR  shift, and go to state 398


State 364

   22 for-stmt: FOR LPAR assign-expr SEMI expr SEMI expr . RPAR LBRACE line RBRACE
   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  159 arit-expr: expr . PLUS expr
  160          | expr . SUB expr
  161          | expr . MULT expr
  162          | expr . DIV expr
  163          | expr . EXP expr
  164          | expr . REM expr
  165 bitw-expr: expr . BITWISE_AND expr
  166          | expr . BITWISE_OR expr
  167          | expr . BITWISE_XOR expr
  168 shift-expr: expr . LSHIFT expr
  169           | expr . RSHIFT expr
  170           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 117
    SUB              shift, and go to state 118
    MULT             shift, and go to state 119
    DIV              shift, and go to state 120
    EXP              shift, and go to state 121
    REM              shift, and go to state 122
    BITWISE_AND      shift, and go to state 123
    BITWISE_OR       shift, and go to state 124
    BITWISE_XOR      shift, and go to state 125
    LOGICAL_NULL     shift, and go to state 126
    LOGICAL_AND      shift, and go to state 127
    LOGICAL_OR       shift, and go to state 128
    EQ               shift, and go to state 129
    EQ_STRICT        shift, and go to state 130
    INEQ             shift, and go to state 131
    INEQ_STRICT      shift, and go to state 132
    LT               shift, and go to state 133
    LT_EQ            shift, and go to state 134
    GT               shift, and go to state 135
    GT_EQ            shift, and go to state 136
    LSHIFT           shift, and go to state 137
    RSHIFT           shift, and go to state 138
    RSHIFT_UNSIGNED  shift, and go to state 139
    RPAR             shift, and go to state 399


State 365

   33 for-stmt: FOR LPAR var-declr SEMI SEMI RPAR LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 2 (line)

    line             go to state 400
    stmt-list        go to state 30
    stmt             go to state 31
    assign-expr      go to state 32
    for-stmt         go to state 33
    do-while-stmt    go to state 34
    while-stmt       go to state 35
    if-stmt          go to state 36
    logic-expr       go to state 37
    class-def        go to state 38
    func-def         go to state 39
    var-declr        go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 366

   32 for-stmt: FOR LPAR var-declr SEMI SEMI assign-expr RPAR . LBRACE line RBRACE

    LBRACE  shift, and go to state 401


State 367

   31 for-stmt: FOR LPAR var-declr SEMI SEMI expr RPAR . LBRACE line RBRACE

    LBRACE  shift, and go to state 402


State 368

   30 for-stmt: FOR LPAR var-declr SEMI expr SEMI RPAR . LBRACE line RBRACE

    LBRACE  shift, and go to state 403


State 369

   29 for-stmt: FOR LPAR var-declr SEMI expr SEMI assign-expr . RPAR LBRACE line RBRACE

    RPAR  shift, and go to state 404


State 370

   28 for-stmt: FOR LPAR var-declr SEMI expr SEMI expr . RPAR LBRACE line RBRACE
   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  159 arit-expr: expr . PLUS expr
  160          | expr . SUB expr
  161          | expr . MULT expr
  162          | expr . DIV expr
  163          | expr . EXP expr
  164          | expr . REM expr
  165 bitw-expr: expr . BITWISE_AND expr
  166          | expr . BITWISE_OR expr
  167          | expr . BITWISE_XOR expr
  168 shift-expr: expr . LSHIFT expr
  169           | expr . RSHIFT expr
  170           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 117
    SUB              shift, and go to state 118
    MULT             shift, and go to state 119
    DIV              shift, and go to state 120
    EXP              shift, and go to state 121
    REM              shift, and go to state 122
    BITWISE_AND      shift, and go to state 123
    BITWISE_OR       shift, and go to state 124
    BITWISE_XOR      shift, and go to state 125
    LOGICAL_NULL     shift, and go to state 126
    LOGICAL_AND      shift, and go to state 127
    LOGICAL_OR       shift, and go to state 128
    EQ               shift, and go to state 129
    EQ_STRICT        shift, and go to state 130
    INEQ             shift, and go to state 131
    INEQ_STRICT      shift, and go to state 132
    LT               shift, and go to state 133
    LT_EQ            shift, and go to state 134
    GT               shift, and go to state 135
    GT_EQ            shift, and go to state 136
    LSHIFT           shift, and go to state 137
    RSHIFT           shift, and go to state 138
    RSHIFT_UNSIGNED  shift, and go to state 139
    RPAR             shift, and go to state 405


State 371

   93 params: COMMA ID COLON var-type .

    $default  reduce using rule 93 (params)


State 372

   98 params: ID COMMA ID COLON . var-type

    VOID_RW   shift, and go to state 154
    ANY       shift, and go to state 155
    BOOLTYPE  shift, and go to state 156
    NEVER     shift, and go to state 157
    NUMBER    shift, and go to state 158
    STRING    shift, and go to state 159
    UNKNOWN   shift, and go to state 160

    var-type  go to state 406


State 373

   95 params: ID COLON var-type COMMA . ID COLON var-type
   96       | ID COLON var-type COMMA . ID

    ID  shift, and go to state 407


State 374

   91 func-def: FUNCTION ID LPAR params RPAR COLON var-type . LBRACE line RBRACE

    LBRACE  shift, and go to state 408


State 375

   90 func-def: FUNCTION ID LPAR params RPAR LBRACE line . RBRACE

    RBRACE  shift, and go to state 409


State 376

   63 if-stmt: IF LPAR assign-expr RPAR LBRACE line RBRACE .
   64        | IF LPAR assign-expr RPAR LBRACE line RBRACE . ELSE LBRACE line RBRACE
   65        | IF LPAR assign-expr RPAR LBRACE line RBRACE . ELSE stmt

    ELSE  shift, and go to state 410

    $default  reduce using rule 63 (if-stmt)


State 377

   60 if-stmt: IF LPAR expr RPAR LBRACE line RBRACE .
   61        | IF LPAR expr RPAR LBRACE line RBRACE . ELSE LBRACE line RBRACE
   62        | IF LPAR expr RPAR LBRACE line RBRACE . ELSE stmt

    ELSE  shift, and go to state 411

    $default  reduce using rule 60 (if-stmt)


State 378

  106 var-declr: LET ID COLON var-type LBRACKET RBRACKET ASSIGN . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 37
    expr             go to state 412
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 379

  188 var-obj: NEW ID LT var-type GT LPAR args-list . RPAR

    RPAR  shift, and go to state 413


State 380

  113 var-declr: VAR ID COLON var-type LBRACKET RBRACKET ASSIGN . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 37
    expr             go to state 414
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 381

   59 while-stmt: WHILE LPAR assign-expr RPAR LBRACE line RBRACE .

    $default  reduce using rule 59 (while-stmt)


State 382

   58 while-stmt: WHILE LPAR expr RPAR LBRACE line RBRACE .

    $default  reduce using rule 58 (while-stmt)


State 383

   86 class-att: ID LPAR params RPAR COLON . var-type LBRACE line RBRACE

    VOID_RW   shift, and go to state 154
    ANY       shift, and go to state 155
    BOOLTYPE  shift, and go to state 156
    NEVER     shift, and go to state 157
    NUMBER    shift, and go to state 158
    STRING    shift, and go to state 159
    UNKNOWN   shift, and go to state 160

    var-type  go to state 415


State 384

   85 class-att: ID LPAR params RPAR LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 2 (line)

    line             go to state 416
    stmt-list        go to state 30
    stmt             go to state 31
    assign-expr      go to state 32
    for-stmt         go to state 33
    do-while-stmt    go to state 34
    while-stmt       go to state 35
    if-stmt          go to state 36
    logic-expr       go to state 37
    class-def        go to state 38
    func-def         go to state 39
    var-declr        go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 385

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  116 var-declr: CONST_RW ID COLON var-type LBRACKET RBRACKET ASSIGN expr .
  159 arit-expr: expr . PLUS expr
  160          | expr . SUB expr
  161          | expr . MULT expr
  162          | expr . DIV expr
  163          | expr . EXP expr
  164          | expr . REM expr
  165 bitw-expr: expr . BITWISE_AND expr
  166          | expr . BITWISE_OR expr
  167          | expr . BITWISE_XOR expr
  168 shift-expr: expr . LSHIFT expr
  169           | expr . RSHIFT expr
  170           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 117
    SUB              shift, and go to state 118
    MULT             shift, and go to state 119
    DIV              shift, and go to state 120
    EXP              shift, and go to state 121
    REM              shift, and go to state 122
    BITWISE_AND      shift, and go to state 123
    BITWISE_OR       shift, and go to state 124
    BITWISE_XOR      shift, and go to state 125
    LOGICAL_NULL     shift, and go to state 126
    LOGICAL_AND      shift, and go to state 127
    LOGICAL_OR       shift, and go to state 128
    EQ               shift, and go to state 129
    EQ_STRICT        shift, and go to state 130
    INEQ             shift, and go to state 131
    INEQ_STRICT      shift, and go to state 132
    LT               shift, and go to state 133
    LT_EQ            shift, and go to state 134
    GT               shift, and go to state 135
    GT_EQ            shift, and go to state 136
    LSHIFT           shift, and go to state 137
    RSHIFT           shift, and go to state 138
    RSHIFT_UNSIGNED  shift, and go to state 139

    $default  reduce using rule 116 (var-declr)


State 386

   57 do-while-stmt: DO LBRACE line RBRACE WHILE LPAR assign-expr RPAR .

    $default  reduce using rule 57 (do-while-stmt)


State 387

   56 do-while-stmt: DO LBRACE line RBRACE WHILE LPAR expr RPAR .

    $default  reduce using rule 56 (do-while-stmt)


State 388

   39 for-stmt: FOR LPAR SEMI SEMI RPAR LBRACE line RBRACE .

    $default  reduce using rule 39 (for-stmt)


State 389

   38 for-stmt: FOR LPAR SEMI SEMI assign-expr RPAR LBRACE line . RBRACE

    RBRACE  shift, and go to state 417


State 390

   37 for-stmt: FOR LPAR SEMI SEMI expr RPAR LBRACE line . RBRACE

    RBRACE  shift, and go to state 418


State 391

   36 for-stmt: FOR LPAR SEMI expr SEMI RPAR LBRACE line . RBRACE

    RBRACE  shift, and go to state 419


State 392

   35 for-stmt: FOR LPAR SEMI expr SEMI assign-expr RPAR LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 2 (line)

    line             go to state 420
    stmt-list        go to state 30
    stmt             go to state 31
    assign-expr      go to state 32
    for-stmt         go to state 33
    do-while-stmt    go to state 34
    while-stmt       go to state 35
    if-stmt          go to state 36
    logic-expr       go to state 37
    class-def        go to state 38
    func-def         go to state 39
    var-declr        go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 393

   34 for-stmt: FOR LPAR SEMI expr SEMI expr RPAR LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 2 (line)

    line             go to state 421
    stmt-list        go to state 30
    stmt             go to state 31
    assign-expr      go to state 32
    for-stmt         go to state 33
    do-while-stmt    go to state 34
    while-stmt       go to state 35
    if-stmt          go to state 36
    logic-expr       go to state 37
    class-def        go to state 38
    func-def         go to state 39
    var-declr        go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 394

   27 for-stmt: FOR LPAR assign-expr SEMI SEMI RPAR LBRACE line . RBRACE

    RBRACE  shift, and go to state 422


State 395

   26 for-stmt: FOR LPAR assign-expr SEMI SEMI assign-expr RPAR LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 2 (line)

    line             go to state 423
    stmt-list        go to state 30
    stmt             go to state 31
    assign-expr      go to state 32
    for-stmt         go to state 33
    do-while-stmt    go to state 34
    while-stmt       go to state 35
    if-stmt          go to state 36
    logic-expr       go to state 37
    class-def        go to state 38
    func-def         go to state 39
    var-declr        go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 396

   25 for-stmt: FOR LPAR assign-expr SEMI SEMI expr RPAR LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 2 (line)

    line             go to state 424
    stmt-list        go to state 30
    stmt             go to state 31
    assign-expr      go to state 32
    for-stmt         go to state 33
    do-while-stmt    go to state 34
    while-stmt       go to state 35
    if-stmt          go to state 36
    logic-expr       go to state 37
    class-def        go to state 38
    func-def         go to state 39
    var-declr        go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 397

   24 for-stmt: FOR LPAR assign-expr SEMI expr SEMI RPAR LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 2 (line)

    line             go to state 425
    stmt-list        go to state 30
    stmt             go to state 31
    assign-expr      go to state 32
    for-stmt         go to state 33
    do-while-stmt    go to state 34
    while-stmt       go to state 35
    if-stmt          go to state 36
    logic-expr       go to state 37
    class-def        go to state 38
    func-def         go to state 39
    var-declr        go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 398

   23 for-stmt: FOR LPAR assign-expr SEMI expr SEMI assign-expr RPAR . LBRACE line RBRACE

    LBRACE  shift, and go to state 426


State 399

   22 for-stmt: FOR LPAR assign-expr SEMI expr SEMI expr RPAR . LBRACE line RBRACE

    LBRACE  shift, and go to state 427


State 400

   33 for-stmt: FOR LPAR var-declr SEMI SEMI RPAR LBRACE line . RBRACE

    RBRACE  shift, and go to state 428


State 401

   32 for-stmt: FOR LPAR var-declr SEMI SEMI assign-expr RPAR LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 2 (line)

    line             go to state 429
    stmt-list        go to state 30
    stmt             go to state 31
    assign-expr      go to state 32
    for-stmt         go to state 33
    do-while-stmt    go to state 34
    while-stmt       go to state 35
    if-stmt          go to state 36
    logic-expr       go to state 37
    class-def        go to state 38
    func-def         go to state 39
    var-declr        go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 402

   31 for-stmt: FOR LPAR var-declr SEMI SEMI expr RPAR LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 2 (line)

    line             go to state 430
    stmt-list        go to state 30
    stmt             go to state 31
    assign-expr      go to state 32
    for-stmt         go to state 33
    do-while-stmt    go to state 34
    while-stmt       go to state 35
    if-stmt          go to state 36
    logic-expr       go to state 37
    class-def        go to state 38
    func-def         go to state 39
    var-declr        go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 403

   30 for-stmt: FOR LPAR var-declr SEMI expr SEMI RPAR LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 2 (line)

    line             go to state 431
    stmt-list        go to state 30
    stmt             go to state 31
    assign-expr      go to state 32
    for-stmt         go to state 33
    do-while-stmt    go to state 34
    while-stmt       go to state 35
    if-stmt          go to state 36
    logic-expr       go to state 37
    class-def        go to state 38
    func-def         go to state 39
    var-declr        go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 404

   29 for-stmt: FOR LPAR var-declr SEMI expr SEMI assign-expr RPAR . LBRACE line RBRACE

    LBRACE  shift, and go to state 432


State 405

   28 for-stmt: FOR LPAR var-declr SEMI expr SEMI expr RPAR . LBRACE line RBRACE

    LBRACE  shift, and go to state 433


State 406

   98 params: ID COMMA ID COLON var-type .

    $default  reduce using rule 98 (params)


State 407

   95 params: ID COLON var-type COMMA ID . COLON var-type
   96       | ID COLON var-type COMMA ID .

    COLON  shift, and go to state 434

    $default  reduce using rule 96 (params)


State 408

   91 func-def: FUNCTION ID LPAR params RPAR COLON var-type LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 2 (line)

    line             go to state 435
    stmt-list        go to state 30
    stmt             go to state 31
    assign-expr      go to state 32
    for-stmt         go to state 33
    do-while-stmt    go to state 34
    while-stmt       go to state 35
    if-stmt          go to state 36
    logic-expr       go to state 37
    class-def        go to state 38
    func-def         go to state 39
    var-declr        go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 409

   90 func-def: FUNCTION ID LPAR params RPAR LBRACE line RBRACE .

    $default  reduce using rule 90 (func-def)


State 410

   64 if-stmt: IF LPAR assign-expr RPAR LBRACE line RBRACE ELSE . LBRACE line RBRACE
   65        | IF LPAR assign-expr RPAR LBRACE line RBRACE ELSE . stmt

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACE       shift, and go to state 436
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    stmt             go to state 437
    assign-expr      go to state 32
    for-stmt         go to state 33
    do-while-stmt    go to state 34
    while-stmt       go to state 35
    if-stmt          go to state 36
    logic-expr       go to state 37
    class-def        go to state 38
    func-def         go to state 39
    var-declr        go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 411

   61 if-stmt: IF LPAR expr RPAR LBRACE line RBRACE ELSE . LBRACE line RBRACE
   62        | IF LPAR expr RPAR LBRACE line RBRACE ELSE . stmt

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACE       shift, and go to state 438
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    stmt             go to state 439
    assign-expr      go to state 32
    for-stmt         go to state 33
    do-while-stmt    go to state 34
    while-stmt       go to state 35
    if-stmt          go to state 36
    logic-expr       go to state 37
    class-def        go to state 38
    func-def         go to state 39
    var-declr        go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 412

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  106 var-declr: LET ID COLON var-type LBRACKET RBRACKET ASSIGN expr .
  159 arit-expr: expr . PLUS expr
  160          | expr . SUB expr
  161          | expr . MULT expr
  162          | expr . DIV expr
  163          | expr . EXP expr
  164          | expr . REM expr
  165 bitw-expr: expr . BITWISE_AND expr
  166          | expr . BITWISE_OR expr
  167          | expr . BITWISE_XOR expr
  168 shift-expr: expr . LSHIFT expr
  169           | expr . RSHIFT expr
  170           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 117
    SUB              shift, and go to state 118
    MULT             shift, and go to state 119
    DIV              shift, and go to state 120
    EXP              shift, and go to state 121
    REM              shift, and go to state 122
    BITWISE_AND      shift, and go to state 123
    BITWISE_OR       shift, and go to state 124
    BITWISE_XOR      shift, and go to state 125
    LOGICAL_NULL     shift, and go to state 126
    LOGICAL_AND      shift, and go to state 127
    LOGICAL_OR       shift, and go to state 128
    EQ               shift, and go to state 129
    EQ_STRICT        shift, and go to state 130
    INEQ             shift, and go to state 131
    INEQ_STRICT      shift, and go to state 132
    LT               shift, and go to state 133
    LT_EQ            shift, and go to state 134
    GT               shift, and go to state 135
    GT_EQ            shift, and go to state 136
    LSHIFT           shift, and go to state 137
    RSHIFT           shift, and go to state 138
    RSHIFT_UNSIGNED  shift, and go to state 139

    $default  reduce using rule 106 (var-declr)


State 413

  188 var-obj: NEW ID LT var-type GT LPAR args-list RPAR .

    $default  reduce using rule 188 (var-obj)


State 414

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  113 var-declr: VAR ID COLON var-type LBRACKET RBRACKET ASSIGN expr .
  159 arit-expr: expr . PLUS expr
  160          | expr . SUB expr
  161          | expr . MULT expr
  162          | expr . DIV expr
  163          | expr . EXP expr
  164          | expr . REM expr
  165 bitw-expr: expr . BITWISE_AND expr
  166          | expr . BITWISE_OR expr
  167          | expr . BITWISE_XOR expr
  168 shift-expr: expr . LSHIFT expr
  169           | expr . RSHIFT expr
  170           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 117
    SUB              shift, and go to state 118
    MULT             shift, and go to state 119
    DIV              shift, and go to state 120
    EXP              shift, and go to state 121
    REM              shift, and go to state 122
    BITWISE_AND      shift, and go to state 123
    BITWISE_OR       shift, and go to state 124
    BITWISE_XOR      shift, and go to state 125
    LOGICAL_NULL     shift, and go to state 126
    LOGICAL_AND      shift, and go to state 127
    LOGICAL_OR       shift, and go to state 128
    EQ               shift, and go to state 129
    EQ_STRICT        shift, and go to state 130
    INEQ             shift, and go to state 131
    INEQ_STRICT      shift, and go to state 132
    LT               shift, and go to state 133
    LT_EQ            shift, and go to state 134
    GT               shift, and go to state 135
    GT_EQ            shift, and go to state 136
    LSHIFT           shift, and go to state 137
    RSHIFT           shift, and go to state 138
    RSHIFT_UNSIGNED  shift, and go to state 139

    $default  reduce using rule 113 (var-declr)


State 415

   86 class-att: ID LPAR params RPAR COLON var-type . LBRACE line RBRACE

    LBRACE  shift, and go to state 440


State 416

   85 class-att: ID LPAR params RPAR LBRACE line . RBRACE

    RBRACE  shift, and go to state 441


State 417

   38 for-stmt: FOR LPAR SEMI SEMI assign-expr RPAR LBRACE line RBRACE .

    $default  reduce using rule 38 (for-stmt)


State 418

   37 for-stmt: FOR LPAR SEMI SEMI expr RPAR LBRACE line RBRACE .

    $default  reduce using rule 37 (for-stmt)


State 419

   36 for-stmt: FOR LPAR SEMI expr SEMI RPAR LBRACE line RBRACE .

    $default  reduce using rule 36 (for-stmt)


State 420

   35 for-stmt: FOR LPAR SEMI expr SEMI assign-expr RPAR LBRACE line . RBRACE

    RBRACE  shift, and go to state 442


State 421

   34 for-stmt: FOR LPAR SEMI expr SEMI expr RPAR LBRACE line . RBRACE

    RBRACE  shift, and go to state 443


State 422

   27 for-stmt: FOR LPAR assign-expr SEMI SEMI RPAR LBRACE line RBRACE .

    $default  reduce using rule 27 (for-stmt)


State 423

   26 for-stmt: FOR LPAR assign-expr SEMI SEMI assign-expr RPAR LBRACE line . RBRACE

    RBRACE  shift, and go to state 444


State 424

   25 for-stmt: FOR LPAR assign-expr SEMI SEMI expr RPAR LBRACE line . RBRACE

    RBRACE  shift, and go to state 445


State 425

   24 for-stmt: FOR LPAR assign-expr SEMI expr SEMI RPAR LBRACE line . RBRACE

    RBRACE  shift, and go to state 446


State 426

   23 for-stmt: FOR LPAR assign-expr SEMI expr SEMI assign-expr RPAR LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 2 (line)

    line             go to state 447
    stmt-list        go to state 30
    stmt             go to state 31
    assign-expr      go to state 32
    for-stmt         go to state 33
    do-while-stmt    go to state 34
    while-stmt       go to state 35
    if-stmt          go to state 36
    logic-expr       go to state 37
    class-def        go to state 38
    func-def         go to state 39
    var-declr        go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 427

   22 for-stmt: FOR LPAR assign-expr SEMI expr SEMI expr RPAR LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 2 (line)

    line             go to state 448
    stmt-list        go to state 30
    stmt             go to state 31
    assign-expr      go to state 32
    for-stmt         go to state 33
    do-while-stmt    go to state 34
    while-stmt       go to state 35
    if-stmt          go to state 36
    logic-expr       go to state 37
    class-def        go to state 38
    func-def         go to state 39
    var-declr        go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 428

   33 for-stmt: FOR LPAR var-declr SEMI SEMI RPAR LBRACE line RBRACE .

    $default  reduce using rule 33 (for-stmt)


State 429

   32 for-stmt: FOR LPAR var-declr SEMI SEMI assign-expr RPAR LBRACE line . RBRACE

    RBRACE  shift, and go to state 449


State 430

   31 for-stmt: FOR LPAR var-declr SEMI SEMI expr RPAR LBRACE line . RBRACE

    RBRACE  shift, and go to state 450


State 431

   30 for-stmt: FOR LPAR var-declr SEMI expr SEMI RPAR LBRACE line . RBRACE

    RBRACE  shift, and go to state 451


State 432

   29 for-stmt: FOR LPAR var-declr SEMI expr SEMI assign-expr RPAR LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 2 (line)

    line             go to state 452
    stmt-list        go to state 30
    stmt             go to state 31
    assign-expr      go to state 32
    for-stmt         go to state 33
    do-while-stmt    go to state 34
    while-stmt       go to state 35
    if-stmt          go to state 36
    logic-expr       go to state 37
    class-def        go to state 38
    func-def         go to state 39
    var-declr        go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 433

   28 for-stmt: FOR LPAR var-declr SEMI expr SEMI expr RPAR LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 2 (line)

    line             go to state 453
    stmt-list        go to state 30
    stmt             go to state 31
    assign-expr      go to state 32
    for-stmt         go to state 33
    do-while-stmt    go to state 34
    while-stmt       go to state 35
    if-stmt          go to state 36
    logic-expr       go to state 37
    class-def        go to state 38
    func-def         go to state 39
    var-declr        go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 434

   95 params: ID COLON var-type COMMA ID COLON . var-type

    VOID_RW   shift, and go to state 154
    ANY       shift, and go to state 155
    BOOLTYPE  shift, and go to state 156
    NEVER     shift, and go to state 157
    NUMBER    shift, and go to state 158
    STRING    shift, and go to state 159
    UNKNOWN   shift, and go to state 160

    var-type  go to state 454


State 435

   91 func-def: FUNCTION ID LPAR params RPAR COLON var-type LBRACE line . RBRACE

    RBRACE  shift, and go to state 455


State 436

   64 if-stmt: IF LPAR assign-expr RPAR LBRACE line RBRACE ELSE LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 2 (line)

    line             go to state 456
    stmt-list        go to state 30
    stmt             go to state 31
    assign-expr      go to state 32
    for-stmt         go to state 33
    do-while-stmt    go to state 34
    while-stmt       go to state 35
    if-stmt          go to state 36
    logic-expr       go to state 37
    class-def        go to state 38
    func-def         go to state 39
    var-declr        go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 437

   65 if-stmt: IF LPAR assign-expr RPAR LBRACE line RBRACE ELSE stmt .

    $default  reduce using rule 65 (if-stmt)


State 438

   61 if-stmt: IF LPAR expr RPAR LBRACE line RBRACE ELSE LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 2 (line)

    line             go to state 457
    stmt-list        go to state 30
    stmt             go to state 31
    assign-expr      go to state 32
    for-stmt         go to state 33
    do-while-stmt    go to state 34
    while-stmt       go to state 35
    if-stmt          go to state 36
    logic-expr       go to state 37
    class-def        go to state 38
    func-def         go to state 39
    var-declr        go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 439

   62 if-stmt: IF LPAR expr RPAR LBRACE line RBRACE ELSE stmt .

    $default  reduce using rule 62 (if-stmt)


State 440

   86 class-att: ID LPAR params RPAR COLON var-type LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 2 (line)

    line             go to state 458
    stmt-list        go to state 30
    stmt             go to state 31
    assign-expr      go to state 32
    for-stmt         go to state 33
    do-while-stmt    go to state 34
    while-stmt       go to state 35
    if-stmt          go to state 36
    logic-expr       go to state 37
    class-def        go to state 38
    func-def         go to state 39
    var-declr        go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 441

   85 class-att: ID LPAR params RPAR LBRACE line RBRACE .

    $default  reduce using rule 85 (class-att)


State 442

   35 for-stmt: FOR LPAR SEMI expr SEMI assign-expr RPAR LBRACE line RBRACE .

    $default  reduce using rule 35 (for-stmt)


State 443

   34 for-stmt: FOR LPAR SEMI expr SEMI expr RPAR LBRACE line RBRACE .

    $default  reduce using rule 34 (for-stmt)


State 444

   26 for-stmt: FOR LPAR assign-expr SEMI SEMI assign-expr RPAR LBRACE line RBRACE .

    $default  reduce using rule 26 (for-stmt)


State 445

   25 for-stmt: FOR LPAR assign-expr SEMI SEMI expr RPAR LBRACE line RBRACE .

    $default  reduce using rule 25 (for-stmt)


State 446

   24 for-stmt: FOR LPAR assign-expr SEMI expr SEMI RPAR LBRACE line RBRACE .

    $default  reduce using rule 24 (for-stmt)


State 447

   23 for-stmt: FOR LPAR assign-expr SEMI expr SEMI assign-expr RPAR LBRACE line . RBRACE

    RBRACE  shift, and go to state 459


State 448

   22 for-stmt: FOR LPAR assign-expr SEMI expr SEMI expr RPAR LBRACE line . RBRACE

    RBRACE  shift, and go to state 460


State 449

   32 for-stmt: FOR LPAR var-declr SEMI SEMI assign-expr RPAR LBRACE line RBRACE .

    $default  reduce using rule 32 (for-stmt)


State 450

   31 for-stmt: FOR LPAR var-declr SEMI SEMI expr RPAR LBRACE line RBRACE .

    $default  reduce using rule 31 (for-stmt)


State 451

   30 for-stmt: FOR LPAR var-declr SEMI expr SEMI RPAR LBRACE line RBRACE .

    $default  reduce using rule 30 (for-stmt)


State 452

   29 for-stmt: FOR LPAR var-declr SEMI expr SEMI assign-expr RPAR LBRACE line . RBRACE

    RBRACE  shift, and go to state 461


State 453

   28 for-stmt: FOR LPAR var-declr SEMI expr SEMI expr RPAR LBRACE line . RBRACE

    RBRACE  shift, and go to state 462


State 454

   95 params: ID COLON var-type COMMA ID COLON var-type .

    $default  reduce using rule 95 (params)


State 455

   91 func-def: FUNCTION ID LPAR params RPAR COLON var-type LBRACE line RBRACE .

    $default  reduce using rule 91 (func-def)


State 456

   64 if-stmt: IF LPAR assign-expr RPAR LBRACE line RBRACE ELSE LBRACE line . RBRACE

    RBRACE  shift, and go to state 463


State 457

   61 if-stmt: IF LPAR expr RPAR LBRACE line RBRACE ELSE LBRACE line . RBRACE

    RBRACE  shift, and go to state 464


State 458

   86 class-att: ID LPAR params RPAR COLON var-type LBRACE line . RBRACE

    RBRACE  shift, and go to state 465


State 459

   23 for-stmt: FOR LPAR assign-expr SEMI expr SEMI assign-expr RPAR LBRACE line RBRACE .

    $default  reduce using rule 23 (for-stmt)


State 460

   22 for-stmt: FOR LPAR assign-expr SEMI expr SEMI expr RPAR LBRACE line RBRACE .

    $default  reduce using rule 22 (for-stmt)


State 461

   29 for-stmt: FOR LPAR var-declr SEMI expr SEMI assign-expr RPAR LBRACE line RBRACE .

    $default  reduce using rule 29 (for-stmt)


State 462

   28 for-stmt: FOR LPAR var-declr SEMI expr SEMI expr RPAR LBRACE line RBRACE .

    $default  reduce using rule 28 (for-stmt)


State 463

   64 if-stmt: IF LPAR assign-expr RPAR LBRACE line RBRACE ELSE LBRACE line RBRACE .

    $default  reduce using rule 64 (if-stmt)


State 464

   61 if-stmt: IF LPAR expr RPAR LBRACE line RBRACE ELSE LBRACE line RBRACE .

    $default  reduce using rule 61 (if-stmt)


State 465

   86 class-att: ID LPAR params RPAR COLON var-type LBRACE line RBRACE .

    $default  reduce using rule 86 (class-att)
