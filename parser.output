Terminals unused in grammar

   ARROW
   TERNARY
   CHAIN
   PIPELINE
   SPREAD
   CASE
   CATCH
   DEBUGGER
   DEFAULT
   DELETE
   ENUM
   EXPORT
   EXTENDS
   FINALLY
   IMPLEMENTS
   IMPORT
   IN
   INSTANCEOF
   INTERFACE
   PACKAGE
   SUPER
   SWITCH
   THIS
   THROW
   TRY
   TYPEOF
   WITH
   AWAIT
   YIELD
   STATIC
   AS
   ASYNC
   FROM
   GET
   OF
   SET
   TARGET
   CONSTRUCTOR
   DECLARE
   MODULE
   REQUIRE
   SYMBOL
   TYPE


Grammar

    0 $accept: line $end

    1 line: stmt-list
    2     | %empty

    3 stmt-list: stmt-list stmt
    4          | stmt

    5 stmt: var-declr SEMI
    6     | func-def
    7     | class-def
    8     | expr SEMI
    9     | assign-expr SEMI
   10     | if-stmt
   11     | while-stmt
   12     | do-while-stmt
   13     | for-stmt
   14     | RETURN SEMI
   15     | RETURN expr SEMI
   16     | BREAK SEMI
   17     | CONTINUE SEMI

   18 assign-expr: var-att assignment expr
   19            | ID assignment expr
   20            | vet-idx assignment expr

   21 for-stmt: FOR LPAR assign-expr SEMI expr SEMI expr RPAR LBRACE line RBRACE
   22         | FOR LPAR assign-expr SEMI expr SEMI assign-expr RPAR LBRACE line RBRACE
   23         | FOR LPAR assign-expr SEMI expr SEMI RPAR LBRACE line RBRACE
   24         | FOR LPAR assign-expr SEMI SEMI expr RPAR LBRACE line RBRACE
   25         | FOR LPAR assign-expr SEMI SEMI assign-expr RPAR LBRACE line RBRACE
   26         | FOR LPAR assign-expr SEMI SEMI RPAR LBRACE line RBRACE
   27         | FOR LPAR var-declr SEMI expr SEMI expr RPAR LBRACE line RBRACE
   28         | FOR LPAR var-declr SEMI expr SEMI assign-expr RPAR LBRACE line RBRACE
   29         | FOR LPAR var-declr SEMI expr SEMI RPAR LBRACE line RBRACE
   30         | FOR LPAR var-declr SEMI SEMI expr RPAR LBRACE line RBRACE
   31         | FOR LPAR var-declr SEMI SEMI assign-expr RPAR LBRACE line RBRACE
   32         | FOR LPAR var-declr SEMI SEMI RPAR LBRACE line RBRACE
   33         | FOR LPAR SEMI expr SEMI expr RPAR LBRACE line RBRACE
   34         | FOR LPAR SEMI expr SEMI assign-expr RPAR LBRACE line RBRACE
   35         | FOR LPAR SEMI expr SEMI RPAR LBRACE line RBRACE
   36         | FOR LPAR SEMI SEMI expr RPAR LBRACE line RBRACE
   37         | FOR LPAR SEMI SEMI assign-expr RPAR LBRACE line RBRACE
   38         | FOR LPAR SEMI SEMI RPAR LBRACE line RBRACE

   39 assignment: ASSIGN
   40           | LOGICAL_NULL_ASSIGN
   41           | LOGICAL_AND_ASSIGN
   42           | LOGICAL_OR_ASSIGN
   43           | PLUS_ASSIGN
   44           | SUB_ASSIGN
   45           | MULT_ASSIGN
   46           | DIV_ASSIGN
   47           | EXP_ASSIGN
   48           | REM_ASSIGN
   49           | BITWISE_AND_ASSIGN
   50           | BITWISE_OR_ASSIGN
   51           | BITWISE_XOR_ASSIGN
   52           | LSHIFT_ASSIGN
   53           | RSHIFT_ASSIGN
   54           | RSHIFT_UNSIGNED_ASSIGN

   55 do-while-stmt: DO LBRACE line RBRACE WHILE LPAR expr RPAR
   56              | DO LBRACE line RBRACE WHILE LPAR assign-expr RPAR

   57 while-stmt: WHILE LPAR expr RPAR LBRACE line RBRACE
   58           | WHILE LPAR assign-expr RPAR LBRACE line RBRACE

   59 if-stmt: IF LPAR expr RPAR LBRACE line RBRACE
   60        | IF LPAR expr RPAR LBRACE line RBRACE ELSE LBRACE line RBRACE
   61        | IF LPAR expr RPAR LBRACE line RBRACE ELSE stmt
   62        | IF LPAR assign-expr RPAR LBRACE line RBRACE
   63        | IF LPAR assign-expr RPAR LBRACE line RBRACE ELSE LBRACE line RBRACE
   64        | IF LPAR assign-expr RPAR LBRACE line RBRACE ELSE stmt

   65 logic-expr: expr EQ expr
   66           | expr EQ_STRICT expr
   67           | expr INEQ expr
   68           | expr INEQ_STRICT expr
   69           | expr LT expr
   70           | ID LT expr
   71           | expr LT_EQ expr
   72           | expr GT expr
   73           | expr GT_EQ expr
   74           | expr LOGICAL_NULL expr
   75           | expr LOGICAL_AND expr
   76           | expr LOGICAL_OR expr

   77 class-def: CLASS ID LBRACE class-att-list RBRACE

   78 class-att-list: SEMI class-att-list
   79               | class-att SEMI class-att-list
   80               | class-att
   81               | %empty

   82 class-att: ID COLON var-type
   83          | access-modif ID COLON var-type
   84          | ID LPAR params RPAR LBRACE line RBRACE
   85          | ID LPAR params RPAR COLON var-type LBRACE line RBRACE

   86 access-modif: PUBLIC
   87             | PRIVATE
   88             | PROTECTED

   89 func-def: FUNCTION ID LPAR params RPAR LBRACE line RBRACE
   90         | FUNCTION ID LPAR params RPAR COLON var-type LBRACE line RBRACE

   91 params: COMMA ID
   92       | COMMA ID COLON var-type
   93       | ID COMMA ID
   94       | ID COLON var-type COMMA ID COLON var-type
   95       | ID COLON var-type COMMA ID
   96       | ID COLON var-type
   97       | ID COMMA ID COLON var-type
   98       | %empty

   99 var-declr: LET id-list
  100          | LET id-list ASSIGN expr
  101          | LET id-list ASSIGN obj-def
  102          | LET ID COLON var-type
  103          | LET ID COLON var-type ASSIGN expr
  104          | LET ID COLON var-type LBRACKET RBRACKET
  105          | LET ID COLON var-type LBRACKET RBRACKET ASSIGN expr
  106          | VAR id-list
  107          | VAR id-list ASSIGN expr
  108          | VAR id-list ASSIGN obj-def
  109          | VAR ID COLON var-type
  110          | VAR ID COLON var-type ASSIGN expr
  111          | VAR ID COLON var-type LBRACKET RBRACKET
  112          | VAR ID COLON var-type LBRACKET RBRACKET ASSIGN expr
  113          | CONST_RW id-list ASSIGN expr
  114          | CONST_RW ID COLON var-type ASSIGN expr
  115          | CONST_RW ID COLON var-type LBRACKET RBRACKET ASSIGN expr
  116          | CONST_RW id-list ASSIGN obj-def

  117 id-list: ID COMMA id-list
  118        | ID

  119 obj-def: LBRACE obj-att-list RBRACE

  120 obj-att-list: COMMA obj-att-list
  121             | obj-att COMMA obj-att-list
  122             | obj-att
  123             | %empty

  124 obj-att: ID COLON var-val

  125 var-type: NUMBER
  126         | STRING
  127         | UNKNOWN
  128         | BOOLTYPE
  129         | ANY
  130         | VOID_RW
  131         | NEVER

  132 expr: idx-safe-expr
  133     | idx-unsafe-expr
  134     | LPAR expr RPAR

  135 idx-unsafe-expr: array-expr
  136                | logic-expr
  137                | var-obj

  138 idx-safe-expr: var-val
  139              | var-att
  140              | arit-expr
  141              | bitw-expr
  142              | shift-expr
  143              | unary-expr
  144              | vet-idx
  145              | ID

  146 vet-idx: ID LBRACKET idx-safe-expr RBRACKET

  147 unary-expr: INCREMENT ID
  148           | INCREMENT var-att
  149           | DECREMENT ID
  150           | DECREMENT var-att
  151           | ID INCREMENT
  152           | var-att INCREMENT
  153           | ID DECREMENT
  154           | var-att DECREMENT
  155           | LOGICAL_NOT expr
  156           | BITWISE_NOT expr

  157 arit-expr: expr PLUS expr
  158          | expr SUB expr
  159          | expr MULT expr
  160          | expr DIV expr
  161          | expr EXP expr
  162          | expr REM expr

  163 bitw-expr: expr BITWISE_AND expr
  164          | expr BITWISE_OR expr
  165          | expr BITWISE_XOR expr

  166 shift-expr: expr LSHIFT expr
  167           | expr RSHIFT expr
  168           | expr RSHIFT_UNSIGNED expr

  169 var-att: ID DOT var-att
  170        | var-att DOT ID
  171        | ID DOT var-met
  172        | var-met DOT ID
  173        | var-met DOT var-att
  174        | var-att DOT var-met
  175        | ID DOT ID

  176 var-met: ID LPAR args-list RPAR

  177 args-list: COMMA args-list
  178          | expr COMMA args-list
  179          | assign-expr COMMA args-list
  180          | expr
  181          | assign-expr
  182          | %empty

  183 var-obj: ID LPAR args-list RPAR
  184        | ID LT var-type GT LPAR args-list RPAR
  185        | NEW ID LPAR args-list RPAR
  186        | NEW ID LT var-type GT LPAR args-list RPAR

  187 var-val: INT_VAL
  188        | REAL_VAL
  189        | STR_VAL
  190        | TRUE_RW
  191        | FALSE_RW
  192        | SUB INT_VAL
  193        | SUB REAL_VAL
  194        | SUB STR_VAL
  195        | SUB TRUE_RW
  196        | SUB FALSE_RW
  197        | NULL_RW
  198        | UNDEFINED

  199 array-expr: LBRACKET elmts-list RBRACKET

  200 elmts-list: COMMA elmts-list
  201           | var-val COMMA elmts-list
  202           | var-val
  203           | %empty


Terminals, with rules where they appear

$end (0) 0
error (256)
ASSIGN (258) 39 100 101 103 105 107 108 110 112 113 114 115 116
ARROW (259)
COMMA (260) 91 92 93 94 95 97 117 120 121 177 178 179 200 201
SEMI (261) 5 8 9 14 15 16 17 21 22 23 24 25 26 27 28 29 30 31 32 33
    34 35 36 37 38 78 79
COLON (262) 82 83 85 90 92 94 95 96 97 102 103 104 105 109 110 111
    112 114 115 124
TERNARY (263)
CHAIN (264)
PIPELINE (265)
DOT (266) 169 170 171 172 173 174 175
SPREAD (267)
PLUS (268) 157
INCREMENT (269) 147 148 151 152
PLUS_ASSIGN (270) 43
SUB (271) 158 192 193 194 195 196
DECREMENT (272) 149 150 153 154
SUB_ASSIGN (273) 44
MULT (274) 159
MULT_ASSIGN (275) 45
DIV (276) 160
DIV_ASSIGN (277) 46
EXP (278) 161
EXP_ASSIGN (279) 47
REM (280) 162
REM_ASSIGN (281) 48
BITWISE_NOT (282) 156
BITWISE_AND (283) 163
BITWISE_AND_ASSIGN (284) 49
BITWISE_OR (285) 164
BITWISE_OR_ASSIGN (286) 50
BITWISE_XOR (287) 165
BITWISE_XOR_ASSIGN (288) 51
LOGICAL_NOT (289) 155
LOGICAL_NULL (290) 74
LOGICAL_NULL_ASSIGN (291) 40
LOGICAL_AND (292) 75
LOGICAL_AND_ASSIGN (293) 41
LOGICAL_OR (294) 76
LOGICAL_OR_ASSIGN (295) 42
EQ (296) 65
EQ_STRICT (297) 66
INEQ (298) 67
INEQ_STRICT (299) 68
LT (300) 69 70 184 186
LT_EQ (301) 71
GT (302) 72 184 186
GT_EQ (303) 73
LSHIFT (304) 166
LSHIFT_ASSIGN (305) 52
RSHIFT (306) 167
RSHIFT_ASSIGN (307) 53
RSHIFT_UNSIGNED (308) 168
RSHIFT_UNSIGNED_ASSIGN (309) 54
LPAR (310) 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 55
    56 57 58 59 60 61 62 63 64 84 85 89 90 134 176 183 184 185 186
RPAR (311) 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 55
    56 57 58 59 60 61 62 63 64 84 85 89 90 134 176 183 184 185 186
LBRACE (312) 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38
    55 56 57 58 59 60 61 62 63 64 77 84 85 89 90 119
RBRACE (313) 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38
    55 56 57 58 59 60 61 62 63 64 77 84 85 89 90 119
LBRACKET (314) 104 105 111 112 115 146 199
RBRACKET (315) 104 105 111 112 115 146 199
INT_VAL (316) 187 192
REAL_VAL (317) 188 193
STR_VAL (318) 189 194
ID (319) 19 70 77 82 83 84 85 89 90 91 92 93 94 95 96 97 102 103 104
    105 109 110 111 112 114 115 117 118 124 145 146 147 149 151 153
    169 170 171 172 175 176 183 184 185 186
BREAK (320) 16
CASE (321)
CATCH (322)
CLASS (323) 77
CONST_RW (324) 113 114 115 116
CONTINUE (325) 17
DEBUGGER (326)
DEFAULT (327)
DELETE (328)
DO (329) 55 56
ELSE (330) 60 61 63 64
ENUM (331)
EXPORT (332)
EXTENDS (333)
FALSE_RW (334) 191 196
FINALLY (335)
FOR (336) 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38
FUNCTION (337) 89 90
IF (338) 59 60 61 62 63 64
IMPLEMENTS (339)
IMPORT (340)
IN (341)
INSTANCEOF (342)
INTERFACE (343)
LET (344) 99 100 101 102 103 104 105
NEW (345) 185 186
NULL_RW (346) 197
PACKAGE (347)
PRIVATE (348) 87
PROTECTED (349) 88
PUBLIC (350) 86
RETURN (351) 14 15
SUPER (352)
SWITCH (353)
THIS (354)
THROW (355)
TRUE_RW (356) 190 195
TRY (357)
TYPEOF (358)
VAR (359) 106 107 108 109 110 111 112
VOID_RW (360) 130
WHILE (361) 55 56 57 58
WITH (362)
AWAIT (363)
YIELD (364)
STATIC (365)
AS (366)
ASYNC (367)
FROM (368)
GET (369)
OF (370)
SET (371)
TARGET (372)
ANY (373) 129
BOOLTYPE (374) 128
CONSTRUCTOR (375)
DECLARE (376)
MODULE (377)
REQUIRE (378)
NEVER (379) 131
NUMBER (380) 125
STRING (381) 126
SYMBOL (382)
TYPE (383)
UNDEFINED (384) 198
UNKNOWN (385) 127
E_ID (386)


Nonterminals, with rules where they appear

$accept (132)
    on left: 0
line (133)
    on left: 1 2, on right: 0 21 22 23 24 25 26 27 28 29 30 31 32 33
    34 35 36 37 38 55 56 57 58 59 60 61 62 63 64 84 85 89 90
stmt-list (134)
    on left: 3 4, on right: 1 3
stmt (135)
    on left: 5 6 7 8 9 10 11 12 13 14 15 16 17, on right: 3 4 61 64
assign-expr (136)
    on left: 18 19 20, on right: 9 21 22 23 24 25 26 28 31 34 37 56
    58 62 63 64 179 181
for-stmt (137)
    on left: 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38,
    on right: 13
assignment (138)
    on left: 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54, on right:
    18 19 20
do-while-stmt (139)
    on left: 55 56, on right: 12
while-stmt (140)
    on left: 57 58, on right: 11
if-stmt (141)
    on left: 59 60 61 62 63 64, on right: 10
logic-expr (142)
    on left: 65 66 67 68 69 70 71 72 73 74 75 76, on right: 136
class-def (143)
    on left: 77, on right: 7
class-att-list (144)
    on left: 78 79 80 81, on right: 77 78 79
class-att (145)
    on left: 82 83 84 85, on right: 79 80
access-modif (146)
    on left: 86 87 88, on right: 83
func-def (147)
    on left: 89 90, on right: 6
params (148)
    on left: 91 92 93 94 95 96 97 98, on right: 84 85 89 90
var-declr (149)
    on left: 99 100 101 102 103 104 105 106 107 108 109 110 111 112
    113 114 115 116, on right: 5 27 28 29 30 31 32
id-list (150)
    on left: 117 118, on right: 99 100 101 106 107 108 113 116 117
obj-def (151)
    on left: 119, on right: 101 108 116
obj-att-list (152)
    on left: 120 121 122 123, on right: 119 120 121
obj-att (153)
    on left: 124, on right: 121 122
var-type (154)
    on left: 125 126 127 128 129 130 131, on right: 82 83 85 90 92
    94 95 96 97 102 103 104 105 109 110 111 112 114 115 184 186
expr (155)
    on left: 132 133 134, on right: 8 15 18 19 20 21 22 23 24 27 28
    29 30 33 34 35 36 55 57 59 60 61 65 66 67 68 69 70 71 72 73 74
    75 76 100 103 105 107 110 112 113 114 115 134 155 156 157 158 159
    160 161 162 163 164 165 166 167 168 178 180
idx-unsafe-expr (156)
    on left: 135 136 137, on right: 133
idx-safe-expr (157)
    on left: 138 139 140 141 142 143 144 145, on right: 132 146
vet-idx (158)
    on left: 146, on right: 20 144
unary-expr (159)
    on left: 147 148 149 150 151 152 153 154 155 156, on right: 143
arit-expr (160)
    on left: 157 158 159 160 161 162, on right: 140
bitw-expr (161)
    on left: 163 164 165, on right: 141
shift-expr (162)
    on left: 166 167 168, on right: 142
var-att (163)
    on left: 169 170 171 172 173 174 175, on right: 18 139 148 150
    152 154 169 170 173 174
var-met (164)
    on left: 176, on right: 171 172 173 174
args-list (165)
    on left: 177 178 179 180 181 182, on right: 176 177 178 179 183
    184 185 186
var-obj (166)
    on left: 183 184 185 186, on right: 137
var-val (167)
    on left: 187 188 189 190 191 192 193 194 195 196 197 198, on right:
    124 138 201 202
array-expr (168)
    on left: 199, on right: 135
elmts-list (169)
    on left: 200 201 202 203, on right: 199 200 201


State 0

    0 $accept: . line $end

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 2 (line)

    line             go to state 29
    stmt-list        go to state 30
    stmt             go to state 31
    assign-expr      go to state 32
    for-stmt         go to state 33
    do-while-stmt    go to state 34
    while-stmt       go to state 35
    if-stmt          go to state 36
    logic-expr       go to state 37
    class-def        go to state 38
    func-def         go to state 39
    var-declr        go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 1

  147 unary-expr: INCREMENT . ID
  148           | INCREMENT . var-att

    ID  shift, and go to state 54

    var-att  go to state 55
    var-met  go to state 50


State 2

  192 var-val: SUB . INT_VAL
  193        | SUB . REAL_VAL
  194        | SUB . STR_VAL
  195        | SUB . TRUE_RW
  196        | SUB . FALSE_RW

    INT_VAL   shift, and go to state 56
    REAL_VAL  shift, and go to state 57
    STR_VAL   shift, and go to state 58
    FALSE_RW  shift, and go to state 59
    TRUE_RW   shift, and go to state 60


State 3

  149 unary-expr: DECREMENT . ID
  150           | DECREMENT . var-att

    ID  shift, and go to state 61

    var-att  go to state 62
    var-met  go to state 50


State 4

  156 unary-expr: BITWISE_NOT . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 37
    expr             go to state 64
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 5

  155 unary-expr: LOGICAL_NOT . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 37
    expr             go to state 67
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 6

  134 expr: LPAR . expr RPAR

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 37
    expr             go to state 68
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 7

  199 array-expr: LBRACKET . elmts-list RBRACKET

    COMMA      shift, and go to state 69
    SUB        shift, and go to state 2
    INT_VAL    shift, and go to state 8
    REAL_VAL   shift, and go to state 9
    STR_VAL    shift, and go to state 10
    FALSE_RW   shift, and go to state 17
    NULL_RW    shift, and go to state 23
    TRUE_RW    shift, and go to state 25
    UNDEFINED  shift, and go to state 28

    $default  reduce using rule 203 (elmts-list)

    var-val     go to state 70
    elmts-list  go to state 71


State 8

  187 var-val: INT_VAL .

    $default  reduce using rule 187 (var-val)


State 9

  188 var-val: REAL_VAL .

    $default  reduce using rule 188 (var-val)


State 10

  189 var-val: STR_VAL .

    $default  reduce using rule 189 (var-val)


State 11

   19 assign-expr: ID . assignment expr
   70 logic-expr: ID . LT expr
  145 idx-safe-expr: ID .
  146 vet-idx: ID . LBRACKET idx-safe-expr RBRACKET
  151 unary-expr: ID . INCREMENT
  153           | ID . DECREMENT
  169 var-att: ID . DOT var-att
  171        | ID . DOT var-met
  175        | ID . DOT ID
  176 var-met: ID . LPAR args-list RPAR
  183 var-obj: ID . LPAR args-list RPAR
  184        | ID . LT var-type GT LPAR args-list RPAR

    ASSIGN                  shift, and go to state 72
    DOT                     shift, and go to state 73
    INCREMENT               shift, and go to state 74
    PLUS_ASSIGN             shift, and go to state 75
    DECREMENT               shift, and go to state 76
    SUB_ASSIGN              shift, and go to state 77
    MULT_ASSIGN             shift, and go to state 78
    DIV_ASSIGN              shift, and go to state 79
    EXP_ASSIGN              shift, and go to state 80
    REM_ASSIGN              shift, and go to state 81
    BITWISE_AND_ASSIGN      shift, and go to state 82
    BITWISE_OR_ASSIGN       shift, and go to state 83
    BITWISE_XOR_ASSIGN      shift, and go to state 84
    LOGICAL_NULL_ASSIGN     shift, and go to state 85
    LOGICAL_AND_ASSIGN      shift, and go to state 86
    LOGICAL_OR_ASSIGN       shift, and go to state 87
    LT                      shift, and go to state 88
    LSHIFT_ASSIGN           shift, and go to state 89
    RSHIFT_ASSIGN           shift, and go to state 90
    RSHIFT_UNSIGNED_ASSIGN  shift, and go to state 91
    LPAR                    shift, and go to state 92
    LBRACKET                shift, and go to state 93

    $default  reduce using rule 145 (idx-safe-expr)

    assignment  go to state 94


State 12

   16 stmt: BREAK . SEMI

    SEMI  shift, and go to state 95


State 13

   77 class-def: CLASS . ID LBRACE class-att-list RBRACE

    ID  shift, and go to state 96


State 14

  113 var-declr: CONST_RW . id-list ASSIGN expr
  114          | CONST_RW . ID COLON var-type ASSIGN expr
  115          | CONST_RW . ID COLON var-type LBRACKET RBRACKET ASSIGN expr
  116          | CONST_RW . id-list ASSIGN obj-def

    ID  shift, and go to state 97

    id-list  go to state 98


State 15

   17 stmt: CONTINUE . SEMI

    SEMI  shift, and go to state 99


State 16

   55 do-while-stmt: DO . LBRACE line RBRACE WHILE LPAR expr RPAR
   56              | DO . LBRACE line RBRACE WHILE LPAR assign-expr RPAR

    LBRACE  shift, and go to state 100


State 17

  191 var-val: FALSE_RW .

    $default  reduce using rule 191 (var-val)


State 18

   21 for-stmt: FOR . LPAR assign-expr SEMI expr SEMI expr RPAR LBRACE line RBRACE
   22         | FOR . LPAR assign-expr SEMI expr SEMI assign-expr RPAR LBRACE line RBRACE
   23         | FOR . LPAR assign-expr SEMI expr SEMI RPAR LBRACE line RBRACE
   24         | FOR . LPAR assign-expr SEMI SEMI expr RPAR LBRACE line RBRACE
   25         | FOR . LPAR assign-expr SEMI SEMI assign-expr RPAR LBRACE line RBRACE
   26         | FOR . LPAR assign-expr SEMI SEMI RPAR LBRACE line RBRACE
   27         | FOR . LPAR var-declr SEMI expr SEMI expr RPAR LBRACE line RBRACE
   28         | FOR . LPAR var-declr SEMI expr SEMI assign-expr RPAR LBRACE line RBRACE
   29         | FOR . LPAR var-declr SEMI expr SEMI RPAR LBRACE line RBRACE
   30         | FOR . LPAR var-declr SEMI SEMI expr RPAR LBRACE line RBRACE
   31         | FOR . LPAR var-declr SEMI SEMI assign-expr RPAR LBRACE line RBRACE
   32         | FOR . LPAR var-declr SEMI SEMI RPAR LBRACE line RBRACE
   33         | FOR . LPAR SEMI expr SEMI expr RPAR LBRACE line RBRACE
   34         | FOR . LPAR SEMI expr SEMI assign-expr RPAR LBRACE line RBRACE
   35         | FOR . LPAR SEMI expr SEMI RPAR LBRACE line RBRACE
   36         | FOR . LPAR SEMI SEMI expr RPAR LBRACE line RBRACE
   37         | FOR . LPAR SEMI SEMI assign-expr RPAR LBRACE line RBRACE
   38         | FOR . LPAR SEMI SEMI RPAR LBRACE line RBRACE

    LPAR  shift, and go to state 101


State 19

   89 func-def: FUNCTION . ID LPAR params RPAR LBRACE line RBRACE
   90         | FUNCTION . ID LPAR params RPAR COLON var-type LBRACE line RBRACE

    ID  shift, and go to state 102


State 20

   59 if-stmt: IF . LPAR expr RPAR LBRACE line RBRACE
   60        | IF . LPAR expr RPAR LBRACE line RBRACE ELSE LBRACE line RBRACE
   61        | IF . LPAR expr RPAR LBRACE line RBRACE ELSE stmt
   62        | IF . LPAR assign-expr RPAR LBRACE line RBRACE
   63        | IF . LPAR assign-expr RPAR LBRACE line RBRACE ELSE LBRACE line RBRACE
   64        | IF . LPAR assign-expr RPAR LBRACE line RBRACE ELSE stmt

    LPAR  shift, and go to state 103


State 21

   99 var-declr: LET . id-list
  100          | LET . id-list ASSIGN expr
  101          | LET . id-list ASSIGN obj-def
  102          | LET . ID COLON var-type
  103          | LET . ID COLON var-type ASSIGN expr
  104          | LET . ID COLON var-type LBRACKET RBRACKET
  105          | LET . ID COLON var-type LBRACKET RBRACKET ASSIGN expr

    ID  shift, and go to state 104

    id-list  go to state 105


State 22

  185 var-obj: NEW . ID LPAR args-list RPAR
  186        | NEW . ID LT var-type GT LPAR args-list RPAR

    ID  shift, and go to state 106


State 23

  197 var-val: NULL_RW .

    $default  reduce using rule 197 (var-val)


State 24

   14 stmt: RETURN . SEMI
   15     | RETURN . expr SEMI

    SEMI         shift, and go to state 107
    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 37
    expr             go to state 108
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 25

  190 var-val: TRUE_RW .

    $default  reduce using rule 190 (var-val)


State 26

  106 var-declr: VAR . id-list
  107          | VAR . id-list ASSIGN expr
  108          | VAR . id-list ASSIGN obj-def
  109          | VAR . ID COLON var-type
  110          | VAR . ID COLON var-type ASSIGN expr
  111          | VAR . ID COLON var-type LBRACKET RBRACKET
  112          | VAR . ID COLON var-type LBRACKET RBRACKET ASSIGN expr

    ID  shift, and go to state 109

    id-list  go to state 110


State 27

   57 while-stmt: WHILE . LPAR expr RPAR LBRACE line RBRACE
   58           | WHILE . LPAR assign-expr RPAR LBRACE line RBRACE

    LPAR  shift, and go to state 111


State 28

  198 var-val: UNDEFINED .

    $default  reduce using rule 198 (var-val)


State 29

    0 $accept: line . $end

    $end  shift, and go to state 112


State 30

    1 line: stmt-list .
    3 stmt-list: stmt-list . stmt

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 1 (line)

    stmt             go to state 113
    assign-expr      go to state 32
    for-stmt         go to state 33
    do-while-stmt    go to state 34
    while-stmt       go to state 35
    if-stmt          go to state 36
    logic-expr       go to state 37
    class-def        go to state 38
    func-def         go to state 39
    var-declr        go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 31

    4 stmt-list: stmt .

    $default  reduce using rule 4 (stmt-list)


State 32

    9 stmt: assign-expr . SEMI

    SEMI  shift, and go to state 114


State 33

   13 stmt: for-stmt .

    $default  reduce using rule 13 (stmt)


State 34

   12 stmt: do-while-stmt .

    $default  reduce using rule 12 (stmt)


State 35

   11 stmt: while-stmt .

    $default  reduce using rule 11 (stmt)


State 36

   10 stmt: if-stmt .

    $default  reduce using rule 10 (stmt)


State 37

  136 idx-unsafe-expr: logic-expr .

    $default  reduce using rule 136 (idx-unsafe-expr)


State 38

    7 stmt: class-def .

    $default  reduce using rule 7 (stmt)


State 39

    6 stmt: func-def .

    $default  reduce using rule 6 (stmt)


State 40

    5 stmt: var-declr . SEMI

    SEMI  shift, and go to state 115


State 41

    8 stmt: expr . SEMI
   65 logic-expr: expr . EQ expr
   66           | expr . EQ_STRICT expr
   67           | expr . INEQ expr
   68           | expr . INEQ_STRICT expr
   69           | expr . LT expr
   71           | expr . LT_EQ expr
   72           | expr . GT expr
   73           | expr . GT_EQ expr
   74           | expr . LOGICAL_NULL expr
   75           | expr . LOGICAL_AND expr
   76           | expr . LOGICAL_OR expr
  157 arit-expr: expr . PLUS expr
  158          | expr . SUB expr
  159          | expr . MULT expr
  160          | expr . DIV expr
  161          | expr . EXP expr
  162          | expr . REM expr
  163 bitw-expr: expr . BITWISE_AND expr
  164          | expr . BITWISE_OR expr
  165          | expr . BITWISE_XOR expr
  166 shift-expr: expr . LSHIFT expr
  167           | expr . RSHIFT expr
  168           | expr . RSHIFT_UNSIGNED expr

    SEMI             shift, and go to state 116
    PLUS             shift, and go to state 117
    SUB              shift, and go to state 118
    MULT             shift, and go to state 119
    DIV              shift, and go to state 120
    EXP              shift, and go to state 121
    REM              shift, and go to state 122
    BITWISE_AND      shift, and go to state 123
    BITWISE_OR       shift, and go to state 124
    BITWISE_XOR      shift, and go to state 125
    LOGICAL_NULL     shift, and go to state 126
    LOGICAL_AND      shift, and go to state 127
    LOGICAL_OR       shift, and go to state 128
    EQ               shift, and go to state 129
    EQ_STRICT        shift, and go to state 130
    INEQ             shift, and go to state 131
    INEQ_STRICT      shift, and go to state 132
    LT               shift, and go to state 133
    LT_EQ            shift, and go to state 134
    GT               shift, and go to state 135
    GT_EQ            shift, and go to state 136
    LSHIFT           shift, and go to state 137
    RSHIFT           shift, and go to state 138
    RSHIFT_UNSIGNED  shift, and go to state 139


State 42

  133 expr: idx-unsafe-expr .

    $default  reduce using rule 133 (expr)


State 43

  132 expr: idx-safe-expr .

    $default  reduce using rule 132 (expr)


State 44

   20 assign-expr: vet-idx . assignment expr
  144 idx-safe-expr: vet-idx .

    ASSIGN                  shift, and go to state 72
    PLUS_ASSIGN             shift, and go to state 75
    SUB_ASSIGN              shift, and go to state 77
    MULT_ASSIGN             shift, and go to state 78
    DIV_ASSIGN              shift, and go to state 79
    EXP_ASSIGN              shift, and go to state 80
    REM_ASSIGN              shift, and go to state 81
    BITWISE_AND_ASSIGN      shift, and go to state 82
    BITWISE_OR_ASSIGN       shift, and go to state 83
    BITWISE_XOR_ASSIGN      shift, and go to state 84
    LOGICAL_NULL_ASSIGN     shift, and go to state 85
    LOGICAL_AND_ASSIGN      shift, and go to state 86
    LOGICAL_OR_ASSIGN       shift, and go to state 87
    LSHIFT_ASSIGN           shift, and go to state 89
    RSHIFT_ASSIGN           shift, and go to state 90
    RSHIFT_UNSIGNED_ASSIGN  shift, and go to state 91

    $default  reduce using rule 144 (idx-safe-expr)

    assignment  go to state 140


State 45

  143 idx-safe-expr: unary-expr .

    $default  reduce using rule 143 (idx-safe-expr)


State 46

  140 idx-safe-expr: arit-expr .

    $default  reduce using rule 140 (idx-safe-expr)


State 47

  141 idx-safe-expr: bitw-expr .

    $default  reduce using rule 141 (idx-safe-expr)


State 48

  142 idx-safe-expr: shift-expr .

    $default  reduce using rule 142 (idx-safe-expr)


State 49

   18 assign-expr: var-att . assignment expr
  139 idx-safe-expr: var-att .
  152 unary-expr: var-att . INCREMENT
  154           | var-att . DECREMENT
  170 var-att: var-att . DOT ID
  174        | var-att . DOT var-met

    ASSIGN                  shift, and go to state 72
    DOT                     shift, and go to state 141
    INCREMENT               shift, and go to state 142
    PLUS_ASSIGN             shift, and go to state 75
    DECREMENT               shift, and go to state 143
    SUB_ASSIGN              shift, and go to state 77
    MULT_ASSIGN             shift, and go to state 78
    DIV_ASSIGN              shift, and go to state 79
    EXP_ASSIGN              shift, and go to state 80
    REM_ASSIGN              shift, and go to state 81
    BITWISE_AND_ASSIGN      shift, and go to state 82
    BITWISE_OR_ASSIGN       shift, and go to state 83
    BITWISE_XOR_ASSIGN      shift, and go to state 84
    LOGICAL_NULL_ASSIGN     shift, and go to state 85
    LOGICAL_AND_ASSIGN      shift, and go to state 86
    LOGICAL_OR_ASSIGN       shift, and go to state 87
    LSHIFT_ASSIGN           shift, and go to state 89
    RSHIFT_ASSIGN           shift, and go to state 90
    RSHIFT_UNSIGNED_ASSIGN  shift, and go to state 91

    $default  reduce using rule 139 (idx-safe-expr)

    assignment  go to state 144


State 50

  172 var-att: var-met . DOT ID
  173        | var-met . DOT var-att

    DOT  shift, and go to state 145


State 51

  137 idx-unsafe-expr: var-obj .

    $default  reduce using rule 137 (idx-unsafe-expr)


State 52

  138 idx-safe-expr: var-val .

    $default  reduce using rule 138 (idx-safe-expr)


State 53

  135 idx-unsafe-expr: array-expr .

    $default  reduce using rule 135 (idx-unsafe-expr)


State 54

  147 unary-expr: INCREMENT ID .
  169 var-att: ID . DOT var-att
  171        | ID . DOT var-met
  175        | ID . DOT ID
  176 var-met: ID . LPAR args-list RPAR

    DOT   shift, and go to state 73
    LPAR  shift, and go to state 146

    $default  reduce using rule 147 (unary-expr)


State 55

  148 unary-expr: INCREMENT var-att .
  170 var-att: var-att . DOT ID
  174        | var-att . DOT var-met

    DOT  shift, and go to state 141

    $default  reduce using rule 148 (unary-expr)


State 56

  192 var-val: SUB INT_VAL .

    $default  reduce using rule 192 (var-val)


State 57

  193 var-val: SUB REAL_VAL .

    $default  reduce using rule 193 (var-val)


State 58

  194 var-val: SUB STR_VAL .

    $default  reduce using rule 194 (var-val)


State 59

  196 var-val: SUB FALSE_RW .

    $default  reduce using rule 196 (var-val)


State 60

  195 var-val: SUB TRUE_RW .

    $default  reduce using rule 195 (var-val)


State 61

  149 unary-expr: DECREMENT ID .
  169 var-att: ID . DOT var-att
  171        | ID . DOT var-met
  175        | ID . DOT ID
  176 var-met: ID . LPAR args-list RPAR

    DOT   shift, and go to state 73
    LPAR  shift, and go to state 146

    $default  reduce using rule 149 (unary-expr)


State 62

  150 unary-expr: DECREMENT var-att .
  170 var-att: var-att . DOT ID
  174        | var-att . DOT var-met

    DOT  shift, and go to state 141

    $default  reduce using rule 150 (unary-expr)


State 63

   70 logic-expr: ID . LT expr
  145 idx-safe-expr: ID .
  146 vet-idx: ID . LBRACKET idx-safe-expr RBRACKET
  151 unary-expr: ID . INCREMENT
  153           | ID . DECREMENT
  169 var-att: ID . DOT var-att
  171        | ID . DOT var-met
  175        | ID . DOT ID
  176 var-met: ID . LPAR args-list RPAR
  183 var-obj: ID . LPAR args-list RPAR
  184        | ID . LT var-type GT LPAR args-list RPAR

    DOT        shift, and go to state 73
    INCREMENT  shift, and go to state 74
    DECREMENT  shift, and go to state 76
    LT         shift, and go to state 88
    LPAR       shift, and go to state 92
    LBRACKET   shift, and go to state 93

    $default  reduce using rule 145 (idx-safe-expr)


State 64

   65 logic-expr: expr . EQ expr
   66           | expr . EQ_STRICT expr
   67           | expr . INEQ expr
   68           | expr . INEQ_STRICT expr
   69           | expr . LT expr
   71           | expr . LT_EQ expr
   72           | expr . GT expr
   73           | expr . GT_EQ expr
   74           | expr . LOGICAL_NULL expr
   75           | expr . LOGICAL_AND expr
   76           | expr . LOGICAL_OR expr
  156 unary-expr: BITWISE_NOT expr .
  157 arit-expr: expr . PLUS expr
  158          | expr . SUB expr
  159          | expr . MULT expr
  160          | expr . DIV expr
  161          | expr . EXP expr
  162          | expr . REM expr
  163 bitw-expr: expr . BITWISE_AND expr
  164          | expr . BITWISE_OR expr
  165          | expr . BITWISE_XOR expr
  166 shift-expr: expr . LSHIFT expr
  167           | expr . RSHIFT expr
  168           | expr . RSHIFT_UNSIGNED expr

    $default  reduce using rule 156 (unary-expr)


State 65

  144 idx-safe-expr: vet-idx .

    $default  reduce using rule 144 (idx-safe-expr)


State 66

  139 idx-safe-expr: var-att .
  152 unary-expr: var-att . INCREMENT
  154           | var-att . DECREMENT
  170 var-att: var-att . DOT ID
  174        | var-att . DOT var-met

    DOT        shift, and go to state 141
    INCREMENT  shift, and go to state 142
    DECREMENT  shift, and go to state 143

    $default  reduce using rule 139 (idx-safe-expr)


State 67

   65 logic-expr: expr . EQ expr
   66           | expr . EQ_STRICT expr
   67           | expr . INEQ expr
   68           | expr . INEQ_STRICT expr
   69           | expr . LT expr
   71           | expr . LT_EQ expr
   72           | expr . GT expr
   73           | expr . GT_EQ expr
   74           | expr . LOGICAL_NULL expr
   75           | expr . LOGICAL_AND expr
   76           | expr . LOGICAL_OR expr
  155 unary-expr: LOGICAL_NOT expr .
  157 arit-expr: expr . PLUS expr
  158          | expr . SUB expr
  159          | expr . MULT expr
  160          | expr . DIV expr
  161          | expr . EXP expr
  162          | expr . REM expr
  163 bitw-expr: expr . BITWISE_AND expr
  164          | expr . BITWISE_OR expr
  165          | expr . BITWISE_XOR expr
  166 shift-expr: expr . LSHIFT expr
  167           | expr . RSHIFT expr
  168           | expr . RSHIFT_UNSIGNED expr

    $default  reduce using rule 155 (unary-expr)


State 68

   65 logic-expr: expr . EQ expr
   66           | expr . EQ_STRICT expr
   67           | expr . INEQ expr
   68           | expr . INEQ_STRICT expr
   69           | expr . LT expr
   71           | expr . LT_EQ expr
   72           | expr . GT expr
   73           | expr . GT_EQ expr
   74           | expr . LOGICAL_NULL expr
   75           | expr . LOGICAL_AND expr
   76           | expr . LOGICAL_OR expr
  134 expr: LPAR expr . RPAR
  157 arit-expr: expr . PLUS expr
  158          | expr . SUB expr
  159          | expr . MULT expr
  160          | expr . DIV expr
  161          | expr . EXP expr
  162          | expr . REM expr
  163 bitw-expr: expr . BITWISE_AND expr
  164          | expr . BITWISE_OR expr
  165          | expr . BITWISE_XOR expr
  166 shift-expr: expr . LSHIFT expr
  167           | expr . RSHIFT expr
  168           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 117
    SUB              shift, and go to state 118
    MULT             shift, and go to state 119
    DIV              shift, and go to state 120
    EXP              shift, and go to state 121
    REM              shift, and go to state 122
    BITWISE_AND      shift, and go to state 123
    BITWISE_OR       shift, and go to state 124
    BITWISE_XOR      shift, and go to state 125
    LOGICAL_NULL     shift, and go to state 126
    LOGICAL_AND      shift, and go to state 127
    LOGICAL_OR       shift, and go to state 128
    EQ               shift, and go to state 129
    EQ_STRICT        shift, and go to state 130
    INEQ             shift, and go to state 131
    INEQ_STRICT      shift, and go to state 132
    LT               shift, and go to state 133
    LT_EQ            shift, and go to state 134
    GT               shift, and go to state 135
    GT_EQ            shift, and go to state 136
    LSHIFT           shift, and go to state 137
    RSHIFT           shift, and go to state 138
    RSHIFT_UNSIGNED  shift, and go to state 139
    RPAR             shift, and go to state 147


State 69

  200 elmts-list: COMMA . elmts-list

    COMMA      shift, and go to state 69
    SUB        shift, and go to state 2
    INT_VAL    shift, and go to state 8
    REAL_VAL   shift, and go to state 9
    STR_VAL    shift, and go to state 10
    FALSE_RW   shift, and go to state 17
    NULL_RW    shift, and go to state 23
    TRUE_RW    shift, and go to state 25
    UNDEFINED  shift, and go to state 28

    $default  reduce using rule 203 (elmts-list)

    var-val     go to state 70
    elmts-list  go to state 148


State 70

  201 elmts-list: var-val . COMMA elmts-list
  202           | var-val .

    COMMA  shift, and go to state 149

    $default  reduce using rule 202 (elmts-list)


State 71

  199 array-expr: LBRACKET elmts-list . RBRACKET

    RBRACKET  shift, and go to state 150


State 72

   39 assignment: ASSIGN .

    $default  reduce using rule 39 (assignment)


State 73

  169 var-att: ID DOT . var-att
  171        | ID DOT . var-met
  175        | ID DOT . ID

    ID  shift, and go to state 151

    var-att  go to state 152
    var-met  go to state 153


State 74

  151 unary-expr: ID INCREMENT .

    $default  reduce using rule 151 (unary-expr)


State 75

   43 assignment: PLUS_ASSIGN .

    $default  reduce using rule 43 (assignment)


State 76

  153 unary-expr: ID DECREMENT .

    $default  reduce using rule 153 (unary-expr)


State 77

   44 assignment: SUB_ASSIGN .

    $default  reduce using rule 44 (assignment)


State 78

   45 assignment: MULT_ASSIGN .

    $default  reduce using rule 45 (assignment)


State 79

   46 assignment: DIV_ASSIGN .

    $default  reduce using rule 46 (assignment)


State 80

   47 assignment: EXP_ASSIGN .

    $default  reduce using rule 47 (assignment)


State 81

   48 assignment: REM_ASSIGN .

    $default  reduce using rule 48 (assignment)


State 82

   49 assignment: BITWISE_AND_ASSIGN .

    $default  reduce using rule 49 (assignment)


State 83

   50 assignment: BITWISE_OR_ASSIGN .

    $default  reduce using rule 50 (assignment)


State 84

   51 assignment: BITWISE_XOR_ASSIGN .

    $default  reduce using rule 51 (assignment)


State 85

   40 assignment: LOGICAL_NULL_ASSIGN .

    $default  reduce using rule 40 (assignment)


State 86

   41 assignment: LOGICAL_AND_ASSIGN .

    $default  reduce using rule 41 (assignment)


State 87

   42 assignment: LOGICAL_OR_ASSIGN .

    $default  reduce using rule 42 (assignment)


State 88

   70 logic-expr: ID LT . expr
  184 var-obj: ID LT . var-type GT LPAR args-list RPAR

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    VOID_RW      shift, and go to state 154
    ANY          shift, and go to state 155
    BOOLTYPE     shift, and go to state 156
    NEVER        shift, and go to state 157
    NUMBER       shift, and go to state 158
    STRING       shift, and go to state 159
    UNDEFINED    shift, and go to state 28
    UNKNOWN      shift, and go to state 160

    logic-expr       go to state 37
    var-type         go to state 161
    expr             go to state 162
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 89

   52 assignment: LSHIFT_ASSIGN .

    $default  reduce using rule 52 (assignment)


State 90

   53 assignment: RSHIFT_ASSIGN .

    $default  reduce using rule 53 (assignment)


State 91

   54 assignment: RSHIFT_UNSIGNED_ASSIGN .

    $default  reduce using rule 54 (assignment)


State 92

  176 var-met: ID LPAR . args-list RPAR
  183 var-obj: ID LPAR . args-list RPAR

    COMMA        shift, and go to state 163
    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 182 (args-list)

    assign-expr      go to state 164
    logic-expr       go to state 37
    expr             go to state 165
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    args-list        go to state 166
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 93

  146 vet-idx: ID LBRACKET . idx-safe-expr RBRACKET

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 37
    expr             go to state 167
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 168
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 94

   19 assign-expr: ID assignment . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 37
    expr             go to state 169
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 95

   16 stmt: BREAK SEMI .

    $default  reduce using rule 16 (stmt)


State 96

   77 class-def: CLASS ID . LBRACE class-att-list RBRACE

    LBRACE  shift, and go to state 170


State 97

  114 var-declr: CONST_RW ID . COLON var-type ASSIGN expr
  115          | CONST_RW ID . COLON var-type LBRACKET RBRACKET ASSIGN expr
  117 id-list: ID . COMMA id-list
  118        | ID .

    COMMA  shift, and go to state 171
    COLON  shift, and go to state 172

    $default  reduce using rule 118 (id-list)


State 98

  113 var-declr: CONST_RW id-list . ASSIGN expr
  116          | CONST_RW id-list . ASSIGN obj-def

    ASSIGN  shift, and go to state 173


State 99

   17 stmt: CONTINUE SEMI .

    $default  reduce using rule 17 (stmt)


State 100

   55 do-while-stmt: DO LBRACE . line RBRACE WHILE LPAR expr RPAR
   56              | DO LBRACE . line RBRACE WHILE LPAR assign-expr RPAR

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 2 (line)

    line             go to state 174
    stmt-list        go to state 30
    stmt             go to state 31
    assign-expr      go to state 32
    for-stmt         go to state 33
    do-while-stmt    go to state 34
    while-stmt       go to state 35
    if-stmt          go to state 36
    logic-expr       go to state 37
    class-def        go to state 38
    func-def         go to state 39
    var-declr        go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 101

   21 for-stmt: FOR LPAR . assign-expr SEMI expr SEMI expr RPAR LBRACE line RBRACE
   22         | FOR LPAR . assign-expr SEMI expr SEMI assign-expr RPAR LBRACE line RBRACE
   23         | FOR LPAR . assign-expr SEMI expr SEMI RPAR LBRACE line RBRACE
   24         | FOR LPAR . assign-expr SEMI SEMI expr RPAR LBRACE line RBRACE
   25         | FOR LPAR . assign-expr SEMI SEMI assign-expr RPAR LBRACE line RBRACE
   26         | FOR LPAR . assign-expr SEMI SEMI RPAR LBRACE line RBRACE
   27         | FOR LPAR . var-declr SEMI expr SEMI expr RPAR LBRACE line RBRACE
   28         | FOR LPAR . var-declr SEMI expr SEMI assign-expr RPAR LBRACE line RBRACE
   29         | FOR LPAR . var-declr SEMI expr SEMI RPAR LBRACE line RBRACE
   30         | FOR LPAR . var-declr SEMI SEMI expr RPAR LBRACE line RBRACE
   31         | FOR LPAR . var-declr SEMI SEMI assign-expr RPAR LBRACE line RBRACE
   32         | FOR LPAR . var-declr SEMI SEMI RPAR LBRACE line RBRACE
   33         | FOR LPAR . SEMI expr SEMI expr RPAR LBRACE line RBRACE
   34         | FOR LPAR . SEMI expr SEMI assign-expr RPAR LBRACE line RBRACE
   35         | FOR LPAR . SEMI expr SEMI RPAR LBRACE line RBRACE
   36         | FOR LPAR . SEMI SEMI expr RPAR LBRACE line RBRACE
   37         | FOR LPAR . SEMI SEMI assign-expr RPAR LBRACE line RBRACE
   38         | FOR LPAR . SEMI SEMI RPAR LBRACE line RBRACE

    SEMI      shift, and go to state 175
    ID        shift, and go to state 176
    CONST_RW  shift, and go to state 14
    LET       shift, and go to state 21
    VAR       shift, and go to state 26

    assign-expr  go to state 177
    var-declr    go to state 178
    vet-idx      go to state 179
    var-att      go to state 180
    var-met      go to state 50


State 102

   89 func-def: FUNCTION ID . LPAR params RPAR LBRACE line RBRACE
   90         | FUNCTION ID . LPAR params RPAR COLON var-type LBRACE line RBRACE

    LPAR  shift, and go to state 181


State 103

   59 if-stmt: IF LPAR . expr RPAR LBRACE line RBRACE
   60        | IF LPAR . expr RPAR LBRACE line RBRACE ELSE LBRACE line RBRACE
   61        | IF LPAR . expr RPAR LBRACE line RBRACE ELSE stmt
   62        | IF LPAR . assign-expr RPAR LBRACE line RBRACE
   63        | IF LPAR . assign-expr RPAR LBRACE line RBRACE ELSE LBRACE line RBRACE
   64        | IF LPAR . assign-expr RPAR LBRACE line RBRACE ELSE stmt

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    assign-expr      go to state 182
    logic-expr       go to state 37
    expr             go to state 183
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 104

  102 var-declr: LET ID . COLON var-type
  103          | LET ID . COLON var-type ASSIGN expr
  104          | LET ID . COLON var-type LBRACKET RBRACKET
  105          | LET ID . COLON var-type LBRACKET RBRACKET ASSIGN expr
  117 id-list: ID . COMMA id-list
  118        | ID .

    COMMA  shift, and go to state 171
    COLON  shift, and go to state 184

    $default  reduce using rule 118 (id-list)


State 105

   99 var-declr: LET id-list .
  100          | LET id-list . ASSIGN expr
  101          | LET id-list . ASSIGN obj-def

    ASSIGN  shift, and go to state 185

    $default  reduce using rule 99 (var-declr)


State 106

  185 var-obj: NEW ID . LPAR args-list RPAR
  186        | NEW ID . LT var-type GT LPAR args-list RPAR

    LT    shift, and go to state 186
    LPAR  shift, and go to state 187


State 107

   14 stmt: RETURN SEMI .

    $default  reduce using rule 14 (stmt)


State 108

   15 stmt: RETURN expr . SEMI
   65 logic-expr: expr . EQ expr
   66           | expr . EQ_STRICT expr
   67           | expr . INEQ expr
   68           | expr . INEQ_STRICT expr
   69           | expr . LT expr
   71           | expr . LT_EQ expr
   72           | expr . GT expr
   73           | expr . GT_EQ expr
   74           | expr . LOGICAL_NULL expr
   75           | expr . LOGICAL_AND expr
   76           | expr . LOGICAL_OR expr
  157 arit-expr: expr . PLUS expr
  158          | expr . SUB expr
  159          | expr . MULT expr
  160          | expr . DIV expr
  161          | expr . EXP expr
  162          | expr . REM expr
  163 bitw-expr: expr . BITWISE_AND expr
  164          | expr . BITWISE_OR expr
  165          | expr . BITWISE_XOR expr
  166 shift-expr: expr . LSHIFT expr
  167           | expr . RSHIFT expr
  168           | expr . RSHIFT_UNSIGNED expr

    SEMI             shift, and go to state 188
    PLUS             shift, and go to state 117
    SUB              shift, and go to state 118
    MULT             shift, and go to state 119
    DIV              shift, and go to state 120
    EXP              shift, and go to state 121
    REM              shift, and go to state 122
    BITWISE_AND      shift, and go to state 123
    BITWISE_OR       shift, and go to state 124
    BITWISE_XOR      shift, and go to state 125
    LOGICAL_NULL     shift, and go to state 126
    LOGICAL_AND      shift, and go to state 127
    LOGICAL_OR       shift, and go to state 128
    EQ               shift, and go to state 129
    EQ_STRICT        shift, and go to state 130
    INEQ             shift, and go to state 131
    INEQ_STRICT      shift, and go to state 132
    LT               shift, and go to state 133
    LT_EQ            shift, and go to state 134
    GT               shift, and go to state 135
    GT_EQ            shift, and go to state 136
    LSHIFT           shift, and go to state 137
    RSHIFT           shift, and go to state 138
    RSHIFT_UNSIGNED  shift, and go to state 139


State 109

  109 var-declr: VAR ID . COLON var-type
  110          | VAR ID . COLON var-type ASSIGN expr
  111          | VAR ID . COLON var-type LBRACKET RBRACKET
  112          | VAR ID . COLON var-type LBRACKET RBRACKET ASSIGN expr
  117 id-list: ID . COMMA id-list
  118        | ID .

    COMMA  shift, and go to state 171
    COLON  shift, and go to state 189

    $default  reduce using rule 118 (id-list)


State 110

  106 var-declr: VAR id-list .
  107          | VAR id-list . ASSIGN expr
  108          | VAR id-list . ASSIGN obj-def

    ASSIGN  shift, and go to state 190

    $default  reduce using rule 106 (var-declr)


State 111

   57 while-stmt: WHILE LPAR . expr RPAR LBRACE line RBRACE
   58           | WHILE LPAR . assign-expr RPAR LBRACE line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    assign-expr      go to state 191
    logic-expr       go to state 37
    expr             go to state 192
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 112

    0 $accept: line $end .

    $default  accept


State 113

    3 stmt-list: stmt-list stmt .

    $default  reduce using rule 3 (stmt-list)


State 114

    9 stmt: assign-expr SEMI .

    $default  reduce using rule 9 (stmt)


State 115

    5 stmt: var-declr SEMI .

    $default  reduce using rule 5 (stmt)


State 116

    8 stmt: expr SEMI .

    $default  reduce using rule 8 (stmt)


State 117

  157 arit-expr: expr PLUS . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 37
    expr             go to state 193
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 118

  158 arit-expr: expr SUB . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 37
    expr             go to state 194
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 119

  159 arit-expr: expr MULT . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 37
    expr             go to state 195
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 120

  160 arit-expr: expr DIV . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 37
    expr             go to state 196
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 121

  161 arit-expr: expr EXP . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 37
    expr             go to state 197
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 122

  162 arit-expr: expr REM . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 37
    expr             go to state 198
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 123

  163 bitw-expr: expr BITWISE_AND . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 37
    expr             go to state 199
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 124

  164 bitw-expr: expr BITWISE_OR . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 37
    expr             go to state 200
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 125

  165 bitw-expr: expr BITWISE_XOR . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 37
    expr             go to state 201
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 126

   74 logic-expr: expr LOGICAL_NULL . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 37
    expr             go to state 202
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 127

   75 logic-expr: expr LOGICAL_AND . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 37
    expr             go to state 203
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 128

   76 logic-expr: expr LOGICAL_OR . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 37
    expr             go to state 204
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 129

   65 logic-expr: expr EQ . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 37
    expr             go to state 205
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 130

   66 logic-expr: expr EQ_STRICT . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 37
    expr             go to state 206
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 131

   67 logic-expr: expr INEQ . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 37
    expr             go to state 207
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 132

   68 logic-expr: expr INEQ_STRICT . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 37
    expr             go to state 208
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 133

   69 logic-expr: expr LT . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 37
    expr             go to state 209
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 134

   71 logic-expr: expr LT_EQ . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 37
    expr             go to state 210
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 135

   72 logic-expr: expr GT . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 37
    expr             go to state 211
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 136

   73 logic-expr: expr GT_EQ . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 37
    expr             go to state 212
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 137

  166 shift-expr: expr LSHIFT . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 37
    expr             go to state 213
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 138

  167 shift-expr: expr RSHIFT . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 37
    expr             go to state 214
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 139

  168 shift-expr: expr RSHIFT_UNSIGNED . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 37
    expr             go to state 215
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 140

   20 assign-expr: vet-idx assignment . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 37
    expr             go to state 216
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 141

  170 var-att: var-att DOT . ID
  174        | var-att DOT . var-met

    ID  shift, and go to state 217

    var-met  go to state 218


State 142

  152 unary-expr: var-att INCREMENT .

    $default  reduce using rule 152 (unary-expr)


State 143

  154 unary-expr: var-att DECREMENT .

    $default  reduce using rule 154 (unary-expr)


State 144

   18 assign-expr: var-att assignment . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 37
    expr             go to state 219
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 145

  172 var-att: var-met DOT . ID
  173        | var-met DOT . var-att

    ID  shift, and go to state 220

    var-att  go to state 221
    var-met  go to state 50


State 146

  176 var-met: ID LPAR . args-list RPAR

    COMMA        shift, and go to state 163
    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 182 (args-list)

    assign-expr      go to state 164
    logic-expr       go to state 37
    expr             go to state 165
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    args-list        go to state 222
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 147

  134 expr: LPAR expr RPAR .

    $default  reduce using rule 134 (expr)


State 148

  200 elmts-list: COMMA elmts-list .

    $default  reduce using rule 200 (elmts-list)


State 149

  201 elmts-list: var-val COMMA . elmts-list

    COMMA      shift, and go to state 69
    SUB        shift, and go to state 2
    INT_VAL    shift, and go to state 8
    REAL_VAL   shift, and go to state 9
    STR_VAL    shift, and go to state 10
    FALSE_RW   shift, and go to state 17
    NULL_RW    shift, and go to state 23
    TRUE_RW    shift, and go to state 25
    UNDEFINED  shift, and go to state 28

    $default  reduce using rule 203 (elmts-list)

    var-val     go to state 70
    elmts-list  go to state 223


State 150

  199 array-expr: LBRACKET elmts-list RBRACKET .

    $default  reduce using rule 199 (array-expr)


State 151

  169 var-att: ID . DOT var-att
  171        | ID . DOT var-met
  175        | ID . DOT ID
  175        | ID DOT ID .
  176 var-met: ID . LPAR args-list RPAR

    DOT   shift, and go to state 73
    LPAR  shift, and go to state 146

    $default  reduce using rule 175 (var-att)


State 152

  169 var-att: ID DOT var-att .
  170        | var-att . DOT ID
  174        | var-att . DOT var-met

    DOT  shift, and go to state 141

    $default  reduce using rule 169 (var-att)


State 153

  171 var-att: ID DOT var-met .
  172        | var-met . DOT ID
  173        | var-met . DOT var-att

    DOT  shift, and go to state 145

    $default  reduce using rule 171 (var-att)


State 154

  130 var-type: VOID_RW .

    $default  reduce using rule 130 (var-type)


State 155

  129 var-type: ANY .

    $default  reduce using rule 129 (var-type)


State 156

  128 var-type: BOOLTYPE .

    $default  reduce using rule 128 (var-type)


State 157

  131 var-type: NEVER .

    $default  reduce using rule 131 (var-type)


State 158

  125 var-type: NUMBER .

    $default  reduce using rule 125 (var-type)


State 159

  126 var-type: STRING .

    $default  reduce using rule 126 (var-type)


State 160

  127 var-type: UNKNOWN .

    $default  reduce using rule 127 (var-type)


State 161

  184 var-obj: ID LT var-type . GT LPAR args-list RPAR

    GT  shift, and go to state 224


State 162

   65 logic-expr: expr . EQ expr
   66           | expr . EQ_STRICT expr
   67           | expr . INEQ expr
   68           | expr . INEQ_STRICT expr
   69           | expr . LT expr
   70           | ID LT expr .
   71           | expr . LT_EQ expr
   72           | expr . GT expr
   73           | expr . GT_EQ expr
   74           | expr . LOGICAL_NULL expr
   75           | expr . LOGICAL_AND expr
   76           | expr . LOGICAL_OR expr
  157 arit-expr: expr . PLUS expr
  158          | expr . SUB expr
  159          | expr . MULT expr
  160          | expr . DIV expr
  161          | expr . EXP expr
  162          | expr . REM expr
  163 bitw-expr: expr . BITWISE_AND expr
  164          | expr . BITWISE_OR expr
  165          | expr . BITWISE_XOR expr
  166 shift-expr: expr . LSHIFT expr
  167           | expr . RSHIFT expr
  168           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 117
    SUB              shift, and go to state 118
    MULT             shift, and go to state 119
    DIV              shift, and go to state 120
    EXP              shift, and go to state 121
    REM              shift, and go to state 122
    BITWISE_AND      shift, and go to state 123
    BITWISE_OR       shift, and go to state 124
    BITWISE_XOR      shift, and go to state 125
    LSHIFT           shift, and go to state 137
    RSHIFT           shift, and go to state 138
    RSHIFT_UNSIGNED  shift, and go to state 139

    $default  reduce using rule 70 (logic-expr)


State 163

  177 args-list: COMMA . args-list

    COMMA        shift, and go to state 163
    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 182 (args-list)

    assign-expr      go to state 164
    logic-expr       go to state 37
    expr             go to state 165
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    args-list        go to state 225
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 164

  179 args-list: assign-expr . COMMA args-list
  181          | assign-expr .

    COMMA  shift, and go to state 226

    $default  reduce using rule 181 (args-list)


State 165

   65 logic-expr: expr . EQ expr
   66           | expr . EQ_STRICT expr
   67           | expr . INEQ expr
   68           | expr . INEQ_STRICT expr
   69           | expr . LT expr
   71           | expr . LT_EQ expr
   72           | expr . GT expr
   73           | expr . GT_EQ expr
   74           | expr . LOGICAL_NULL expr
   75           | expr . LOGICAL_AND expr
   76           | expr . LOGICAL_OR expr
  157 arit-expr: expr . PLUS expr
  158          | expr . SUB expr
  159          | expr . MULT expr
  160          | expr . DIV expr
  161          | expr . EXP expr
  162          | expr . REM expr
  163 bitw-expr: expr . BITWISE_AND expr
  164          | expr . BITWISE_OR expr
  165          | expr . BITWISE_XOR expr
  166 shift-expr: expr . LSHIFT expr
  167           | expr . RSHIFT expr
  168           | expr . RSHIFT_UNSIGNED expr
  178 args-list: expr . COMMA args-list
  180          | expr .

    COMMA            shift, and go to state 227
    PLUS             shift, and go to state 117
    SUB              shift, and go to state 118
    MULT             shift, and go to state 119
    DIV              shift, and go to state 120
    EXP              shift, and go to state 121
    REM              shift, and go to state 122
    BITWISE_AND      shift, and go to state 123
    BITWISE_OR       shift, and go to state 124
    BITWISE_XOR      shift, and go to state 125
    LOGICAL_NULL     shift, and go to state 126
    LOGICAL_AND      shift, and go to state 127
    LOGICAL_OR       shift, and go to state 128
    EQ               shift, and go to state 129
    EQ_STRICT        shift, and go to state 130
    INEQ             shift, and go to state 131
    INEQ_STRICT      shift, and go to state 132
    LT               shift, and go to state 133
    LT_EQ            shift, and go to state 134
    GT               shift, and go to state 135
    GT_EQ            shift, and go to state 136
    LSHIFT           shift, and go to state 137
    RSHIFT           shift, and go to state 138
    RSHIFT_UNSIGNED  shift, and go to state 139

    $default  reduce using rule 180 (args-list)


State 166

  176 var-met: ID LPAR args-list . RPAR
  183 var-obj: ID LPAR args-list . RPAR

    RPAR  shift, and go to state 228


State 167

   65 logic-expr: expr . EQ expr
   66           | expr . EQ_STRICT expr
   67           | expr . INEQ expr
   68           | expr . INEQ_STRICT expr
   69           | expr . LT expr
   71           | expr . LT_EQ expr
   72           | expr . GT expr
   73           | expr . GT_EQ expr
   74           | expr . LOGICAL_NULL expr
   75           | expr . LOGICAL_AND expr
   76           | expr . LOGICAL_OR expr
  157 arit-expr: expr . PLUS expr
  158          | expr . SUB expr
  159          | expr . MULT expr
  160          | expr . DIV expr
  161          | expr . EXP expr
  162          | expr . REM expr
  163 bitw-expr: expr . BITWISE_AND expr
  164          | expr . BITWISE_OR expr
  165          | expr . BITWISE_XOR expr
  166 shift-expr: expr . LSHIFT expr
  167           | expr . RSHIFT expr
  168           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 117
    SUB              shift, and go to state 118
    MULT             shift, and go to state 119
    DIV              shift, and go to state 120
    EXP              shift, and go to state 121
    REM              shift, and go to state 122
    BITWISE_AND      shift, and go to state 123
    BITWISE_OR       shift, and go to state 124
    BITWISE_XOR      shift, and go to state 125
    LOGICAL_NULL     shift, and go to state 126
    LOGICAL_AND      shift, and go to state 127
    LOGICAL_OR       shift, and go to state 128
    EQ               shift, and go to state 129
    EQ_STRICT        shift, and go to state 130
    INEQ             shift, and go to state 131
    INEQ_STRICT      shift, and go to state 132
    LT               shift, and go to state 133
    LT_EQ            shift, and go to state 134
    GT               shift, and go to state 135
    GT_EQ            shift, and go to state 136
    LSHIFT           shift, and go to state 137
    RSHIFT           shift, and go to state 138
    RSHIFT_UNSIGNED  shift, and go to state 139


State 168

  132 expr: idx-safe-expr .
  146 vet-idx: ID LBRACKET idx-safe-expr . RBRACKET

    RBRACKET  shift, and go to state 229

    $default  reduce using rule 132 (expr)


State 169

   19 assign-expr: ID assignment expr .
   65 logic-expr: expr . EQ expr
   66           | expr . EQ_STRICT expr
   67           | expr . INEQ expr
   68           | expr . INEQ_STRICT expr
   69           | expr . LT expr
   71           | expr . LT_EQ expr
   72           | expr . GT expr
   73           | expr . GT_EQ expr
   74           | expr . LOGICAL_NULL expr
   75           | expr . LOGICAL_AND expr
   76           | expr . LOGICAL_OR expr
  157 arit-expr: expr . PLUS expr
  158          | expr . SUB expr
  159          | expr . MULT expr
  160          | expr . DIV expr
  161          | expr . EXP expr
  162          | expr . REM expr
  163 bitw-expr: expr . BITWISE_AND expr
  164          | expr . BITWISE_OR expr
  165          | expr . BITWISE_XOR expr
  166 shift-expr: expr . LSHIFT expr
  167           | expr . RSHIFT expr
  168           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 117
    SUB              shift, and go to state 118
    MULT             shift, and go to state 119
    DIV              shift, and go to state 120
    EXP              shift, and go to state 121
    REM              shift, and go to state 122
    BITWISE_AND      shift, and go to state 123
    BITWISE_OR       shift, and go to state 124
    BITWISE_XOR      shift, and go to state 125
    LOGICAL_NULL     shift, and go to state 126
    LOGICAL_AND      shift, and go to state 127
    LOGICAL_OR       shift, and go to state 128
    EQ               shift, and go to state 129
    EQ_STRICT        shift, and go to state 130
    INEQ             shift, and go to state 131
    INEQ_STRICT      shift, and go to state 132
    LT               shift, and go to state 133
    LT_EQ            shift, and go to state 134
    GT               shift, and go to state 135
    GT_EQ            shift, and go to state 136
    LSHIFT           shift, and go to state 137
    RSHIFT           shift, and go to state 138
    RSHIFT_UNSIGNED  shift, and go to state 139

    $default  reduce using rule 19 (assign-expr)


State 170

   77 class-def: CLASS ID LBRACE . class-att-list RBRACE

    SEMI       shift, and go to state 230
    ID         shift, and go to state 231
    PRIVATE    shift, and go to state 232
    PROTECTED  shift, and go to state 233
    PUBLIC     shift, and go to state 234

    $default  reduce using rule 81 (class-att-list)

    class-att-list  go to state 235
    class-att       go to state 236
    access-modif    go to state 237


State 171

  117 id-list: ID COMMA . id-list

    ID  shift, and go to state 238

    id-list  go to state 239


State 172

  114 var-declr: CONST_RW ID COLON . var-type ASSIGN expr
  115          | CONST_RW ID COLON . var-type LBRACKET RBRACKET ASSIGN expr

    VOID_RW   shift, and go to state 154
    ANY       shift, and go to state 155
    BOOLTYPE  shift, and go to state 156
    NEVER     shift, and go to state 157
    NUMBER    shift, and go to state 158
    STRING    shift, and go to state 159
    UNKNOWN   shift, and go to state 160

    var-type  go to state 240


State 173

  113 var-declr: CONST_RW id-list ASSIGN . expr
  116          | CONST_RW id-list ASSIGN . obj-def

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACE       shift, and go to state 241
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 37
    obj-def          go to state 242
    expr             go to state 243
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 174

   55 do-while-stmt: DO LBRACE line . RBRACE WHILE LPAR expr RPAR
   56              | DO LBRACE line . RBRACE WHILE LPAR assign-expr RPAR

    RBRACE  shift, and go to state 244


State 175

   33 for-stmt: FOR LPAR SEMI . expr SEMI expr RPAR LBRACE line RBRACE
   34         | FOR LPAR SEMI . expr SEMI assign-expr RPAR LBRACE line RBRACE
   35         | FOR LPAR SEMI . expr SEMI RPAR LBRACE line RBRACE
   36         | FOR LPAR SEMI . SEMI expr RPAR LBRACE line RBRACE
   37         | FOR LPAR SEMI . SEMI assign-expr RPAR LBRACE line RBRACE
   38         | FOR LPAR SEMI . SEMI RPAR LBRACE line RBRACE

    SEMI         shift, and go to state 245
    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 37
    expr             go to state 246
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 176

   19 assign-expr: ID . assignment expr
  146 vet-idx: ID . LBRACKET idx-safe-expr RBRACKET
  169 var-att: ID . DOT var-att
  171        | ID . DOT var-met
  175        | ID . DOT ID
  176 var-met: ID . LPAR args-list RPAR

    ASSIGN                  shift, and go to state 72
    DOT                     shift, and go to state 73
    PLUS_ASSIGN             shift, and go to state 75
    SUB_ASSIGN              shift, and go to state 77
    MULT_ASSIGN             shift, and go to state 78
    DIV_ASSIGN              shift, and go to state 79
    EXP_ASSIGN              shift, and go to state 80
    REM_ASSIGN              shift, and go to state 81
    BITWISE_AND_ASSIGN      shift, and go to state 82
    BITWISE_OR_ASSIGN       shift, and go to state 83
    BITWISE_XOR_ASSIGN      shift, and go to state 84
    LOGICAL_NULL_ASSIGN     shift, and go to state 85
    LOGICAL_AND_ASSIGN      shift, and go to state 86
    LOGICAL_OR_ASSIGN       shift, and go to state 87
    LSHIFT_ASSIGN           shift, and go to state 89
    RSHIFT_ASSIGN           shift, and go to state 90
    RSHIFT_UNSIGNED_ASSIGN  shift, and go to state 91
    LPAR                    shift, and go to state 146
    LBRACKET                shift, and go to state 93

    assignment  go to state 94


State 177

   21 for-stmt: FOR LPAR assign-expr . SEMI expr SEMI expr RPAR LBRACE line RBRACE
   22         | FOR LPAR assign-expr . SEMI expr SEMI assign-expr RPAR LBRACE line RBRACE
   23         | FOR LPAR assign-expr . SEMI expr SEMI RPAR LBRACE line RBRACE
   24         | FOR LPAR assign-expr . SEMI SEMI expr RPAR LBRACE line RBRACE
   25         | FOR LPAR assign-expr . SEMI SEMI assign-expr RPAR LBRACE line RBRACE
   26         | FOR LPAR assign-expr . SEMI SEMI RPAR LBRACE line RBRACE

    SEMI  shift, and go to state 247


State 178

   27 for-stmt: FOR LPAR var-declr . SEMI expr SEMI expr RPAR LBRACE line RBRACE
   28         | FOR LPAR var-declr . SEMI expr SEMI assign-expr RPAR LBRACE line RBRACE
   29         | FOR LPAR var-declr . SEMI expr SEMI RPAR LBRACE line RBRACE
   30         | FOR LPAR var-declr . SEMI SEMI expr RPAR LBRACE line RBRACE
   31         | FOR LPAR var-declr . SEMI SEMI assign-expr RPAR LBRACE line RBRACE
   32         | FOR LPAR var-declr . SEMI SEMI RPAR LBRACE line RBRACE

    SEMI  shift, and go to state 248


State 179

   20 assign-expr: vet-idx . assignment expr

    ASSIGN                  shift, and go to state 72
    PLUS_ASSIGN             shift, and go to state 75
    SUB_ASSIGN              shift, and go to state 77
    MULT_ASSIGN             shift, and go to state 78
    DIV_ASSIGN              shift, and go to state 79
    EXP_ASSIGN              shift, and go to state 80
    REM_ASSIGN              shift, and go to state 81
    BITWISE_AND_ASSIGN      shift, and go to state 82
    BITWISE_OR_ASSIGN       shift, and go to state 83
    BITWISE_XOR_ASSIGN      shift, and go to state 84
    LOGICAL_NULL_ASSIGN     shift, and go to state 85
    LOGICAL_AND_ASSIGN      shift, and go to state 86
    LOGICAL_OR_ASSIGN       shift, and go to state 87
    LSHIFT_ASSIGN           shift, and go to state 89
    RSHIFT_ASSIGN           shift, and go to state 90
    RSHIFT_UNSIGNED_ASSIGN  shift, and go to state 91

    assignment  go to state 140


State 180

   18 assign-expr: var-att . assignment expr
  170 var-att: var-att . DOT ID
  174        | var-att . DOT var-met

    ASSIGN                  shift, and go to state 72
    DOT                     shift, and go to state 141
    PLUS_ASSIGN             shift, and go to state 75
    SUB_ASSIGN              shift, and go to state 77
    MULT_ASSIGN             shift, and go to state 78
    DIV_ASSIGN              shift, and go to state 79
    EXP_ASSIGN              shift, and go to state 80
    REM_ASSIGN              shift, and go to state 81
    BITWISE_AND_ASSIGN      shift, and go to state 82
    BITWISE_OR_ASSIGN       shift, and go to state 83
    BITWISE_XOR_ASSIGN      shift, and go to state 84
    LOGICAL_NULL_ASSIGN     shift, and go to state 85
    LOGICAL_AND_ASSIGN      shift, and go to state 86
    LOGICAL_OR_ASSIGN       shift, and go to state 87
    LSHIFT_ASSIGN           shift, and go to state 89
    RSHIFT_ASSIGN           shift, and go to state 90
    RSHIFT_UNSIGNED_ASSIGN  shift, and go to state 91

    assignment  go to state 144


State 181

   89 func-def: FUNCTION ID LPAR . params RPAR LBRACE line RBRACE
   90         | FUNCTION ID LPAR . params RPAR COLON var-type LBRACE line RBRACE

    COMMA  shift, and go to state 249
    ID     shift, and go to state 250

    $default  reduce using rule 98 (params)

    params  go to state 251


State 182

   62 if-stmt: IF LPAR assign-expr . RPAR LBRACE line RBRACE
   63        | IF LPAR assign-expr . RPAR LBRACE line RBRACE ELSE LBRACE line RBRACE
   64        | IF LPAR assign-expr . RPAR LBRACE line RBRACE ELSE stmt

    RPAR  shift, and go to state 252


State 183

   59 if-stmt: IF LPAR expr . RPAR LBRACE line RBRACE
   60        | IF LPAR expr . RPAR LBRACE line RBRACE ELSE LBRACE line RBRACE
   61        | IF LPAR expr . RPAR LBRACE line RBRACE ELSE stmt
   65 logic-expr: expr . EQ expr
   66           | expr . EQ_STRICT expr
   67           | expr . INEQ expr
   68           | expr . INEQ_STRICT expr
   69           | expr . LT expr
   71           | expr . LT_EQ expr
   72           | expr . GT expr
   73           | expr . GT_EQ expr
   74           | expr . LOGICAL_NULL expr
   75           | expr . LOGICAL_AND expr
   76           | expr . LOGICAL_OR expr
  157 arit-expr: expr . PLUS expr
  158          | expr . SUB expr
  159          | expr . MULT expr
  160          | expr . DIV expr
  161          | expr . EXP expr
  162          | expr . REM expr
  163 bitw-expr: expr . BITWISE_AND expr
  164          | expr . BITWISE_OR expr
  165          | expr . BITWISE_XOR expr
  166 shift-expr: expr . LSHIFT expr
  167           | expr . RSHIFT expr
  168           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 117
    SUB              shift, and go to state 118
    MULT             shift, and go to state 119
    DIV              shift, and go to state 120
    EXP              shift, and go to state 121
    REM              shift, and go to state 122
    BITWISE_AND      shift, and go to state 123
    BITWISE_OR       shift, and go to state 124
    BITWISE_XOR      shift, and go to state 125
    LOGICAL_NULL     shift, and go to state 126
    LOGICAL_AND      shift, and go to state 127
    LOGICAL_OR       shift, and go to state 128
    EQ               shift, and go to state 129
    EQ_STRICT        shift, and go to state 130
    INEQ             shift, and go to state 131
    INEQ_STRICT      shift, and go to state 132
    LT               shift, and go to state 133
    LT_EQ            shift, and go to state 134
    GT               shift, and go to state 135
    GT_EQ            shift, and go to state 136
    LSHIFT           shift, and go to state 137
    RSHIFT           shift, and go to state 138
    RSHIFT_UNSIGNED  shift, and go to state 139
    RPAR             shift, and go to state 253


State 184

  102 var-declr: LET ID COLON . var-type
  103          | LET ID COLON . var-type ASSIGN expr
  104          | LET ID COLON . var-type LBRACKET RBRACKET
  105          | LET ID COLON . var-type LBRACKET RBRACKET ASSIGN expr

    VOID_RW   shift, and go to state 154
    ANY       shift, and go to state 155
    BOOLTYPE  shift, and go to state 156
    NEVER     shift, and go to state 157
    NUMBER    shift, and go to state 158
    STRING    shift, and go to state 159
    UNKNOWN   shift, and go to state 160

    var-type  go to state 254


State 185

  100 var-declr: LET id-list ASSIGN . expr
  101          | LET id-list ASSIGN . obj-def

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACE       shift, and go to state 241
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 37
    obj-def          go to state 255
    expr             go to state 256
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 186

  186 var-obj: NEW ID LT . var-type GT LPAR args-list RPAR

    VOID_RW   shift, and go to state 154
    ANY       shift, and go to state 155
    BOOLTYPE  shift, and go to state 156
    NEVER     shift, and go to state 157
    NUMBER    shift, and go to state 158
    STRING    shift, and go to state 159
    UNKNOWN   shift, and go to state 160

    var-type  go to state 257


State 187

  185 var-obj: NEW ID LPAR . args-list RPAR

    COMMA        shift, and go to state 163
    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 182 (args-list)

    assign-expr      go to state 164
    logic-expr       go to state 37
    expr             go to state 165
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    args-list        go to state 258
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 188

   15 stmt: RETURN expr SEMI .

    $default  reduce using rule 15 (stmt)


State 189

  109 var-declr: VAR ID COLON . var-type
  110          | VAR ID COLON . var-type ASSIGN expr
  111          | VAR ID COLON . var-type LBRACKET RBRACKET
  112          | VAR ID COLON . var-type LBRACKET RBRACKET ASSIGN expr

    VOID_RW   shift, and go to state 154
    ANY       shift, and go to state 155
    BOOLTYPE  shift, and go to state 156
    NEVER     shift, and go to state 157
    NUMBER    shift, and go to state 158
    STRING    shift, and go to state 159
    UNKNOWN   shift, and go to state 160

    var-type  go to state 259


State 190

  107 var-declr: VAR id-list ASSIGN . expr
  108          | VAR id-list ASSIGN . obj-def

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACE       shift, and go to state 241
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 37
    obj-def          go to state 260
    expr             go to state 261
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 191

   58 while-stmt: WHILE LPAR assign-expr . RPAR LBRACE line RBRACE

    RPAR  shift, and go to state 262


State 192

   57 while-stmt: WHILE LPAR expr . RPAR LBRACE line RBRACE
   65 logic-expr: expr . EQ expr
   66           | expr . EQ_STRICT expr
   67           | expr . INEQ expr
   68           | expr . INEQ_STRICT expr
   69           | expr . LT expr
   71           | expr . LT_EQ expr
   72           | expr . GT expr
   73           | expr . GT_EQ expr
   74           | expr . LOGICAL_NULL expr
   75           | expr . LOGICAL_AND expr
   76           | expr . LOGICAL_OR expr
  157 arit-expr: expr . PLUS expr
  158          | expr . SUB expr
  159          | expr . MULT expr
  160          | expr . DIV expr
  161          | expr . EXP expr
  162          | expr . REM expr
  163 bitw-expr: expr . BITWISE_AND expr
  164          | expr . BITWISE_OR expr
  165          | expr . BITWISE_XOR expr
  166 shift-expr: expr . LSHIFT expr
  167           | expr . RSHIFT expr
  168           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 117
    SUB              shift, and go to state 118
    MULT             shift, and go to state 119
    DIV              shift, and go to state 120
    EXP              shift, and go to state 121
    REM              shift, and go to state 122
    BITWISE_AND      shift, and go to state 123
    BITWISE_OR       shift, and go to state 124
    BITWISE_XOR      shift, and go to state 125
    LOGICAL_NULL     shift, and go to state 126
    LOGICAL_AND      shift, and go to state 127
    LOGICAL_OR       shift, and go to state 128
    EQ               shift, and go to state 129
    EQ_STRICT        shift, and go to state 130
    INEQ             shift, and go to state 131
    INEQ_STRICT      shift, and go to state 132
    LT               shift, and go to state 133
    LT_EQ            shift, and go to state 134
    GT               shift, and go to state 135
    GT_EQ            shift, and go to state 136
    LSHIFT           shift, and go to state 137
    RSHIFT           shift, and go to state 138
    RSHIFT_UNSIGNED  shift, and go to state 139
    RPAR             shift, and go to state 263


State 193

   65 logic-expr: expr . EQ expr
   66           | expr . EQ_STRICT expr
   67           | expr . INEQ expr
   68           | expr . INEQ_STRICT expr
   69           | expr . LT expr
   71           | expr . LT_EQ expr
   72           | expr . GT expr
   73           | expr . GT_EQ expr
   74           | expr . LOGICAL_NULL expr
   75           | expr . LOGICAL_AND expr
   76           | expr . LOGICAL_OR expr
  157 arit-expr: expr . PLUS expr
  157          | expr PLUS expr .
  158          | expr . SUB expr
  159          | expr . MULT expr
  160          | expr . DIV expr
  161          | expr . EXP expr
  162          | expr . REM expr
  163 bitw-expr: expr . BITWISE_AND expr
  164          | expr . BITWISE_OR expr
  165          | expr . BITWISE_XOR expr
  166 shift-expr: expr . LSHIFT expr
  167           | expr . RSHIFT expr
  168           | expr . RSHIFT_UNSIGNED expr

    MULT  shift, and go to state 119
    DIV   shift, and go to state 120
    EXP   shift, and go to state 121
    REM   shift, and go to state 122

    $default  reduce using rule 157 (arit-expr)


State 194

   65 logic-expr: expr . EQ expr
   66           | expr . EQ_STRICT expr
   67           | expr . INEQ expr
   68           | expr . INEQ_STRICT expr
   69           | expr . LT expr
   71           | expr . LT_EQ expr
   72           | expr . GT expr
   73           | expr . GT_EQ expr
   74           | expr . LOGICAL_NULL expr
   75           | expr . LOGICAL_AND expr
   76           | expr . LOGICAL_OR expr
  157 arit-expr: expr . PLUS expr
  158          | expr . SUB expr
  158          | expr SUB expr .
  159          | expr . MULT expr
  160          | expr . DIV expr
  161          | expr . EXP expr
  162          | expr . REM expr
  163 bitw-expr: expr . BITWISE_AND expr
  164          | expr . BITWISE_OR expr
  165          | expr . BITWISE_XOR expr
  166 shift-expr: expr . LSHIFT expr
  167           | expr . RSHIFT expr
  168           | expr . RSHIFT_UNSIGNED expr

    MULT  shift, and go to state 119
    DIV   shift, and go to state 120
    EXP   shift, and go to state 121
    REM   shift, and go to state 122

    $default  reduce using rule 158 (arit-expr)


State 195

   65 logic-expr: expr . EQ expr
   66           | expr . EQ_STRICT expr
   67           | expr . INEQ expr
   68           | expr . INEQ_STRICT expr
   69           | expr . LT expr
   71           | expr . LT_EQ expr
   72           | expr . GT expr
   73           | expr . GT_EQ expr
   74           | expr . LOGICAL_NULL expr
   75           | expr . LOGICAL_AND expr
   76           | expr . LOGICAL_OR expr
  157 arit-expr: expr . PLUS expr
  158          | expr . SUB expr
  159          | expr . MULT expr
  159          | expr MULT expr .
  160          | expr . DIV expr
  161          | expr . EXP expr
  162          | expr . REM expr
  163 bitw-expr: expr . BITWISE_AND expr
  164          | expr . BITWISE_OR expr
  165          | expr . BITWISE_XOR expr
  166 shift-expr: expr . LSHIFT expr
  167           | expr . RSHIFT expr
  168           | expr . RSHIFT_UNSIGNED expr

    EXP  shift, and go to state 121

    $default  reduce using rule 159 (arit-expr)


State 196

   65 logic-expr: expr . EQ expr
   66           | expr . EQ_STRICT expr
   67           | expr . INEQ expr
   68           | expr . INEQ_STRICT expr
   69           | expr . LT expr
   71           | expr . LT_EQ expr
   72           | expr . GT expr
   73           | expr . GT_EQ expr
   74           | expr . LOGICAL_NULL expr
   75           | expr . LOGICAL_AND expr
   76           | expr . LOGICAL_OR expr
  157 arit-expr: expr . PLUS expr
  158          | expr . SUB expr
  159          | expr . MULT expr
  160          | expr . DIV expr
  160          | expr DIV expr .
  161          | expr . EXP expr
  162          | expr . REM expr
  163 bitw-expr: expr . BITWISE_AND expr
  164          | expr . BITWISE_OR expr
  165          | expr . BITWISE_XOR expr
  166 shift-expr: expr . LSHIFT expr
  167           | expr . RSHIFT expr
  168           | expr . RSHIFT_UNSIGNED expr

    EXP  shift, and go to state 121

    $default  reduce using rule 160 (arit-expr)


State 197

   65 logic-expr: expr . EQ expr
   66           | expr . EQ_STRICT expr
   67           | expr . INEQ expr
   68           | expr . INEQ_STRICT expr
   69           | expr . LT expr
   71           | expr . LT_EQ expr
   72           | expr . GT expr
   73           | expr . GT_EQ expr
   74           | expr . LOGICAL_NULL expr
   75           | expr . LOGICAL_AND expr
   76           | expr . LOGICAL_OR expr
  157 arit-expr: expr . PLUS expr
  158          | expr . SUB expr
  159          | expr . MULT expr
  160          | expr . DIV expr
  161          | expr . EXP expr
  161          | expr EXP expr .
  162          | expr . REM expr
  163 bitw-expr: expr . BITWISE_AND expr
  164          | expr . BITWISE_OR expr
  165          | expr . BITWISE_XOR expr
  166 shift-expr: expr . LSHIFT expr
  167           | expr . RSHIFT expr
  168           | expr . RSHIFT_UNSIGNED expr

    EXP  shift, and go to state 121

    $default  reduce using rule 161 (arit-expr)


State 198

   65 logic-expr: expr . EQ expr
   66           | expr . EQ_STRICT expr
   67           | expr . INEQ expr
   68           | expr . INEQ_STRICT expr
   69           | expr . LT expr
   71           | expr . LT_EQ expr
   72           | expr . GT expr
   73           | expr . GT_EQ expr
   74           | expr . LOGICAL_NULL expr
   75           | expr . LOGICAL_AND expr
   76           | expr . LOGICAL_OR expr
  157 arit-expr: expr . PLUS expr
  158          | expr . SUB expr
  159          | expr . MULT expr
  160          | expr . DIV expr
  161          | expr . EXP expr
  162          | expr . REM expr
  162          | expr REM expr .
  163 bitw-expr: expr . BITWISE_AND expr
  164          | expr . BITWISE_OR expr
  165          | expr . BITWISE_XOR expr
  166 shift-expr: expr . LSHIFT expr
  167           | expr . RSHIFT expr
  168           | expr . RSHIFT_UNSIGNED expr

    EXP  shift, and go to state 121

    $default  reduce using rule 162 (arit-expr)


State 199

   65 logic-expr: expr . EQ expr
   66           | expr . EQ_STRICT expr
   67           | expr . INEQ expr
   68           | expr . INEQ_STRICT expr
   69           | expr . LT expr
   71           | expr . LT_EQ expr
   72           | expr . GT expr
   73           | expr . GT_EQ expr
   74           | expr . LOGICAL_NULL expr
   75           | expr . LOGICAL_AND expr
   76           | expr . LOGICAL_OR expr
  157 arit-expr: expr . PLUS expr
  158          | expr . SUB expr
  159          | expr . MULT expr
  160          | expr . DIV expr
  161          | expr . EXP expr
  162          | expr . REM expr
  163 bitw-expr: expr . BITWISE_AND expr
  163          | expr BITWISE_AND expr .
  164          | expr . BITWISE_OR expr
  165          | expr . BITWISE_XOR expr
  166 shift-expr: expr . LSHIFT expr
  167           | expr . RSHIFT expr
  168           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 117
    SUB              shift, and go to state 118
    MULT             shift, and go to state 119
    DIV              shift, and go to state 120
    EXP              shift, and go to state 121
    REM              shift, and go to state 122
    LSHIFT           shift, and go to state 137
    RSHIFT           shift, and go to state 138
    RSHIFT_UNSIGNED  shift, and go to state 139

    $default  reduce using rule 163 (bitw-expr)


State 200

   65 logic-expr: expr . EQ expr
   66           | expr . EQ_STRICT expr
   67           | expr . INEQ expr
   68           | expr . INEQ_STRICT expr
   69           | expr . LT expr
   71           | expr . LT_EQ expr
   72           | expr . GT expr
   73           | expr . GT_EQ expr
   74           | expr . LOGICAL_NULL expr
   75           | expr . LOGICAL_AND expr
   76           | expr . LOGICAL_OR expr
  157 arit-expr: expr . PLUS expr
  158          | expr . SUB expr
  159          | expr . MULT expr
  160          | expr . DIV expr
  161          | expr . EXP expr
  162          | expr . REM expr
  163 bitw-expr: expr . BITWISE_AND expr
  164          | expr . BITWISE_OR expr
  164          | expr BITWISE_OR expr .
  165          | expr . BITWISE_XOR expr
  166 shift-expr: expr . LSHIFT expr
  167           | expr . RSHIFT expr
  168           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 117
    SUB              shift, and go to state 118
    MULT             shift, and go to state 119
    DIV              shift, and go to state 120
    EXP              shift, and go to state 121
    REM              shift, and go to state 122
    BITWISE_AND      shift, and go to state 123
    BITWISE_XOR      shift, and go to state 125
    LSHIFT           shift, and go to state 137
    RSHIFT           shift, and go to state 138
    RSHIFT_UNSIGNED  shift, and go to state 139

    $default  reduce using rule 164 (bitw-expr)


State 201

   65 logic-expr: expr . EQ expr
   66           | expr . EQ_STRICT expr
   67           | expr . INEQ expr
   68           | expr . INEQ_STRICT expr
   69           | expr . LT expr
   71           | expr . LT_EQ expr
   72           | expr . GT expr
   73           | expr . GT_EQ expr
   74           | expr . LOGICAL_NULL expr
   75           | expr . LOGICAL_AND expr
   76           | expr . LOGICAL_OR expr
  157 arit-expr: expr . PLUS expr
  158          | expr . SUB expr
  159          | expr . MULT expr
  160          | expr . DIV expr
  161          | expr . EXP expr
  162          | expr . REM expr
  163 bitw-expr: expr . BITWISE_AND expr
  164          | expr . BITWISE_OR expr
  165          | expr . BITWISE_XOR expr
  165          | expr BITWISE_XOR expr .
  166 shift-expr: expr . LSHIFT expr
  167           | expr . RSHIFT expr
  168           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 117
    SUB              shift, and go to state 118
    MULT             shift, and go to state 119
    DIV              shift, and go to state 120
    EXP              shift, and go to state 121
    REM              shift, and go to state 122
    BITWISE_AND      shift, and go to state 123
    LSHIFT           shift, and go to state 137
    RSHIFT           shift, and go to state 138
    RSHIFT_UNSIGNED  shift, and go to state 139

    $default  reduce using rule 165 (bitw-expr)


State 202

   65 logic-expr: expr . EQ expr
   66           | expr . EQ_STRICT expr
   67           | expr . INEQ expr
   68           | expr . INEQ_STRICT expr
   69           | expr . LT expr
   71           | expr . LT_EQ expr
   72           | expr . GT expr
   73           | expr . GT_EQ expr
   74           | expr . LOGICAL_NULL expr
   74           | expr LOGICAL_NULL expr .
   75           | expr . LOGICAL_AND expr
   76           | expr . LOGICAL_OR expr
  157 arit-expr: expr . PLUS expr
  158          | expr . SUB expr
  159          | expr . MULT expr
  160          | expr . DIV expr
  161          | expr . EXP expr
  162          | expr . REM expr
  163 bitw-expr: expr . BITWISE_AND expr
  164          | expr . BITWISE_OR expr
  165          | expr . BITWISE_XOR expr
  166 shift-expr: expr . LSHIFT expr
  167           | expr . RSHIFT expr
  168           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 117
    SUB              shift, and go to state 118
    MULT             shift, and go to state 119
    DIV              shift, and go to state 120
    EXP              shift, and go to state 121
    REM              shift, and go to state 122
    BITWISE_AND      shift, and go to state 123
    BITWISE_OR       shift, and go to state 124
    BITWISE_XOR      shift, and go to state 125
    LSHIFT           shift, and go to state 137
    RSHIFT           shift, and go to state 138
    RSHIFT_UNSIGNED  shift, and go to state 139

    $default  reduce using rule 74 (logic-expr)


State 203

   65 logic-expr: expr . EQ expr
   66           | expr . EQ_STRICT expr
   67           | expr . INEQ expr
   68           | expr . INEQ_STRICT expr
   69           | expr . LT expr
   71           | expr . LT_EQ expr
   72           | expr . GT expr
   73           | expr . GT_EQ expr
   74           | expr . LOGICAL_NULL expr
   75           | expr . LOGICAL_AND expr
   75           | expr LOGICAL_AND expr .
   76           | expr . LOGICAL_OR expr
  157 arit-expr: expr . PLUS expr
  158          | expr . SUB expr
  159          | expr . MULT expr
  160          | expr . DIV expr
  161          | expr . EXP expr
  162          | expr . REM expr
  163 bitw-expr: expr . BITWISE_AND expr
  164          | expr . BITWISE_OR expr
  165          | expr . BITWISE_XOR expr
  166 shift-expr: expr . LSHIFT expr
  167           | expr . RSHIFT expr
  168           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 117
    SUB              shift, and go to state 118
    MULT             shift, and go to state 119
    DIV              shift, and go to state 120
    EXP              shift, and go to state 121
    REM              shift, and go to state 122
    BITWISE_AND      shift, and go to state 123
    BITWISE_OR       shift, and go to state 124
    BITWISE_XOR      shift, and go to state 125
    LSHIFT           shift, and go to state 137
    RSHIFT           shift, and go to state 138
    RSHIFT_UNSIGNED  shift, and go to state 139

    $default  reduce using rule 75 (logic-expr)


State 204

   65 logic-expr: expr . EQ expr
   66           | expr . EQ_STRICT expr
   67           | expr . INEQ expr
   68           | expr . INEQ_STRICT expr
   69           | expr . LT expr
   71           | expr . LT_EQ expr
   72           | expr . GT expr
   73           | expr . GT_EQ expr
   74           | expr . LOGICAL_NULL expr
   75           | expr . LOGICAL_AND expr
   76           | expr . LOGICAL_OR expr
   76           | expr LOGICAL_OR expr .
  157 arit-expr: expr . PLUS expr
  158          | expr . SUB expr
  159          | expr . MULT expr
  160          | expr . DIV expr
  161          | expr . EXP expr
  162          | expr . REM expr
  163 bitw-expr: expr . BITWISE_AND expr
  164          | expr . BITWISE_OR expr
  165          | expr . BITWISE_XOR expr
  166 shift-expr: expr . LSHIFT expr
  167           | expr . RSHIFT expr
  168           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 117
    SUB              shift, and go to state 118
    MULT             shift, and go to state 119
    DIV              shift, and go to state 120
    EXP              shift, and go to state 121
    REM              shift, and go to state 122
    BITWISE_AND      shift, and go to state 123
    BITWISE_OR       shift, and go to state 124
    BITWISE_XOR      shift, and go to state 125
    LSHIFT           shift, and go to state 137
    RSHIFT           shift, and go to state 138
    RSHIFT_UNSIGNED  shift, and go to state 139

    $default  reduce using rule 76 (logic-expr)


State 205

   65 logic-expr: expr . EQ expr
   65           | expr EQ expr .
   66           | expr . EQ_STRICT expr
   67           | expr . INEQ expr
   68           | expr . INEQ_STRICT expr
   69           | expr . LT expr
   71           | expr . LT_EQ expr
   72           | expr . GT expr
   73           | expr . GT_EQ expr
   74           | expr . LOGICAL_NULL expr
   75           | expr . LOGICAL_AND expr
   76           | expr . LOGICAL_OR expr
  157 arit-expr: expr . PLUS expr
  158          | expr . SUB expr
  159          | expr . MULT expr
  160          | expr . DIV expr
  161          | expr . EXP expr
  162          | expr . REM expr
  163 bitw-expr: expr . BITWISE_AND expr
  164          | expr . BITWISE_OR expr
  165          | expr . BITWISE_XOR expr
  166 shift-expr: expr . LSHIFT expr
  167           | expr . RSHIFT expr
  168           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 117
    SUB              shift, and go to state 118
    MULT             shift, and go to state 119
    DIV              shift, and go to state 120
    EXP              shift, and go to state 121
    REM              shift, and go to state 122
    BITWISE_AND      shift, and go to state 123
    BITWISE_OR       shift, and go to state 124
    BITWISE_XOR      shift, and go to state 125
    LSHIFT           shift, and go to state 137
    RSHIFT           shift, and go to state 138
    RSHIFT_UNSIGNED  shift, and go to state 139

    $default  reduce using rule 65 (logic-expr)


State 206

   65 logic-expr: expr . EQ expr
   66           | expr . EQ_STRICT expr
   66           | expr EQ_STRICT expr .
   67           | expr . INEQ expr
   68           | expr . INEQ_STRICT expr
   69           | expr . LT expr
   71           | expr . LT_EQ expr
   72           | expr . GT expr
   73           | expr . GT_EQ expr
   74           | expr . LOGICAL_NULL expr
   75           | expr . LOGICAL_AND expr
   76           | expr . LOGICAL_OR expr
  157 arit-expr: expr . PLUS expr
  158          | expr . SUB expr
  159          | expr . MULT expr
  160          | expr . DIV expr
  161          | expr . EXP expr
  162          | expr . REM expr
  163 bitw-expr: expr . BITWISE_AND expr
  164          | expr . BITWISE_OR expr
  165          | expr . BITWISE_XOR expr
  166 shift-expr: expr . LSHIFT expr
  167           | expr . RSHIFT expr
  168           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 117
    SUB              shift, and go to state 118
    MULT             shift, and go to state 119
    DIV              shift, and go to state 120
    EXP              shift, and go to state 121
    REM              shift, and go to state 122
    BITWISE_AND      shift, and go to state 123
    BITWISE_OR       shift, and go to state 124
    BITWISE_XOR      shift, and go to state 125
    LSHIFT           shift, and go to state 137
    RSHIFT           shift, and go to state 138
    RSHIFT_UNSIGNED  shift, and go to state 139

    $default  reduce using rule 66 (logic-expr)


State 207

   65 logic-expr: expr . EQ expr
   66           | expr . EQ_STRICT expr
   67           | expr . INEQ expr
   67           | expr INEQ expr .
   68           | expr . INEQ_STRICT expr
   69           | expr . LT expr
   71           | expr . LT_EQ expr
   72           | expr . GT expr
   73           | expr . GT_EQ expr
   74           | expr . LOGICAL_NULL expr
   75           | expr . LOGICAL_AND expr
   76           | expr . LOGICAL_OR expr
  157 arit-expr: expr . PLUS expr
  158          | expr . SUB expr
  159          | expr . MULT expr
  160          | expr . DIV expr
  161          | expr . EXP expr
  162          | expr . REM expr
  163 bitw-expr: expr . BITWISE_AND expr
  164          | expr . BITWISE_OR expr
  165          | expr . BITWISE_XOR expr
  166 shift-expr: expr . LSHIFT expr
  167           | expr . RSHIFT expr
  168           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 117
    SUB              shift, and go to state 118
    MULT             shift, and go to state 119
    DIV              shift, and go to state 120
    EXP              shift, and go to state 121
    REM              shift, and go to state 122
    BITWISE_AND      shift, and go to state 123
    BITWISE_OR       shift, and go to state 124
    BITWISE_XOR      shift, and go to state 125
    LSHIFT           shift, and go to state 137
    RSHIFT           shift, and go to state 138
    RSHIFT_UNSIGNED  shift, and go to state 139

    $default  reduce using rule 67 (logic-expr)


State 208

   65 logic-expr: expr . EQ expr
   66           | expr . EQ_STRICT expr
   67           | expr . INEQ expr
   68           | expr . INEQ_STRICT expr
   68           | expr INEQ_STRICT expr .
   69           | expr . LT expr
   71           | expr . LT_EQ expr
   72           | expr . GT expr
   73           | expr . GT_EQ expr
   74           | expr . LOGICAL_NULL expr
   75           | expr . LOGICAL_AND expr
   76           | expr . LOGICAL_OR expr
  157 arit-expr: expr . PLUS expr
  158          | expr . SUB expr
  159          | expr . MULT expr
  160          | expr . DIV expr
  161          | expr . EXP expr
  162          | expr . REM expr
  163 bitw-expr: expr . BITWISE_AND expr
  164          | expr . BITWISE_OR expr
  165          | expr . BITWISE_XOR expr
  166 shift-expr: expr . LSHIFT expr
  167           | expr . RSHIFT expr
  168           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 117
    SUB              shift, and go to state 118
    MULT             shift, and go to state 119
    DIV              shift, and go to state 120
    EXP              shift, and go to state 121
    REM              shift, and go to state 122
    BITWISE_AND      shift, and go to state 123
    BITWISE_OR       shift, and go to state 124
    BITWISE_XOR      shift, and go to state 125
    LSHIFT           shift, and go to state 137
    RSHIFT           shift, and go to state 138
    RSHIFT_UNSIGNED  shift, and go to state 139

    $default  reduce using rule 68 (logic-expr)


State 209

   65 logic-expr: expr . EQ expr
   66           | expr . EQ_STRICT expr
   67           | expr . INEQ expr
   68           | expr . INEQ_STRICT expr
   69           | expr . LT expr
   69           | expr LT expr .
   71           | expr . LT_EQ expr
   72           | expr . GT expr
   73           | expr . GT_EQ expr
   74           | expr . LOGICAL_NULL expr
   75           | expr . LOGICAL_AND expr
   76           | expr . LOGICAL_OR expr
  157 arit-expr: expr . PLUS expr
  158          | expr . SUB expr
  159          | expr . MULT expr
  160          | expr . DIV expr
  161          | expr . EXP expr
  162          | expr . REM expr
  163 bitw-expr: expr . BITWISE_AND expr
  164          | expr . BITWISE_OR expr
  165          | expr . BITWISE_XOR expr
  166 shift-expr: expr . LSHIFT expr
  167           | expr . RSHIFT expr
  168           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 117
    SUB              shift, and go to state 118
    MULT             shift, and go to state 119
    DIV              shift, and go to state 120
    EXP              shift, and go to state 121
    REM              shift, and go to state 122
    BITWISE_AND      shift, and go to state 123
    BITWISE_OR       shift, and go to state 124
    BITWISE_XOR      shift, and go to state 125
    LSHIFT           shift, and go to state 137
    RSHIFT           shift, and go to state 138
    RSHIFT_UNSIGNED  shift, and go to state 139

    $default  reduce using rule 69 (logic-expr)


State 210

   65 logic-expr: expr . EQ expr
   66           | expr . EQ_STRICT expr
   67           | expr . INEQ expr
   68           | expr . INEQ_STRICT expr
   69           | expr . LT expr
   71           | expr . LT_EQ expr
   71           | expr LT_EQ expr .
   72           | expr . GT expr
   73           | expr . GT_EQ expr
   74           | expr . LOGICAL_NULL expr
   75           | expr . LOGICAL_AND expr
   76           | expr . LOGICAL_OR expr
  157 arit-expr: expr . PLUS expr
  158          | expr . SUB expr
  159          | expr . MULT expr
  160          | expr . DIV expr
  161          | expr . EXP expr
  162          | expr . REM expr
  163 bitw-expr: expr . BITWISE_AND expr
  164          | expr . BITWISE_OR expr
  165          | expr . BITWISE_XOR expr
  166 shift-expr: expr . LSHIFT expr
  167           | expr . RSHIFT expr
  168           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 117
    SUB              shift, and go to state 118
    MULT             shift, and go to state 119
    DIV              shift, and go to state 120
    EXP              shift, and go to state 121
    REM              shift, and go to state 122
    BITWISE_AND      shift, and go to state 123
    BITWISE_OR       shift, and go to state 124
    BITWISE_XOR      shift, and go to state 125
    LSHIFT           shift, and go to state 137
    RSHIFT           shift, and go to state 138
    RSHIFT_UNSIGNED  shift, and go to state 139

    $default  reduce using rule 71 (logic-expr)


State 211

   65 logic-expr: expr . EQ expr
   66           | expr . EQ_STRICT expr
   67           | expr . INEQ expr
   68           | expr . INEQ_STRICT expr
   69           | expr . LT expr
   71           | expr . LT_EQ expr
   72           | expr . GT expr
   72           | expr GT expr .
   73           | expr . GT_EQ expr
   74           | expr . LOGICAL_NULL expr
   75           | expr . LOGICAL_AND expr
   76           | expr . LOGICAL_OR expr
  157 arit-expr: expr . PLUS expr
  158          | expr . SUB expr
  159          | expr . MULT expr
  160          | expr . DIV expr
  161          | expr . EXP expr
  162          | expr . REM expr
  163 bitw-expr: expr . BITWISE_AND expr
  164          | expr . BITWISE_OR expr
  165          | expr . BITWISE_XOR expr
  166 shift-expr: expr . LSHIFT expr
  167           | expr . RSHIFT expr
  168           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 117
    SUB              shift, and go to state 118
    MULT             shift, and go to state 119
    DIV              shift, and go to state 120
    EXP              shift, and go to state 121
    REM              shift, and go to state 122
    BITWISE_AND      shift, and go to state 123
    BITWISE_OR       shift, and go to state 124
    BITWISE_XOR      shift, and go to state 125
    LSHIFT           shift, and go to state 137
    RSHIFT           shift, and go to state 138
    RSHIFT_UNSIGNED  shift, and go to state 139

    $default  reduce using rule 72 (logic-expr)


State 212

   65 logic-expr: expr . EQ expr
   66           | expr . EQ_STRICT expr
   67           | expr . INEQ expr
   68           | expr . INEQ_STRICT expr
   69           | expr . LT expr
   71           | expr . LT_EQ expr
   72           | expr . GT expr
   73           | expr . GT_EQ expr
   73           | expr GT_EQ expr .
   74           | expr . LOGICAL_NULL expr
   75           | expr . LOGICAL_AND expr
   76           | expr . LOGICAL_OR expr
  157 arit-expr: expr . PLUS expr
  158          | expr . SUB expr
  159          | expr . MULT expr
  160          | expr . DIV expr
  161          | expr . EXP expr
  162          | expr . REM expr
  163 bitw-expr: expr . BITWISE_AND expr
  164          | expr . BITWISE_OR expr
  165          | expr . BITWISE_XOR expr
  166 shift-expr: expr . LSHIFT expr
  167           | expr . RSHIFT expr
  168           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 117
    SUB              shift, and go to state 118
    MULT             shift, and go to state 119
    DIV              shift, and go to state 120
    EXP              shift, and go to state 121
    REM              shift, and go to state 122
    BITWISE_AND      shift, and go to state 123
    BITWISE_OR       shift, and go to state 124
    BITWISE_XOR      shift, and go to state 125
    LSHIFT           shift, and go to state 137
    RSHIFT           shift, and go to state 138
    RSHIFT_UNSIGNED  shift, and go to state 139

    $default  reduce using rule 73 (logic-expr)


State 213

   65 logic-expr: expr . EQ expr
   66           | expr . EQ_STRICT expr
   67           | expr . INEQ expr
   68           | expr . INEQ_STRICT expr
   69           | expr . LT expr
   71           | expr . LT_EQ expr
   72           | expr . GT expr
   73           | expr . GT_EQ expr
   74           | expr . LOGICAL_NULL expr
   75           | expr . LOGICAL_AND expr
   76           | expr . LOGICAL_OR expr
  157 arit-expr: expr . PLUS expr
  158          | expr . SUB expr
  159          | expr . MULT expr
  160          | expr . DIV expr
  161          | expr . EXP expr
  162          | expr . REM expr
  163 bitw-expr: expr . BITWISE_AND expr
  164          | expr . BITWISE_OR expr
  165          | expr . BITWISE_XOR expr
  166 shift-expr: expr . LSHIFT expr
  166           | expr LSHIFT expr .
  167           | expr . RSHIFT expr
  168           | expr . RSHIFT_UNSIGNED expr

    PLUS  shift, and go to state 117
    SUB   shift, and go to state 118
    MULT  shift, and go to state 119
    DIV   shift, and go to state 120
    EXP   shift, and go to state 121
    REM   shift, and go to state 122

    $default  reduce using rule 166 (shift-expr)


State 214

   65 logic-expr: expr . EQ expr
   66           | expr . EQ_STRICT expr
   67           | expr . INEQ expr
   68           | expr . INEQ_STRICT expr
   69           | expr . LT expr
   71           | expr . LT_EQ expr
   72           | expr . GT expr
   73           | expr . GT_EQ expr
   74           | expr . LOGICAL_NULL expr
   75           | expr . LOGICAL_AND expr
   76           | expr . LOGICAL_OR expr
  157 arit-expr: expr . PLUS expr
  158          | expr . SUB expr
  159          | expr . MULT expr
  160          | expr . DIV expr
  161          | expr . EXP expr
  162          | expr . REM expr
  163 bitw-expr: expr . BITWISE_AND expr
  164          | expr . BITWISE_OR expr
  165          | expr . BITWISE_XOR expr
  166 shift-expr: expr . LSHIFT expr
  167           | expr . RSHIFT expr
  167           | expr RSHIFT expr .
  168           | expr . RSHIFT_UNSIGNED expr

    PLUS  shift, and go to state 117
    SUB   shift, and go to state 118
    MULT  shift, and go to state 119
    DIV   shift, and go to state 120
    EXP   shift, and go to state 121
    REM   shift, and go to state 122

    $default  reduce using rule 167 (shift-expr)


State 215

   65 logic-expr: expr . EQ expr
   66           | expr . EQ_STRICT expr
   67           | expr . INEQ expr
   68           | expr . INEQ_STRICT expr
   69           | expr . LT expr
   71           | expr . LT_EQ expr
   72           | expr . GT expr
   73           | expr . GT_EQ expr
   74           | expr . LOGICAL_NULL expr
   75           | expr . LOGICAL_AND expr
   76           | expr . LOGICAL_OR expr
  157 arit-expr: expr . PLUS expr
  158          | expr . SUB expr
  159          | expr . MULT expr
  160          | expr . DIV expr
  161          | expr . EXP expr
  162          | expr . REM expr
  163 bitw-expr: expr . BITWISE_AND expr
  164          | expr . BITWISE_OR expr
  165          | expr . BITWISE_XOR expr
  166 shift-expr: expr . LSHIFT expr
  167           | expr . RSHIFT expr
  168           | expr . RSHIFT_UNSIGNED expr
  168           | expr RSHIFT_UNSIGNED expr .

    PLUS  shift, and go to state 117
    SUB   shift, and go to state 118
    MULT  shift, and go to state 119
    DIV   shift, and go to state 120
    EXP   shift, and go to state 121
    REM   shift, and go to state 122

    $default  reduce using rule 168 (shift-expr)


State 216

   20 assign-expr: vet-idx assignment expr .
   65 logic-expr: expr . EQ expr
   66           | expr . EQ_STRICT expr
   67           | expr . INEQ expr
   68           | expr . INEQ_STRICT expr
   69           | expr . LT expr
   71           | expr . LT_EQ expr
   72           | expr . GT expr
   73           | expr . GT_EQ expr
   74           | expr . LOGICAL_NULL expr
   75           | expr . LOGICAL_AND expr
   76           | expr . LOGICAL_OR expr
  157 arit-expr: expr . PLUS expr
  158          | expr . SUB expr
  159          | expr . MULT expr
  160          | expr . DIV expr
  161          | expr . EXP expr
  162          | expr . REM expr
  163 bitw-expr: expr . BITWISE_AND expr
  164          | expr . BITWISE_OR expr
  165          | expr . BITWISE_XOR expr
  166 shift-expr: expr . LSHIFT expr
  167           | expr . RSHIFT expr
  168           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 117
    SUB              shift, and go to state 118
    MULT             shift, and go to state 119
    DIV              shift, and go to state 120
    EXP              shift, and go to state 121
    REM              shift, and go to state 122
    BITWISE_AND      shift, and go to state 123
    BITWISE_OR       shift, and go to state 124
    BITWISE_XOR      shift, and go to state 125
    LOGICAL_NULL     shift, and go to state 126
    LOGICAL_AND      shift, and go to state 127
    LOGICAL_OR       shift, and go to state 128
    EQ               shift, and go to state 129
    EQ_STRICT        shift, and go to state 130
    INEQ             shift, and go to state 131
    INEQ_STRICT      shift, and go to state 132
    LT               shift, and go to state 133
    LT_EQ            shift, and go to state 134
    GT               shift, and go to state 135
    GT_EQ            shift, and go to state 136
    LSHIFT           shift, and go to state 137
    RSHIFT           shift, and go to state 138
    RSHIFT_UNSIGNED  shift, and go to state 139

    $default  reduce using rule 20 (assign-expr)


State 217

  170 var-att: var-att DOT ID .
  176 var-met: ID . LPAR args-list RPAR

    LPAR  shift, and go to state 146

    $default  reduce using rule 170 (var-att)


State 218

  174 var-att: var-att DOT var-met .

    $default  reduce using rule 174 (var-att)


State 219

   18 assign-expr: var-att assignment expr .
   65 logic-expr: expr . EQ expr
   66           | expr . EQ_STRICT expr
   67           | expr . INEQ expr
   68           | expr . INEQ_STRICT expr
   69           | expr . LT expr
   71           | expr . LT_EQ expr
   72           | expr . GT expr
   73           | expr . GT_EQ expr
   74           | expr . LOGICAL_NULL expr
   75           | expr . LOGICAL_AND expr
   76           | expr . LOGICAL_OR expr
  157 arit-expr: expr . PLUS expr
  158          | expr . SUB expr
  159          | expr . MULT expr
  160          | expr . DIV expr
  161          | expr . EXP expr
  162          | expr . REM expr
  163 bitw-expr: expr . BITWISE_AND expr
  164          | expr . BITWISE_OR expr
  165          | expr . BITWISE_XOR expr
  166 shift-expr: expr . LSHIFT expr
  167           | expr . RSHIFT expr
  168           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 117
    SUB              shift, and go to state 118
    MULT             shift, and go to state 119
    DIV              shift, and go to state 120
    EXP              shift, and go to state 121
    REM              shift, and go to state 122
    BITWISE_AND      shift, and go to state 123
    BITWISE_OR       shift, and go to state 124
    BITWISE_XOR      shift, and go to state 125
    LOGICAL_NULL     shift, and go to state 126
    LOGICAL_AND      shift, and go to state 127
    LOGICAL_OR       shift, and go to state 128
    EQ               shift, and go to state 129
    EQ_STRICT        shift, and go to state 130
    INEQ             shift, and go to state 131
    INEQ_STRICT      shift, and go to state 132
    LT               shift, and go to state 133
    LT_EQ            shift, and go to state 134
    GT               shift, and go to state 135
    GT_EQ            shift, and go to state 136
    LSHIFT           shift, and go to state 137
    RSHIFT           shift, and go to state 138
    RSHIFT_UNSIGNED  shift, and go to state 139

    $default  reduce using rule 18 (assign-expr)


State 220

  169 var-att: ID . DOT var-att
  171        | ID . DOT var-met
  172        | var-met DOT ID .
  175        | ID . DOT ID
  176 var-met: ID . LPAR args-list RPAR

    DOT   shift, and go to state 73
    LPAR  shift, and go to state 146

    $default  reduce using rule 172 (var-att)


State 221

  170 var-att: var-att . DOT ID
  173        | var-met DOT var-att .
  174        | var-att . DOT var-met

    DOT  shift, and go to state 141

    $default  reduce using rule 173 (var-att)


State 222

  176 var-met: ID LPAR args-list . RPAR

    RPAR  shift, and go to state 264


State 223

  201 elmts-list: var-val COMMA elmts-list .

    $default  reduce using rule 201 (elmts-list)


State 224

  184 var-obj: ID LT var-type GT . LPAR args-list RPAR

    LPAR  shift, and go to state 265


State 225

  177 args-list: COMMA args-list .

    $default  reduce using rule 177 (args-list)


State 226

  179 args-list: assign-expr COMMA . args-list

    COMMA        shift, and go to state 163
    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 182 (args-list)

    assign-expr      go to state 164
    logic-expr       go to state 37
    expr             go to state 165
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    args-list        go to state 266
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 227

  178 args-list: expr COMMA . args-list

    COMMA        shift, and go to state 163
    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 182 (args-list)

    assign-expr      go to state 164
    logic-expr       go to state 37
    expr             go to state 165
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    args-list        go to state 267
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 228

  176 var-met: ID LPAR args-list RPAR .
  183 var-obj: ID LPAR args-list RPAR .

    DOT       reduce using rule 176 (var-met)
    $default  reduce using rule 183 (var-obj)


State 229

  146 vet-idx: ID LBRACKET idx-safe-expr RBRACKET .

    $default  reduce using rule 146 (vet-idx)


State 230

   78 class-att-list: SEMI . class-att-list

    SEMI       shift, and go to state 230
    ID         shift, and go to state 231
    PRIVATE    shift, and go to state 232
    PROTECTED  shift, and go to state 233
    PUBLIC     shift, and go to state 234

    $default  reduce using rule 81 (class-att-list)

    class-att-list  go to state 268
    class-att       go to state 236
    access-modif    go to state 237


State 231

   82 class-att: ID . COLON var-type
   84          | ID . LPAR params RPAR LBRACE line RBRACE
   85          | ID . LPAR params RPAR COLON var-type LBRACE line RBRACE

    COLON  shift, and go to state 269
    LPAR   shift, and go to state 270


State 232

   87 access-modif: PRIVATE .

    $default  reduce using rule 87 (access-modif)


State 233

   88 access-modif: PROTECTED .

    $default  reduce using rule 88 (access-modif)


State 234

   86 access-modif: PUBLIC .

    $default  reduce using rule 86 (access-modif)


State 235

   77 class-def: CLASS ID LBRACE class-att-list . RBRACE

    RBRACE  shift, and go to state 271


State 236

   79 class-att-list: class-att . SEMI class-att-list
   80               | class-att .

    SEMI  shift, and go to state 272

    $default  reduce using rule 80 (class-att-list)


State 237

   83 class-att: access-modif . ID COLON var-type

    ID  shift, and go to state 273


State 238

  117 id-list: ID . COMMA id-list
  118        | ID .

    COMMA  shift, and go to state 171

    $default  reduce using rule 118 (id-list)


State 239

  117 id-list: ID COMMA id-list .

    $default  reduce using rule 117 (id-list)


State 240

  114 var-declr: CONST_RW ID COLON var-type . ASSIGN expr
  115          | CONST_RW ID COLON var-type . LBRACKET RBRACKET ASSIGN expr

    ASSIGN    shift, and go to state 274
    LBRACKET  shift, and go to state 275


State 241

  119 obj-def: LBRACE . obj-att-list RBRACE

    COMMA  shift, and go to state 276
    ID     shift, and go to state 277

    $default  reduce using rule 123 (obj-att-list)

    obj-att-list  go to state 278
    obj-att       go to state 279


State 242

  116 var-declr: CONST_RW id-list ASSIGN obj-def .

    $default  reduce using rule 116 (var-declr)


State 243

   65 logic-expr: expr . EQ expr
   66           | expr . EQ_STRICT expr
   67           | expr . INEQ expr
   68           | expr . INEQ_STRICT expr
   69           | expr . LT expr
   71           | expr . LT_EQ expr
   72           | expr . GT expr
   73           | expr . GT_EQ expr
   74           | expr . LOGICAL_NULL expr
   75           | expr . LOGICAL_AND expr
   76           | expr . LOGICAL_OR expr
  113 var-declr: CONST_RW id-list ASSIGN expr .
  157 arit-expr: expr . PLUS expr
  158          | expr . SUB expr
  159          | expr . MULT expr
  160          | expr . DIV expr
  161          | expr . EXP expr
  162          | expr . REM expr
  163 bitw-expr: expr . BITWISE_AND expr
  164          | expr . BITWISE_OR expr
  165          | expr . BITWISE_XOR expr
  166 shift-expr: expr . LSHIFT expr
  167           | expr . RSHIFT expr
  168           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 117
    SUB              shift, and go to state 118
    MULT             shift, and go to state 119
    DIV              shift, and go to state 120
    EXP              shift, and go to state 121
    REM              shift, and go to state 122
    BITWISE_AND      shift, and go to state 123
    BITWISE_OR       shift, and go to state 124
    BITWISE_XOR      shift, and go to state 125
    LOGICAL_NULL     shift, and go to state 126
    LOGICAL_AND      shift, and go to state 127
    LOGICAL_OR       shift, and go to state 128
    EQ               shift, and go to state 129
    EQ_STRICT        shift, and go to state 130
    INEQ             shift, and go to state 131
    INEQ_STRICT      shift, and go to state 132
    LT               shift, and go to state 133
    LT_EQ            shift, and go to state 134
    GT               shift, and go to state 135
    GT_EQ            shift, and go to state 136
    LSHIFT           shift, and go to state 137
    RSHIFT           shift, and go to state 138
    RSHIFT_UNSIGNED  shift, and go to state 139

    $default  reduce using rule 113 (var-declr)


State 244

   55 do-while-stmt: DO LBRACE line RBRACE . WHILE LPAR expr RPAR
   56              | DO LBRACE line RBRACE . WHILE LPAR assign-expr RPAR

    WHILE  shift, and go to state 280


State 245

   36 for-stmt: FOR LPAR SEMI SEMI . expr RPAR LBRACE line RBRACE
   37         | FOR LPAR SEMI SEMI . assign-expr RPAR LBRACE line RBRACE
   38         | FOR LPAR SEMI SEMI . RPAR LBRACE line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    RPAR         shift, and go to state 281
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    assign-expr      go to state 282
    logic-expr       go to state 37
    expr             go to state 283
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 246

   33 for-stmt: FOR LPAR SEMI expr . SEMI expr RPAR LBRACE line RBRACE
   34         | FOR LPAR SEMI expr . SEMI assign-expr RPAR LBRACE line RBRACE
   35         | FOR LPAR SEMI expr . SEMI RPAR LBRACE line RBRACE
   65 logic-expr: expr . EQ expr
   66           | expr . EQ_STRICT expr
   67           | expr . INEQ expr
   68           | expr . INEQ_STRICT expr
   69           | expr . LT expr
   71           | expr . LT_EQ expr
   72           | expr . GT expr
   73           | expr . GT_EQ expr
   74           | expr . LOGICAL_NULL expr
   75           | expr . LOGICAL_AND expr
   76           | expr . LOGICAL_OR expr
  157 arit-expr: expr . PLUS expr
  158          | expr . SUB expr
  159          | expr . MULT expr
  160          | expr . DIV expr
  161          | expr . EXP expr
  162          | expr . REM expr
  163 bitw-expr: expr . BITWISE_AND expr
  164          | expr . BITWISE_OR expr
  165          | expr . BITWISE_XOR expr
  166 shift-expr: expr . LSHIFT expr
  167           | expr . RSHIFT expr
  168           | expr . RSHIFT_UNSIGNED expr

    SEMI             shift, and go to state 284
    PLUS             shift, and go to state 117
    SUB              shift, and go to state 118
    MULT             shift, and go to state 119
    DIV              shift, and go to state 120
    EXP              shift, and go to state 121
    REM              shift, and go to state 122
    BITWISE_AND      shift, and go to state 123
    BITWISE_OR       shift, and go to state 124
    BITWISE_XOR      shift, and go to state 125
    LOGICAL_NULL     shift, and go to state 126
    LOGICAL_AND      shift, and go to state 127
    LOGICAL_OR       shift, and go to state 128
    EQ               shift, and go to state 129
    EQ_STRICT        shift, and go to state 130
    INEQ             shift, and go to state 131
    INEQ_STRICT      shift, and go to state 132
    LT               shift, and go to state 133
    LT_EQ            shift, and go to state 134
    GT               shift, and go to state 135
    GT_EQ            shift, and go to state 136
    LSHIFT           shift, and go to state 137
    RSHIFT           shift, and go to state 138
    RSHIFT_UNSIGNED  shift, and go to state 139


State 247

   21 for-stmt: FOR LPAR assign-expr SEMI . expr SEMI expr RPAR LBRACE line RBRACE
   22         | FOR LPAR assign-expr SEMI . expr SEMI assign-expr RPAR LBRACE line RBRACE
   23         | FOR LPAR assign-expr SEMI . expr SEMI RPAR LBRACE line RBRACE
   24         | FOR LPAR assign-expr SEMI . SEMI expr RPAR LBRACE line RBRACE
   25         | FOR LPAR assign-expr SEMI . SEMI assign-expr RPAR LBRACE line RBRACE
   26         | FOR LPAR assign-expr SEMI . SEMI RPAR LBRACE line RBRACE

    SEMI         shift, and go to state 285
    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 37
    expr             go to state 286
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 248

   27 for-stmt: FOR LPAR var-declr SEMI . expr SEMI expr RPAR LBRACE line RBRACE
   28         | FOR LPAR var-declr SEMI . expr SEMI assign-expr RPAR LBRACE line RBRACE
   29         | FOR LPAR var-declr SEMI . expr SEMI RPAR LBRACE line RBRACE
   30         | FOR LPAR var-declr SEMI . SEMI expr RPAR LBRACE line RBRACE
   31         | FOR LPAR var-declr SEMI . SEMI assign-expr RPAR LBRACE line RBRACE
   32         | FOR LPAR var-declr SEMI . SEMI RPAR LBRACE line RBRACE

    SEMI         shift, and go to state 287
    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 37
    expr             go to state 288
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 249

   91 params: COMMA . ID
   92       | COMMA . ID COLON var-type

    ID  shift, and go to state 289


State 250

   93 params: ID . COMMA ID
   94       | ID . COLON var-type COMMA ID COLON var-type
   95       | ID . COLON var-type COMMA ID
   96       | ID . COLON var-type
   97       | ID . COMMA ID COLON var-type

    COMMA  shift, and go to state 290
    COLON  shift, and go to state 291


State 251

   89 func-def: FUNCTION ID LPAR params . RPAR LBRACE line RBRACE
   90         | FUNCTION ID LPAR params . RPAR COLON var-type LBRACE line RBRACE

    RPAR  shift, and go to state 292


State 252

   62 if-stmt: IF LPAR assign-expr RPAR . LBRACE line RBRACE
   63        | IF LPAR assign-expr RPAR . LBRACE line RBRACE ELSE LBRACE line RBRACE
   64        | IF LPAR assign-expr RPAR . LBRACE line RBRACE ELSE stmt

    LBRACE  shift, and go to state 293


State 253

   59 if-stmt: IF LPAR expr RPAR . LBRACE line RBRACE
   60        | IF LPAR expr RPAR . LBRACE line RBRACE ELSE LBRACE line RBRACE
   61        | IF LPAR expr RPAR . LBRACE line RBRACE ELSE stmt

    LBRACE  shift, and go to state 294


State 254

  102 var-declr: LET ID COLON var-type .
  103          | LET ID COLON var-type . ASSIGN expr
  104          | LET ID COLON var-type . LBRACKET RBRACKET
  105          | LET ID COLON var-type . LBRACKET RBRACKET ASSIGN expr

    ASSIGN    shift, and go to state 295
    LBRACKET  shift, and go to state 296

    $default  reduce using rule 102 (var-declr)


State 255

  101 var-declr: LET id-list ASSIGN obj-def .

    $default  reduce using rule 101 (var-declr)


State 256

   65 logic-expr: expr . EQ expr
   66           | expr . EQ_STRICT expr
   67           | expr . INEQ expr
   68           | expr . INEQ_STRICT expr
   69           | expr . LT expr
   71           | expr . LT_EQ expr
   72           | expr . GT expr
   73           | expr . GT_EQ expr
   74           | expr . LOGICAL_NULL expr
   75           | expr . LOGICAL_AND expr
   76           | expr . LOGICAL_OR expr
  100 var-declr: LET id-list ASSIGN expr .
  157 arit-expr: expr . PLUS expr
  158          | expr . SUB expr
  159          | expr . MULT expr
  160          | expr . DIV expr
  161          | expr . EXP expr
  162          | expr . REM expr
  163 bitw-expr: expr . BITWISE_AND expr
  164          | expr . BITWISE_OR expr
  165          | expr . BITWISE_XOR expr
  166 shift-expr: expr . LSHIFT expr
  167           | expr . RSHIFT expr
  168           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 117
    SUB              shift, and go to state 118
    MULT             shift, and go to state 119
    DIV              shift, and go to state 120
    EXP              shift, and go to state 121
    REM              shift, and go to state 122
    BITWISE_AND      shift, and go to state 123
    BITWISE_OR       shift, and go to state 124
    BITWISE_XOR      shift, and go to state 125
    LOGICAL_NULL     shift, and go to state 126
    LOGICAL_AND      shift, and go to state 127
    LOGICAL_OR       shift, and go to state 128
    EQ               shift, and go to state 129
    EQ_STRICT        shift, and go to state 130
    INEQ             shift, and go to state 131
    INEQ_STRICT      shift, and go to state 132
    LT               shift, and go to state 133
    LT_EQ            shift, and go to state 134
    GT               shift, and go to state 135
    GT_EQ            shift, and go to state 136
    LSHIFT           shift, and go to state 137
    RSHIFT           shift, and go to state 138
    RSHIFT_UNSIGNED  shift, and go to state 139

    $default  reduce using rule 100 (var-declr)


State 257

  186 var-obj: NEW ID LT var-type . GT LPAR args-list RPAR

    GT  shift, and go to state 297


State 258

  185 var-obj: NEW ID LPAR args-list . RPAR

    RPAR  shift, and go to state 298


State 259

  109 var-declr: VAR ID COLON var-type .
  110          | VAR ID COLON var-type . ASSIGN expr
  111          | VAR ID COLON var-type . LBRACKET RBRACKET
  112          | VAR ID COLON var-type . LBRACKET RBRACKET ASSIGN expr

    ASSIGN    shift, and go to state 299
    LBRACKET  shift, and go to state 300

    $default  reduce using rule 109 (var-declr)


State 260

  108 var-declr: VAR id-list ASSIGN obj-def .

    $default  reduce using rule 108 (var-declr)


State 261

   65 logic-expr: expr . EQ expr
   66           | expr . EQ_STRICT expr
   67           | expr . INEQ expr
   68           | expr . INEQ_STRICT expr
   69           | expr . LT expr
   71           | expr . LT_EQ expr
   72           | expr . GT expr
   73           | expr . GT_EQ expr
   74           | expr . LOGICAL_NULL expr
   75           | expr . LOGICAL_AND expr
   76           | expr . LOGICAL_OR expr
  107 var-declr: VAR id-list ASSIGN expr .
  157 arit-expr: expr . PLUS expr
  158          | expr . SUB expr
  159          | expr . MULT expr
  160          | expr . DIV expr
  161          | expr . EXP expr
  162          | expr . REM expr
  163 bitw-expr: expr . BITWISE_AND expr
  164          | expr . BITWISE_OR expr
  165          | expr . BITWISE_XOR expr
  166 shift-expr: expr . LSHIFT expr
  167           | expr . RSHIFT expr
  168           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 117
    SUB              shift, and go to state 118
    MULT             shift, and go to state 119
    DIV              shift, and go to state 120
    EXP              shift, and go to state 121
    REM              shift, and go to state 122
    BITWISE_AND      shift, and go to state 123
    BITWISE_OR       shift, and go to state 124
    BITWISE_XOR      shift, and go to state 125
    LOGICAL_NULL     shift, and go to state 126
    LOGICAL_AND      shift, and go to state 127
    LOGICAL_OR       shift, and go to state 128
    EQ               shift, and go to state 129
    EQ_STRICT        shift, and go to state 130
    INEQ             shift, and go to state 131
    INEQ_STRICT      shift, and go to state 132
    LT               shift, and go to state 133
    LT_EQ            shift, and go to state 134
    GT               shift, and go to state 135
    GT_EQ            shift, and go to state 136
    LSHIFT           shift, and go to state 137
    RSHIFT           shift, and go to state 138
    RSHIFT_UNSIGNED  shift, and go to state 139

    $default  reduce using rule 107 (var-declr)


State 262

   58 while-stmt: WHILE LPAR assign-expr RPAR . LBRACE line RBRACE

    LBRACE  shift, and go to state 301


State 263

   57 while-stmt: WHILE LPAR expr RPAR . LBRACE line RBRACE

    LBRACE  shift, and go to state 302


State 264

  176 var-met: ID LPAR args-list RPAR .

    $default  reduce using rule 176 (var-met)


State 265

  184 var-obj: ID LT var-type GT LPAR . args-list RPAR

    COMMA        shift, and go to state 163
    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 182 (args-list)

    assign-expr      go to state 164
    logic-expr       go to state 37
    expr             go to state 165
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    args-list        go to state 303
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 266

  179 args-list: assign-expr COMMA args-list .

    $default  reduce using rule 179 (args-list)


State 267

  178 args-list: expr COMMA args-list .

    $default  reduce using rule 178 (args-list)


State 268

   78 class-att-list: SEMI class-att-list .

    $default  reduce using rule 78 (class-att-list)


State 269

   82 class-att: ID COLON . var-type

    VOID_RW   shift, and go to state 154
    ANY       shift, and go to state 155
    BOOLTYPE  shift, and go to state 156
    NEVER     shift, and go to state 157
    NUMBER    shift, and go to state 158
    STRING    shift, and go to state 159
    UNKNOWN   shift, and go to state 160

    var-type  go to state 304


State 270

   84 class-att: ID LPAR . params RPAR LBRACE line RBRACE
   85          | ID LPAR . params RPAR COLON var-type LBRACE line RBRACE

    COMMA  shift, and go to state 249
    ID     shift, and go to state 250

    $default  reduce using rule 98 (params)

    params  go to state 305


State 271

   77 class-def: CLASS ID LBRACE class-att-list RBRACE .

    $default  reduce using rule 77 (class-def)


State 272

   79 class-att-list: class-att SEMI . class-att-list

    SEMI       shift, and go to state 230
    ID         shift, and go to state 231
    PRIVATE    shift, and go to state 232
    PROTECTED  shift, and go to state 233
    PUBLIC     shift, and go to state 234

    $default  reduce using rule 81 (class-att-list)

    class-att-list  go to state 306
    class-att       go to state 236
    access-modif    go to state 237


State 273

   83 class-att: access-modif ID . COLON var-type

    COLON  shift, and go to state 307


State 274

  114 var-declr: CONST_RW ID COLON var-type ASSIGN . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 37
    expr             go to state 308
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 275

  115 var-declr: CONST_RW ID COLON var-type LBRACKET . RBRACKET ASSIGN expr

    RBRACKET  shift, and go to state 309


State 276

  120 obj-att-list: COMMA . obj-att-list

    COMMA  shift, and go to state 276
    ID     shift, and go to state 277

    $default  reduce using rule 123 (obj-att-list)

    obj-att-list  go to state 310
    obj-att       go to state 279


State 277

  124 obj-att: ID . COLON var-val

    COLON  shift, and go to state 311


State 278

  119 obj-def: LBRACE obj-att-list . RBRACE

    RBRACE  shift, and go to state 312


State 279

  121 obj-att-list: obj-att . COMMA obj-att-list
  122             | obj-att .

    COMMA  shift, and go to state 313

    $default  reduce using rule 122 (obj-att-list)


State 280

   55 do-while-stmt: DO LBRACE line RBRACE WHILE . LPAR expr RPAR
   56              | DO LBRACE line RBRACE WHILE . LPAR assign-expr RPAR

    LPAR  shift, and go to state 314


State 281

   38 for-stmt: FOR LPAR SEMI SEMI RPAR . LBRACE line RBRACE

    LBRACE  shift, and go to state 315


State 282

   37 for-stmt: FOR LPAR SEMI SEMI assign-expr . RPAR LBRACE line RBRACE

    RPAR  shift, and go to state 316


State 283

   36 for-stmt: FOR LPAR SEMI SEMI expr . RPAR LBRACE line RBRACE
   65 logic-expr: expr . EQ expr
   66           | expr . EQ_STRICT expr
   67           | expr . INEQ expr
   68           | expr . INEQ_STRICT expr
   69           | expr . LT expr
   71           | expr . LT_EQ expr
   72           | expr . GT expr
   73           | expr . GT_EQ expr
   74           | expr . LOGICAL_NULL expr
   75           | expr . LOGICAL_AND expr
   76           | expr . LOGICAL_OR expr
  157 arit-expr: expr . PLUS expr
  158          | expr . SUB expr
  159          | expr . MULT expr
  160          | expr . DIV expr
  161          | expr . EXP expr
  162          | expr . REM expr
  163 bitw-expr: expr . BITWISE_AND expr
  164          | expr . BITWISE_OR expr
  165          | expr . BITWISE_XOR expr
  166 shift-expr: expr . LSHIFT expr
  167           | expr . RSHIFT expr
  168           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 117
    SUB              shift, and go to state 118
    MULT             shift, and go to state 119
    DIV              shift, and go to state 120
    EXP              shift, and go to state 121
    REM              shift, and go to state 122
    BITWISE_AND      shift, and go to state 123
    BITWISE_OR       shift, and go to state 124
    BITWISE_XOR      shift, and go to state 125
    LOGICAL_NULL     shift, and go to state 126
    LOGICAL_AND      shift, and go to state 127
    LOGICAL_OR       shift, and go to state 128
    EQ               shift, and go to state 129
    EQ_STRICT        shift, and go to state 130
    INEQ             shift, and go to state 131
    INEQ_STRICT      shift, and go to state 132
    LT               shift, and go to state 133
    LT_EQ            shift, and go to state 134
    GT               shift, and go to state 135
    GT_EQ            shift, and go to state 136
    LSHIFT           shift, and go to state 137
    RSHIFT           shift, and go to state 138
    RSHIFT_UNSIGNED  shift, and go to state 139
    RPAR             shift, and go to state 317


State 284

   33 for-stmt: FOR LPAR SEMI expr SEMI . expr RPAR LBRACE line RBRACE
   34         | FOR LPAR SEMI expr SEMI . assign-expr RPAR LBRACE line RBRACE
   35         | FOR LPAR SEMI expr SEMI . RPAR LBRACE line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    RPAR         shift, and go to state 318
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    assign-expr      go to state 319
    logic-expr       go to state 37
    expr             go to state 320
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 285

   24 for-stmt: FOR LPAR assign-expr SEMI SEMI . expr RPAR LBRACE line RBRACE
   25         | FOR LPAR assign-expr SEMI SEMI . assign-expr RPAR LBRACE line RBRACE
   26         | FOR LPAR assign-expr SEMI SEMI . RPAR LBRACE line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    RPAR         shift, and go to state 321
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    assign-expr      go to state 322
    logic-expr       go to state 37
    expr             go to state 323
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 286

   21 for-stmt: FOR LPAR assign-expr SEMI expr . SEMI expr RPAR LBRACE line RBRACE
   22         | FOR LPAR assign-expr SEMI expr . SEMI assign-expr RPAR LBRACE line RBRACE
   23         | FOR LPAR assign-expr SEMI expr . SEMI RPAR LBRACE line RBRACE
   65 logic-expr: expr . EQ expr
   66           | expr . EQ_STRICT expr
   67           | expr . INEQ expr
   68           | expr . INEQ_STRICT expr
   69           | expr . LT expr
   71           | expr . LT_EQ expr
   72           | expr . GT expr
   73           | expr . GT_EQ expr
   74           | expr . LOGICAL_NULL expr
   75           | expr . LOGICAL_AND expr
   76           | expr . LOGICAL_OR expr
  157 arit-expr: expr . PLUS expr
  158          | expr . SUB expr
  159          | expr . MULT expr
  160          | expr . DIV expr
  161          | expr . EXP expr
  162          | expr . REM expr
  163 bitw-expr: expr . BITWISE_AND expr
  164          | expr . BITWISE_OR expr
  165          | expr . BITWISE_XOR expr
  166 shift-expr: expr . LSHIFT expr
  167           | expr . RSHIFT expr
  168           | expr . RSHIFT_UNSIGNED expr

    SEMI             shift, and go to state 324
    PLUS             shift, and go to state 117
    SUB              shift, and go to state 118
    MULT             shift, and go to state 119
    DIV              shift, and go to state 120
    EXP              shift, and go to state 121
    REM              shift, and go to state 122
    BITWISE_AND      shift, and go to state 123
    BITWISE_OR       shift, and go to state 124
    BITWISE_XOR      shift, and go to state 125
    LOGICAL_NULL     shift, and go to state 126
    LOGICAL_AND      shift, and go to state 127
    LOGICAL_OR       shift, and go to state 128
    EQ               shift, and go to state 129
    EQ_STRICT        shift, and go to state 130
    INEQ             shift, and go to state 131
    INEQ_STRICT      shift, and go to state 132
    LT               shift, and go to state 133
    LT_EQ            shift, and go to state 134
    GT               shift, and go to state 135
    GT_EQ            shift, and go to state 136
    LSHIFT           shift, and go to state 137
    RSHIFT           shift, and go to state 138
    RSHIFT_UNSIGNED  shift, and go to state 139


State 287

   30 for-stmt: FOR LPAR var-declr SEMI SEMI . expr RPAR LBRACE line RBRACE
   31         | FOR LPAR var-declr SEMI SEMI . assign-expr RPAR LBRACE line RBRACE
   32         | FOR LPAR var-declr SEMI SEMI . RPAR LBRACE line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    RPAR         shift, and go to state 325
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    assign-expr      go to state 326
    logic-expr       go to state 37
    expr             go to state 327
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 288

   27 for-stmt: FOR LPAR var-declr SEMI expr . SEMI expr RPAR LBRACE line RBRACE
   28         | FOR LPAR var-declr SEMI expr . SEMI assign-expr RPAR LBRACE line RBRACE
   29         | FOR LPAR var-declr SEMI expr . SEMI RPAR LBRACE line RBRACE
   65 logic-expr: expr . EQ expr
   66           | expr . EQ_STRICT expr
   67           | expr . INEQ expr
   68           | expr . INEQ_STRICT expr
   69           | expr . LT expr
   71           | expr . LT_EQ expr
   72           | expr . GT expr
   73           | expr . GT_EQ expr
   74           | expr . LOGICAL_NULL expr
   75           | expr . LOGICAL_AND expr
   76           | expr . LOGICAL_OR expr
  157 arit-expr: expr . PLUS expr
  158          | expr . SUB expr
  159          | expr . MULT expr
  160          | expr . DIV expr
  161          | expr . EXP expr
  162          | expr . REM expr
  163 bitw-expr: expr . BITWISE_AND expr
  164          | expr . BITWISE_OR expr
  165          | expr . BITWISE_XOR expr
  166 shift-expr: expr . LSHIFT expr
  167           | expr . RSHIFT expr
  168           | expr . RSHIFT_UNSIGNED expr

    SEMI             shift, and go to state 328
    PLUS             shift, and go to state 117
    SUB              shift, and go to state 118
    MULT             shift, and go to state 119
    DIV              shift, and go to state 120
    EXP              shift, and go to state 121
    REM              shift, and go to state 122
    BITWISE_AND      shift, and go to state 123
    BITWISE_OR       shift, and go to state 124
    BITWISE_XOR      shift, and go to state 125
    LOGICAL_NULL     shift, and go to state 126
    LOGICAL_AND      shift, and go to state 127
    LOGICAL_OR       shift, and go to state 128
    EQ               shift, and go to state 129
    EQ_STRICT        shift, and go to state 130
    INEQ             shift, and go to state 131
    INEQ_STRICT      shift, and go to state 132
    LT               shift, and go to state 133
    LT_EQ            shift, and go to state 134
    GT               shift, and go to state 135
    GT_EQ            shift, and go to state 136
    LSHIFT           shift, and go to state 137
    RSHIFT           shift, and go to state 138
    RSHIFT_UNSIGNED  shift, and go to state 139


State 289

   91 params: COMMA ID .
   92       | COMMA ID . COLON var-type

    COLON  shift, and go to state 329

    $default  reduce using rule 91 (params)


State 290

   93 params: ID COMMA . ID
   97       | ID COMMA . ID COLON var-type

    ID  shift, and go to state 330


State 291

   94 params: ID COLON . var-type COMMA ID COLON var-type
   95       | ID COLON . var-type COMMA ID
   96       | ID COLON . var-type

    VOID_RW   shift, and go to state 154
    ANY       shift, and go to state 155
    BOOLTYPE  shift, and go to state 156
    NEVER     shift, and go to state 157
    NUMBER    shift, and go to state 158
    STRING    shift, and go to state 159
    UNKNOWN   shift, and go to state 160

    var-type  go to state 331


State 292

   89 func-def: FUNCTION ID LPAR params RPAR . LBRACE line RBRACE
   90         | FUNCTION ID LPAR params RPAR . COLON var-type LBRACE line RBRACE

    COLON   shift, and go to state 332
    LBRACE  shift, and go to state 333


State 293

   62 if-stmt: IF LPAR assign-expr RPAR LBRACE . line RBRACE
   63        | IF LPAR assign-expr RPAR LBRACE . line RBRACE ELSE LBRACE line RBRACE
   64        | IF LPAR assign-expr RPAR LBRACE . line RBRACE ELSE stmt

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 2 (line)

    line             go to state 334
    stmt-list        go to state 30
    stmt             go to state 31
    assign-expr      go to state 32
    for-stmt         go to state 33
    do-while-stmt    go to state 34
    while-stmt       go to state 35
    if-stmt          go to state 36
    logic-expr       go to state 37
    class-def        go to state 38
    func-def         go to state 39
    var-declr        go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 294

   59 if-stmt: IF LPAR expr RPAR LBRACE . line RBRACE
   60        | IF LPAR expr RPAR LBRACE . line RBRACE ELSE LBRACE line RBRACE
   61        | IF LPAR expr RPAR LBRACE . line RBRACE ELSE stmt

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 2 (line)

    line             go to state 335
    stmt-list        go to state 30
    stmt             go to state 31
    assign-expr      go to state 32
    for-stmt         go to state 33
    do-while-stmt    go to state 34
    while-stmt       go to state 35
    if-stmt          go to state 36
    logic-expr       go to state 37
    class-def        go to state 38
    func-def         go to state 39
    var-declr        go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 295

  103 var-declr: LET ID COLON var-type ASSIGN . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 37
    expr             go to state 336
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 296

  104 var-declr: LET ID COLON var-type LBRACKET . RBRACKET
  105          | LET ID COLON var-type LBRACKET . RBRACKET ASSIGN expr

    RBRACKET  shift, and go to state 337


State 297

  186 var-obj: NEW ID LT var-type GT . LPAR args-list RPAR

    LPAR  shift, and go to state 338


State 298

  185 var-obj: NEW ID LPAR args-list RPAR .

    $default  reduce using rule 185 (var-obj)


State 299

  110 var-declr: VAR ID COLON var-type ASSIGN . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 37
    expr             go to state 339
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 300

  111 var-declr: VAR ID COLON var-type LBRACKET . RBRACKET
  112          | VAR ID COLON var-type LBRACKET . RBRACKET ASSIGN expr

    RBRACKET  shift, and go to state 340


State 301

   58 while-stmt: WHILE LPAR assign-expr RPAR LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 2 (line)

    line             go to state 341
    stmt-list        go to state 30
    stmt             go to state 31
    assign-expr      go to state 32
    for-stmt         go to state 33
    do-while-stmt    go to state 34
    while-stmt       go to state 35
    if-stmt          go to state 36
    logic-expr       go to state 37
    class-def        go to state 38
    func-def         go to state 39
    var-declr        go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 302

   57 while-stmt: WHILE LPAR expr RPAR LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 2 (line)

    line             go to state 342
    stmt-list        go to state 30
    stmt             go to state 31
    assign-expr      go to state 32
    for-stmt         go to state 33
    do-while-stmt    go to state 34
    while-stmt       go to state 35
    if-stmt          go to state 36
    logic-expr       go to state 37
    class-def        go to state 38
    func-def         go to state 39
    var-declr        go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 303

  184 var-obj: ID LT var-type GT LPAR args-list . RPAR

    RPAR  shift, and go to state 343


State 304

   82 class-att: ID COLON var-type .

    $default  reduce using rule 82 (class-att)


State 305

   84 class-att: ID LPAR params . RPAR LBRACE line RBRACE
   85          | ID LPAR params . RPAR COLON var-type LBRACE line RBRACE

    RPAR  shift, and go to state 344


State 306

   79 class-att-list: class-att SEMI class-att-list .

    $default  reduce using rule 79 (class-att-list)


State 307

   83 class-att: access-modif ID COLON . var-type

    VOID_RW   shift, and go to state 154
    ANY       shift, and go to state 155
    BOOLTYPE  shift, and go to state 156
    NEVER     shift, and go to state 157
    NUMBER    shift, and go to state 158
    STRING    shift, and go to state 159
    UNKNOWN   shift, and go to state 160

    var-type  go to state 345


State 308

   65 logic-expr: expr . EQ expr
   66           | expr . EQ_STRICT expr
   67           | expr . INEQ expr
   68           | expr . INEQ_STRICT expr
   69           | expr . LT expr
   71           | expr . LT_EQ expr
   72           | expr . GT expr
   73           | expr . GT_EQ expr
   74           | expr . LOGICAL_NULL expr
   75           | expr . LOGICAL_AND expr
   76           | expr . LOGICAL_OR expr
  114 var-declr: CONST_RW ID COLON var-type ASSIGN expr .
  157 arit-expr: expr . PLUS expr
  158          | expr . SUB expr
  159          | expr . MULT expr
  160          | expr . DIV expr
  161          | expr . EXP expr
  162          | expr . REM expr
  163 bitw-expr: expr . BITWISE_AND expr
  164          | expr . BITWISE_OR expr
  165          | expr . BITWISE_XOR expr
  166 shift-expr: expr . LSHIFT expr
  167           | expr . RSHIFT expr
  168           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 117
    SUB              shift, and go to state 118
    MULT             shift, and go to state 119
    DIV              shift, and go to state 120
    EXP              shift, and go to state 121
    REM              shift, and go to state 122
    BITWISE_AND      shift, and go to state 123
    BITWISE_OR       shift, and go to state 124
    BITWISE_XOR      shift, and go to state 125
    LOGICAL_NULL     shift, and go to state 126
    LOGICAL_AND      shift, and go to state 127
    LOGICAL_OR       shift, and go to state 128
    EQ               shift, and go to state 129
    EQ_STRICT        shift, and go to state 130
    INEQ             shift, and go to state 131
    INEQ_STRICT      shift, and go to state 132
    LT               shift, and go to state 133
    LT_EQ            shift, and go to state 134
    GT               shift, and go to state 135
    GT_EQ            shift, and go to state 136
    LSHIFT           shift, and go to state 137
    RSHIFT           shift, and go to state 138
    RSHIFT_UNSIGNED  shift, and go to state 139

    $default  reduce using rule 114 (var-declr)


State 309

  115 var-declr: CONST_RW ID COLON var-type LBRACKET RBRACKET . ASSIGN expr

    ASSIGN  shift, and go to state 346


State 310

  120 obj-att-list: COMMA obj-att-list .

    $default  reduce using rule 120 (obj-att-list)


State 311

  124 obj-att: ID COLON . var-val

    SUB        shift, and go to state 2
    INT_VAL    shift, and go to state 8
    REAL_VAL   shift, and go to state 9
    STR_VAL    shift, and go to state 10
    FALSE_RW   shift, and go to state 17
    NULL_RW    shift, and go to state 23
    TRUE_RW    shift, and go to state 25
    UNDEFINED  shift, and go to state 28

    var-val  go to state 347


State 312

  119 obj-def: LBRACE obj-att-list RBRACE .

    $default  reduce using rule 119 (obj-def)


State 313

  121 obj-att-list: obj-att COMMA . obj-att-list

    COMMA  shift, and go to state 276
    ID     shift, and go to state 277

    $default  reduce using rule 123 (obj-att-list)

    obj-att-list  go to state 348
    obj-att       go to state 279


State 314

   55 do-while-stmt: DO LBRACE line RBRACE WHILE LPAR . expr RPAR
   56              | DO LBRACE line RBRACE WHILE LPAR . assign-expr RPAR

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    assign-expr      go to state 349
    logic-expr       go to state 37
    expr             go to state 350
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 315

   38 for-stmt: FOR LPAR SEMI SEMI RPAR LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 2 (line)

    line             go to state 351
    stmt-list        go to state 30
    stmt             go to state 31
    assign-expr      go to state 32
    for-stmt         go to state 33
    do-while-stmt    go to state 34
    while-stmt       go to state 35
    if-stmt          go to state 36
    logic-expr       go to state 37
    class-def        go to state 38
    func-def         go to state 39
    var-declr        go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 316

   37 for-stmt: FOR LPAR SEMI SEMI assign-expr RPAR . LBRACE line RBRACE

    LBRACE  shift, and go to state 352


State 317

   36 for-stmt: FOR LPAR SEMI SEMI expr RPAR . LBRACE line RBRACE

    LBRACE  shift, and go to state 353


State 318

   35 for-stmt: FOR LPAR SEMI expr SEMI RPAR . LBRACE line RBRACE

    LBRACE  shift, and go to state 354


State 319

   34 for-stmt: FOR LPAR SEMI expr SEMI assign-expr . RPAR LBRACE line RBRACE

    RPAR  shift, and go to state 355


State 320

   33 for-stmt: FOR LPAR SEMI expr SEMI expr . RPAR LBRACE line RBRACE
   65 logic-expr: expr . EQ expr
   66           | expr . EQ_STRICT expr
   67           | expr . INEQ expr
   68           | expr . INEQ_STRICT expr
   69           | expr . LT expr
   71           | expr . LT_EQ expr
   72           | expr . GT expr
   73           | expr . GT_EQ expr
   74           | expr . LOGICAL_NULL expr
   75           | expr . LOGICAL_AND expr
   76           | expr . LOGICAL_OR expr
  157 arit-expr: expr . PLUS expr
  158          | expr . SUB expr
  159          | expr . MULT expr
  160          | expr . DIV expr
  161          | expr . EXP expr
  162          | expr . REM expr
  163 bitw-expr: expr . BITWISE_AND expr
  164          | expr . BITWISE_OR expr
  165          | expr . BITWISE_XOR expr
  166 shift-expr: expr . LSHIFT expr
  167           | expr . RSHIFT expr
  168           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 117
    SUB              shift, and go to state 118
    MULT             shift, and go to state 119
    DIV              shift, and go to state 120
    EXP              shift, and go to state 121
    REM              shift, and go to state 122
    BITWISE_AND      shift, and go to state 123
    BITWISE_OR       shift, and go to state 124
    BITWISE_XOR      shift, and go to state 125
    LOGICAL_NULL     shift, and go to state 126
    LOGICAL_AND      shift, and go to state 127
    LOGICAL_OR       shift, and go to state 128
    EQ               shift, and go to state 129
    EQ_STRICT        shift, and go to state 130
    INEQ             shift, and go to state 131
    INEQ_STRICT      shift, and go to state 132
    LT               shift, and go to state 133
    LT_EQ            shift, and go to state 134
    GT               shift, and go to state 135
    GT_EQ            shift, and go to state 136
    LSHIFT           shift, and go to state 137
    RSHIFT           shift, and go to state 138
    RSHIFT_UNSIGNED  shift, and go to state 139
    RPAR             shift, and go to state 356


State 321

   26 for-stmt: FOR LPAR assign-expr SEMI SEMI RPAR . LBRACE line RBRACE

    LBRACE  shift, and go to state 357


State 322

   25 for-stmt: FOR LPAR assign-expr SEMI SEMI assign-expr . RPAR LBRACE line RBRACE

    RPAR  shift, and go to state 358


State 323

   24 for-stmt: FOR LPAR assign-expr SEMI SEMI expr . RPAR LBRACE line RBRACE
   65 logic-expr: expr . EQ expr
   66           | expr . EQ_STRICT expr
   67           | expr . INEQ expr
   68           | expr . INEQ_STRICT expr
   69           | expr . LT expr
   71           | expr . LT_EQ expr
   72           | expr . GT expr
   73           | expr . GT_EQ expr
   74           | expr . LOGICAL_NULL expr
   75           | expr . LOGICAL_AND expr
   76           | expr . LOGICAL_OR expr
  157 arit-expr: expr . PLUS expr
  158          | expr . SUB expr
  159          | expr . MULT expr
  160          | expr . DIV expr
  161          | expr . EXP expr
  162          | expr . REM expr
  163 bitw-expr: expr . BITWISE_AND expr
  164          | expr . BITWISE_OR expr
  165          | expr . BITWISE_XOR expr
  166 shift-expr: expr . LSHIFT expr
  167           | expr . RSHIFT expr
  168           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 117
    SUB              shift, and go to state 118
    MULT             shift, and go to state 119
    DIV              shift, and go to state 120
    EXP              shift, and go to state 121
    REM              shift, and go to state 122
    BITWISE_AND      shift, and go to state 123
    BITWISE_OR       shift, and go to state 124
    BITWISE_XOR      shift, and go to state 125
    LOGICAL_NULL     shift, and go to state 126
    LOGICAL_AND      shift, and go to state 127
    LOGICAL_OR       shift, and go to state 128
    EQ               shift, and go to state 129
    EQ_STRICT        shift, and go to state 130
    INEQ             shift, and go to state 131
    INEQ_STRICT      shift, and go to state 132
    LT               shift, and go to state 133
    LT_EQ            shift, and go to state 134
    GT               shift, and go to state 135
    GT_EQ            shift, and go to state 136
    LSHIFT           shift, and go to state 137
    RSHIFT           shift, and go to state 138
    RSHIFT_UNSIGNED  shift, and go to state 139
    RPAR             shift, and go to state 359


State 324

   21 for-stmt: FOR LPAR assign-expr SEMI expr SEMI . expr RPAR LBRACE line RBRACE
   22         | FOR LPAR assign-expr SEMI expr SEMI . assign-expr RPAR LBRACE line RBRACE
   23         | FOR LPAR assign-expr SEMI expr SEMI . RPAR LBRACE line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    RPAR         shift, and go to state 360
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    assign-expr      go to state 361
    logic-expr       go to state 37
    expr             go to state 362
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 325

   32 for-stmt: FOR LPAR var-declr SEMI SEMI RPAR . LBRACE line RBRACE

    LBRACE  shift, and go to state 363


State 326

   31 for-stmt: FOR LPAR var-declr SEMI SEMI assign-expr . RPAR LBRACE line RBRACE

    RPAR  shift, and go to state 364


State 327

   30 for-stmt: FOR LPAR var-declr SEMI SEMI expr . RPAR LBRACE line RBRACE
   65 logic-expr: expr . EQ expr
   66           | expr . EQ_STRICT expr
   67           | expr . INEQ expr
   68           | expr . INEQ_STRICT expr
   69           | expr . LT expr
   71           | expr . LT_EQ expr
   72           | expr . GT expr
   73           | expr . GT_EQ expr
   74           | expr . LOGICAL_NULL expr
   75           | expr . LOGICAL_AND expr
   76           | expr . LOGICAL_OR expr
  157 arit-expr: expr . PLUS expr
  158          | expr . SUB expr
  159          | expr . MULT expr
  160          | expr . DIV expr
  161          | expr . EXP expr
  162          | expr . REM expr
  163 bitw-expr: expr . BITWISE_AND expr
  164          | expr . BITWISE_OR expr
  165          | expr . BITWISE_XOR expr
  166 shift-expr: expr . LSHIFT expr
  167           | expr . RSHIFT expr
  168           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 117
    SUB              shift, and go to state 118
    MULT             shift, and go to state 119
    DIV              shift, and go to state 120
    EXP              shift, and go to state 121
    REM              shift, and go to state 122
    BITWISE_AND      shift, and go to state 123
    BITWISE_OR       shift, and go to state 124
    BITWISE_XOR      shift, and go to state 125
    LOGICAL_NULL     shift, and go to state 126
    LOGICAL_AND      shift, and go to state 127
    LOGICAL_OR       shift, and go to state 128
    EQ               shift, and go to state 129
    EQ_STRICT        shift, and go to state 130
    INEQ             shift, and go to state 131
    INEQ_STRICT      shift, and go to state 132
    LT               shift, and go to state 133
    LT_EQ            shift, and go to state 134
    GT               shift, and go to state 135
    GT_EQ            shift, and go to state 136
    LSHIFT           shift, and go to state 137
    RSHIFT           shift, and go to state 138
    RSHIFT_UNSIGNED  shift, and go to state 139
    RPAR             shift, and go to state 365


State 328

   27 for-stmt: FOR LPAR var-declr SEMI expr SEMI . expr RPAR LBRACE line RBRACE
   28         | FOR LPAR var-declr SEMI expr SEMI . assign-expr RPAR LBRACE line RBRACE
   29         | FOR LPAR var-declr SEMI expr SEMI . RPAR LBRACE line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    RPAR         shift, and go to state 366
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    assign-expr      go to state 367
    logic-expr       go to state 37
    expr             go to state 368
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 329

   92 params: COMMA ID COLON . var-type

    VOID_RW   shift, and go to state 154
    ANY       shift, and go to state 155
    BOOLTYPE  shift, and go to state 156
    NEVER     shift, and go to state 157
    NUMBER    shift, and go to state 158
    STRING    shift, and go to state 159
    UNKNOWN   shift, and go to state 160

    var-type  go to state 369


State 330

   93 params: ID COMMA ID .
   97       | ID COMMA ID . COLON var-type

    COLON  shift, and go to state 370

    $default  reduce using rule 93 (params)


State 331

   94 params: ID COLON var-type . COMMA ID COLON var-type
   95       | ID COLON var-type . COMMA ID
   96       | ID COLON var-type .

    COMMA  shift, and go to state 371

    $default  reduce using rule 96 (params)


State 332

   90 func-def: FUNCTION ID LPAR params RPAR COLON . var-type LBRACE line RBRACE

    VOID_RW   shift, and go to state 154
    ANY       shift, and go to state 155
    BOOLTYPE  shift, and go to state 156
    NEVER     shift, and go to state 157
    NUMBER    shift, and go to state 158
    STRING    shift, and go to state 159
    UNKNOWN   shift, and go to state 160

    var-type  go to state 372


State 333

   89 func-def: FUNCTION ID LPAR params RPAR LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 2 (line)

    line             go to state 373
    stmt-list        go to state 30
    stmt             go to state 31
    assign-expr      go to state 32
    for-stmt         go to state 33
    do-while-stmt    go to state 34
    while-stmt       go to state 35
    if-stmt          go to state 36
    logic-expr       go to state 37
    class-def        go to state 38
    func-def         go to state 39
    var-declr        go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 334

   62 if-stmt: IF LPAR assign-expr RPAR LBRACE line . RBRACE
   63        | IF LPAR assign-expr RPAR LBRACE line . RBRACE ELSE LBRACE line RBRACE
   64        | IF LPAR assign-expr RPAR LBRACE line . RBRACE ELSE stmt

    RBRACE  shift, and go to state 374


State 335

   59 if-stmt: IF LPAR expr RPAR LBRACE line . RBRACE
   60        | IF LPAR expr RPAR LBRACE line . RBRACE ELSE LBRACE line RBRACE
   61        | IF LPAR expr RPAR LBRACE line . RBRACE ELSE stmt

    RBRACE  shift, and go to state 375


State 336

   65 logic-expr: expr . EQ expr
   66           | expr . EQ_STRICT expr
   67           | expr . INEQ expr
   68           | expr . INEQ_STRICT expr
   69           | expr . LT expr
   71           | expr . LT_EQ expr
   72           | expr . GT expr
   73           | expr . GT_EQ expr
   74           | expr . LOGICAL_NULL expr
   75           | expr . LOGICAL_AND expr
   76           | expr . LOGICAL_OR expr
  103 var-declr: LET ID COLON var-type ASSIGN expr .
  157 arit-expr: expr . PLUS expr
  158          | expr . SUB expr
  159          | expr . MULT expr
  160          | expr . DIV expr
  161          | expr . EXP expr
  162          | expr . REM expr
  163 bitw-expr: expr . BITWISE_AND expr
  164          | expr . BITWISE_OR expr
  165          | expr . BITWISE_XOR expr
  166 shift-expr: expr . LSHIFT expr
  167           | expr . RSHIFT expr
  168           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 117
    SUB              shift, and go to state 118
    MULT             shift, and go to state 119
    DIV              shift, and go to state 120
    EXP              shift, and go to state 121
    REM              shift, and go to state 122
    BITWISE_AND      shift, and go to state 123
    BITWISE_OR       shift, and go to state 124
    BITWISE_XOR      shift, and go to state 125
    LOGICAL_NULL     shift, and go to state 126
    LOGICAL_AND      shift, and go to state 127
    LOGICAL_OR       shift, and go to state 128
    EQ               shift, and go to state 129
    EQ_STRICT        shift, and go to state 130
    INEQ             shift, and go to state 131
    INEQ_STRICT      shift, and go to state 132
    LT               shift, and go to state 133
    LT_EQ            shift, and go to state 134
    GT               shift, and go to state 135
    GT_EQ            shift, and go to state 136
    LSHIFT           shift, and go to state 137
    RSHIFT           shift, and go to state 138
    RSHIFT_UNSIGNED  shift, and go to state 139

    $default  reduce using rule 103 (var-declr)


State 337

  104 var-declr: LET ID COLON var-type LBRACKET RBRACKET .
  105          | LET ID COLON var-type LBRACKET RBRACKET . ASSIGN expr

    ASSIGN  shift, and go to state 376

    $default  reduce using rule 104 (var-declr)


State 338

  186 var-obj: NEW ID LT var-type GT LPAR . args-list RPAR

    COMMA        shift, and go to state 163
    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 182 (args-list)

    assign-expr      go to state 164
    logic-expr       go to state 37
    expr             go to state 165
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    args-list        go to state 377
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 339

   65 logic-expr: expr . EQ expr
   66           | expr . EQ_STRICT expr
   67           | expr . INEQ expr
   68           | expr . INEQ_STRICT expr
   69           | expr . LT expr
   71           | expr . LT_EQ expr
   72           | expr . GT expr
   73           | expr . GT_EQ expr
   74           | expr . LOGICAL_NULL expr
   75           | expr . LOGICAL_AND expr
   76           | expr . LOGICAL_OR expr
  110 var-declr: VAR ID COLON var-type ASSIGN expr .
  157 arit-expr: expr . PLUS expr
  158          | expr . SUB expr
  159          | expr . MULT expr
  160          | expr . DIV expr
  161          | expr . EXP expr
  162          | expr . REM expr
  163 bitw-expr: expr . BITWISE_AND expr
  164          | expr . BITWISE_OR expr
  165          | expr . BITWISE_XOR expr
  166 shift-expr: expr . LSHIFT expr
  167           | expr . RSHIFT expr
  168           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 117
    SUB              shift, and go to state 118
    MULT             shift, and go to state 119
    DIV              shift, and go to state 120
    EXP              shift, and go to state 121
    REM              shift, and go to state 122
    BITWISE_AND      shift, and go to state 123
    BITWISE_OR       shift, and go to state 124
    BITWISE_XOR      shift, and go to state 125
    LOGICAL_NULL     shift, and go to state 126
    LOGICAL_AND      shift, and go to state 127
    LOGICAL_OR       shift, and go to state 128
    EQ               shift, and go to state 129
    EQ_STRICT        shift, and go to state 130
    INEQ             shift, and go to state 131
    INEQ_STRICT      shift, and go to state 132
    LT               shift, and go to state 133
    LT_EQ            shift, and go to state 134
    GT               shift, and go to state 135
    GT_EQ            shift, and go to state 136
    LSHIFT           shift, and go to state 137
    RSHIFT           shift, and go to state 138
    RSHIFT_UNSIGNED  shift, and go to state 139

    $default  reduce using rule 110 (var-declr)


State 340

  111 var-declr: VAR ID COLON var-type LBRACKET RBRACKET .
  112          | VAR ID COLON var-type LBRACKET RBRACKET . ASSIGN expr

    ASSIGN  shift, and go to state 378

    $default  reduce using rule 111 (var-declr)


State 341

   58 while-stmt: WHILE LPAR assign-expr RPAR LBRACE line . RBRACE

    RBRACE  shift, and go to state 379


State 342

   57 while-stmt: WHILE LPAR expr RPAR LBRACE line . RBRACE

    RBRACE  shift, and go to state 380


State 343

  184 var-obj: ID LT var-type GT LPAR args-list RPAR .

    $default  reduce using rule 184 (var-obj)


State 344

   84 class-att: ID LPAR params RPAR . LBRACE line RBRACE
   85          | ID LPAR params RPAR . COLON var-type LBRACE line RBRACE

    COLON   shift, and go to state 381
    LBRACE  shift, and go to state 382


State 345

   83 class-att: access-modif ID COLON var-type .

    $default  reduce using rule 83 (class-att)


State 346

  115 var-declr: CONST_RW ID COLON var-type LBRACKET RBRACKET ASSIGN . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 37
    expr             go to state 383
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 347

  124 obj-att: ID COLON var-val .

    $default  reduce using rule 124 (obj-att)


State 348

  121 obj-att-list: obj-att COMMA obj-att-list .

    $default  reduce using rule 121 (obj-att-list)


State 349

   56 do-while-stmt: DO LBRACE line RBRACE WHILE LPAR assign-expr . RPAR

    RPAR  shift, and go to state 384


State 350

   55 do-while-stmt: DO LBRACE line RBRACE WHILE LPAR expr . RPAR
   65 logic-expr: expr . EQ expr
   66           | expr . EQ_STRICT expr
   67           | expr . INEQ expr
   68           | expr . INEQ_STRICT expr
   69           | expr . LT expr
   71           | expr . LT_EQ expr
   72           | expr . GT expr
   73           | expr . GT_EQ expr
   74           | expr . LOGICAL_NULL expr
   75           | expr . LOGICAL_AND expr
   76           | expr . LOGICAL_OR expr
  157 arit-expr: expr . PLUS expr
  158          | expr . SUB expr
  159          | expr . MULT expr
  160          | expr . DIV expr
  161          | expr . EXP expr
  162          | expr . REM expr
  163 bitw-expr: expr . BITWISE_AND expr
  164          | expr . BITWISE_OR expr
  165          | expr . BITWISE_XOR expr
  166 shift-expr: expr . LSHIFT expr
  167           | expr . RSHIFT expr
  168           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 117
    SUB              shift, and go to state 118
    MULT             shift, and go to state 119
    DIV              shift, and go to state 120
    EXP              shift, and go to state 121
    REM              shift, and go to state 122
    BITWISE_AND      shift, and go to state 123
    BITWISE_OR       shift, and go to state 124
    BITWISE_XOR      shift, and go to state 125
    LOGICAL_NULL     shift, and go to state 126
    LOGICAL_AND      shift, and go to state 127
    LOGICAL_OR       shift, and go to state 128
    EQ               shift, and go to state 129
    EQ_STRICT        shift, and go to state 130
    INEQ             shift, and go to state 131
    INEQ_STRICT      shift, and go to state 132
    LT               shift, and go to state 133
    LT_EQ            shift, and go to state 134
    GT               shift, and go to state 135
    GT_EQ            shift, and go to state 136
    LSHIFT           shift, and go to state 137
    RSHIFT           shift, and go to state 138
    RSHIFT_UNSIGNED  shift, and go to state 139
    RPAR             shift, and go to state 385


State 351

   38 for-stmt: FOR LPAR SEMI SEMI RPAR LBRACE line . RBRACE

    RBRACE  shift, and go to state 386


State 352

   37 for-stmt: FOR LPAR SEMI SEMI assign-expr RPAR LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 2 (line)

    line             go to state 387
    stmt-list        go to state 30
    stmt             go to state 31
    assign-expr      go to state 32
    for-stmt         go to state 33
    do-while-stmt    go to state 34
    while-stmt       go to state 35
    if-stmt          go to state 36
    logic-expr       go to state 37
    class-def        go to state 38
    func-def         go to state 39
    var-declr        go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 353

   36 for-stmt: FOR LPAR SEMI SEMI expr RPAR LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 2 (line)

    line             go to state 388
    stmt-list        go to state 30
    stmt             go to state 31
    assign-expr      go to state 32
    for-stmt         go to state 33
    do-while-stmt    go to state 34
    while-stmt       go to state 35
    if-stmt          go to state 36
    logic-expr       go to state 37
    class-def        go to state 38
    func-def         go to state 39
    var-declr        go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 354

   35 for-stmt: FOR LPAR SEMI expr SEMI RPAR LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 2 (line)

    line             go to state 389
    stmt-list        go to state 30
    stmt             go to state 31
    assign-expr      go to state 32
    for-stmt         go to state 33
    do-while-stmt    go to state 34
    while-stmt       go to state 35
    if-stmt          go to state 36
    logic-expr       go to state 37
    class-def        go to state 38
    func-def         go to state 39
    var-declr        go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 355

   34 for-stmt: FOR LPAR SEMI expr SEMI assign-expr RPAR . LBRACE line RBRACE

    LBRACE  shift, and go to state 390


State 356

   33 for-stmt: FOR LPAR SEMI expr SEMI expr RPAR . LBRACE line RBRACE

    LBRACE  shift, and go to state 391


State 357

   26 for-stmt: FOR LPAR assign-expr SEMI SEMI RPAR LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 2 (line)

    line             go to state 392
    stmt-list        go to state 30
    stmt             go to state 31
    assign-expr      go to state 32
    for-stmt         go to state 33
    do-while-stmt    go to state 34
    while-stmt       go to state 35
    if-stmt          go to state 36
    logic-expr       go to state 37
    class-def        go to state 38
    func-def         go to state 39
    var-declr        go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 358

   25 for-stmt: FOR LPAR assign-expr SEMI SEMI assign-expr RPAR . LBRACE line RBRACE

    LBRACE  shift, and go to state 393


State 359

   24 for-stmt: FOR LPAR assign-expr SEMI SEMI expr RPAR . LBRACE line RBRACE

    LBRACE  shift, and go to state 394


State 360

   23 for-stmt: FOR LPAR assign-expr SEMI expr SEMI RPAR . LBRACE line RBRACE

    LBRACE  shift, and go to state 395


State 361

   22 for-stmt: FOR LPAR assign-expr SEMI expr SEMI assign-expr . RPAR LBRACE line RBRACE

    RPAR  shift, and go to state 396


State 362

   21 for-stmt: FOR LPAR assign-expr SEMI expr SEMI expr . RPAR LBRACE line RBRACE
   65 logic-expr: expr . EQ expr
   66           | expr . EQ_STRICT expr
   67           | expr . INEQ expr
   68           | expr . INEQ_STRICT expr
   69           | expr . LT expr
   71           | expr . LT_EQ expr
   72           | expr . GT expr
   73           | expr . GT_EQ expr
   74           | expr . LOGICAL_NULL expr
   75           | expr . LOGICAL_AND expr
   76           | expr . LOGICAL_OR expr
  157 arit-expr: expr . PLUS expr
  158          | expr . SUB expr
  159          | expr . MULT expr
  160          | expr . DIV expr
  161          | expr . EXP expr
  162          | expr . REM expr
  163 bitw-expr: expr . BITWISE_AND expr
  164          | expr . BITWISE_OR expr
  165          | expr . BITWISE_XOR expr
  166 shift-expr: expr . LSHIFT expr
  167           | expr . RSHIFT expr
  168           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 117
    SUB              shift, and go to state 118
    MULT             shift, and go to state 119
    DIV              shift, and go to state 120
    EXP              shift, and go to state 121
    REM              shift, and go to state 122
    BITWISE_AND      shift, and go to state 123
    BITWISE_OR       shift, and go to state 124
    BITWISE_XOR      shift, and go to state 125
    LOGICAL_NULL     shift, and go to state 126
    LOGICAL_AND      shift, and go to state 127
    LOGICAL_OR       shift, and go to state 128
    EQ               shift, and go to state 129
    EQ_STRICT        shift, and go to state 130
    INEQ             shift, and go to state 131
    INEQ_STRICT      shift, and go to state 132
    LT               shift, and go to state 133
    LT_EQ            shift, and go to state 134
    GT               shift, and go to state 135
    GT_EQ            shift, and go to state 136
    LSHIFT           shift, and go to state 137
    RSHIFT           shift, and go to state 138
    RSHIFT_UNSIGNED  shift, and go to state 139
    RPAR             shift, and go to state 397


State 363

   32 for-stmt: FOR LPAR var-declr SEMI SEMI RPAR LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 2 (line)

    line             go to state 398
    stmt-list        go to state 30
    stmt             go to state 31
    assign-expr      go to state 32
    for-stmt         go to state 33
    do-while-stmt    go to state 34
    while-stmt       go to state 35
    if-stmt          go to state 36
    logic-expr       go to state 37
    class-def        go to state 38
    func-def         go to state 39
    var-declr        go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 364

   31 for-stmt: FOR LPAR var-declr SEMI SEMI assign-expr RPAR . LBRACE line RBRACE

    LBRACE  shift, and go to state 399


State 365

   30 for-stmt: FOR LPAR var-declr SEMI SEMI expr RPAR . LBRACE line RBRACE

    LBRACE  shift, and go to state 400


State 366

   29 for-stmt: FOR LPAR var-declr SEMI expr SEMI RPAR . LBRACE line RBRACE

    LBRACE  shift, and go to state 401


State 367

   28 for-stmt: FOR LPAR var-declr SEMI expr SEMI assign-expr . RPAR LBRACE line RBRACE

    RPAR  shift, and go to state 402


State 368

   27 for-stmt: FOR LPAR var-declr SEMI expr SEMI expr . RPAR LBRACE line RBRACE
   65 logic-expr: expr . EQ expr
   66           | expr . EQ_STRICT expr
   67           | expr . INEQ expr
   68           | expr . INEQ_STRICT expr
   69           | expr . LT expr
   71           | expr . LT_EQ expr
   72           | expr . GT expr
   73           | expr . GT_EQ expr
   74           | expr . LOGICAL_NULL expr
   75           | expr . LOGICAL_AND expr
   76           | expr . LOGICAL_OR expr
  157 arit-expr: expr . PLUS expr
  158          | expr . SUB expr
  159          | expr . MULT expr
  160          | expr . DIV expr
  161          | expr . EXP expr
  162          | expr . REM expr
  163 bitw-expr: expr . BITWISE_AND expr
  164          | expr . BITWISE_OR expr
  165          | expr . BITWISE_XOR expr
  166 shift-expr: expr . LSHIFT expr
  167           | expr . RSHIFT expr
  168           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 117
    SUB              shift, and go to state 118
    MULT             shift, and go to state 119
    DIV              shift, and go to state 120
    EXP              shift, and go to state 121
    REM              shift, and go to state 122
    BITWISE_AND      shift, and go to state 123
    BITWISE_OR       shift, and go to state 124
    BITWISE_XOR      shift, and go to state 125
    LOGICAL_NULL     shift, and go to state 126
    LOGICAL_AND      shift, and go to state 127
    LOGICAL_OR       shift, and go to state 128
    EQ               shift, and go to state 129
    EQ_STRICT        shift, and go to state 130
    INEQ             shift, and go to state 131
    INEQ_STRICT      shift, and go to state 132
    LT               shift, and go to state 133
    LT_EQ            shift, and go to state 134
    GT               shift, and go to state 135
    GT_EQ            shift, and go to state 136
    LSHIFT           shift, and go to state 137
    RSHIFT           shift, and go to state 138
    RSHIFT_UNSIGNED  shift, and go to state 139
    RPAR             shift, and go to state 403


State 369

   92 params: COMMA ID COLON var-type .

    $default  reduce using rule 92 (params)


State 370

   97 params: ID COMMA ID COLON . var-type

    VOID_RW   shift, and go to state 154
    ANY       shift, and go to state 155
    BOOLTYPE  shift, and go to state 156
    NEVER     shift, and go to state 157
    NUMBER    shift, and go to state 158
    STRING    shift, and go to state 159
    UNKNOWN   shift, and go to state 160

    var-type  go to state 404


State 371

   94 params: ID COLON var-type COMMA . ID COLON var-type
   95       | ID COLON var-type COMMA . ID

    ID  shift, and go to state 405


State 372

   90 func-def: FUNCTION ID LPAR params RPAR COLON var-type . LBRACE line RBRACE

    LBRACE  shift, and go to state 406


State 373

   89 func-def: FUNCTION ID LPAR params RPAR LBRACE line . RBRACE

    RBRACE  shift, and go to state 407


State 374

   62 if-stmt: IF LPAR assign-expr RPAR LBRACE line RBRACE .
   63        | IF LPAR assign-expr RPAR LBRACE line RBRACE . ELSE LBRACE line RBRACE
   64        | IF LPAR assign-expr RPAR LBRACE line RBRACE . ELSE stmt

    ELSE  shift, and go to state 408

    $default  reduce using rule 62 (if-stmt)


State 375

   59 if-stmt: IF LPAR expr RPAR LBRACE line RBRACE .
   60        | IF LPAR expr RPAR LBRACE line RBRACE . ELSE LBRACE line RBRACE
   61        | IF LPAR expr RPAR LBRACE line RBRACE . ELSE stmt

    ELSE  shift, and go to state 409

    $default  reduce using rule 59 (if-stmt)


State 376

  105 var-declr: LET ID COLON var-type LBRACKET RBRACKET ASSIGN . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 37
    expr             go to state 410
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 377

  186 var-obj: NEW ID LT var-type GT LPAR args-list . RPAR

    RPAR  shift, and go to state 411


State 378

  112 var-declr: VAR ID COLON var-type LBRACKET RBRACKET ASSIGN . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 37
    expr             go to state 412
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 379

   58 while-stmt: WHILE LPAR assign-expr RPAR LBRACE line RBRACE .

    $default  reduce using rule 58 (while-stmt)


State 380

   57 while-stmt: WHILE LPAR expr RPAR LBRACE line RBRACE .

    $default  reduce using rule 57 (while-stmt)


State 381

   85 class-att: ID LPAR params RPAR COLON . var-type LBRACE line RBRACE

    VOID_RW   shift, and go to state 154
    ANY       shift, and go to state 155
    BOOLTYPE  shift, and go to state 156
    NEVER     shift, and go to state 157
    NUMBER    shift, and go to state 158
    STRING    shift, and go to state 159
    UNKNOWN   shift, and go to state 160

    var-type  go to state 413


State 382

   84 class-att: ID LPAR params RPAR LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 2 (line)

    line             go to state 414
    stmt-list        go to state 30
    stmt             go to state 31
    assign-expr      go to state 32
    for-stmt         go to state 33
    do-while-stmt    go to state 34
    while-stmt       go to state 35
    if-stmt          go to state 36
    logic-expr       go to state 37
    class-def        go to state 38
    func-def         go to state 39
    var-declr        go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 383

   65 logic-expr: expr . EQ expr
   66           | expr . EQ_STRICT expr
   67           | expr . INEQ expr
   68           | expr . INEQ_STRICT expr
   69           | expr . LT expr
   71           | expr . LT_EQ expr
   72           | expr . GT expr
   73           | expr . GT_EQ expr
   74           | expr . LOGICAL_NULL expr
   75           | expr . LOGICAL_AND expr
   76           | expr . LOGICAL_OR expr
  115 var-declr: CONST_RW ID COLON var-type LBRACKET RBRACKET ASSIGN expr .
  157 arit-expr: expr . PLUS expr
  158          | expr . SUB expr
  159          | expr . MULT expr
  160          | expr . DIV expr
  161          | expr . EXP expr
  162          | expr . REM expr
  163 bitw-expr: expr . BITWISE_AND expr
  164          | expr . BITWISE_OR expr
  165          | expr . BITWISE_XOR expr
  166 shift-expr: expr . LSHIFT expr
  167           | expr . RSHIFT expr
  168           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 117
    SUB              shift, and go to state 118
    MULT             shift, and go to state 119
    DIV              shift, and go to state 120
    EXP              shift, and go to state 121
    REM              shift, and go to state 122
    BITWISE_AND      shift, and go to state 123
    BITWISE_OR       shift, and go to state 124
    BITWISE_XOR      shift, and go to state 125
    LOGICAL_NULL     shift, and go to state 126
    LOGICAL_AND      shift, and go to state 127
    LOGICAL_OR       shift, and go to state 128
    EQ               shift, and go to state 129
    EQ_STRICT        shift, and go to state 130
    INEQ             shift, and go to state 131
    INEQ_STRICT      shift, and go to state 132
    LT               shift, and go to state 133
    LT_EQ            shift, and go to state 134
    GT               shift, and go to state 135
    GT_EQ            shift, and go to state 136
    LSHIFT           shift, and go to state 137
    RSHIFT           shift, and go to state 138
    RSHIFT_UNSIGNED  shift, and go to state 139

    $default  reduce using rule 115 (var-declr)


State 384

   56 do-while-stmt: DO LBRACE line RBRACE WHILE LPAR assign-expr RPAR .

    $default  reduce using rule 56 (do-while-stmt)


State 385

   55 do-while-stmt: DO LBRACE line RBRACE WHILE LPAR expr RPAR .

    $default  reduce using rule 55 (do-while-stmt)


State 386

   38 for-stmt: FOR LPAR SEMI SEMI RPAR LBRACE line RBRACE .

    $default  reduce using rule 38 (for-stmt)


State 387

   37 for-stmt: FOR LPAR SEMI SEMI assign-expr RPAR LBRACE line . RBRACE

    RBRACE  shift, and go to state 415


State 388

   36 for-stmt: FOR LPAR SEMI SEMI expr RPAR LBRACE line . RBRACE

    RBRACE  shift, and go to state 416


State 389

   35 for-stmt: FOR LPAR SEMI expr SEMI RPAR LBRACE line . RBRACE

    RBRACE  shift, and go to state 417


State 390

   34 for-stmt: FOR LPAR SEMI expr SEMI assign-expr RPAR LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 2 (line)

    line             go to state 418
    stmt-list        go to state 30
    stmt             go to state 31
    assign-expr      go to state 32
    for-stmt         go to state 33
    do-while-stmt    go to state 34
    while-stmt       go to state 35
    if-stmt          go to state 36
    logic-expr       go to state 37
    class-def        go to state 38
    func-def         go to state 39
    var-declr        go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 391

   33 for-stmt: FOR LPAR SEMI expr SEMI expr RPAR LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 2 (line)

    line             go to state 419
    stmt-list        go to state 30
    stmt             go to state 31
    assign-expr      go to state 32
    for-stmt         go to state 33
    do-while-stmt    go to state 34
    while-stmt       go to state 35
    if-stmt          go to state 36
    logic-expr       go to state 37
    class-def        go to state 38
    func-def         go to state 39
    var-declr        go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 392

   26 for-stmt: FOR LPAR assign-expr SEMI SEMI RPAR LBRACE line . RBRACE

    RBRACE  shift, and go to state 420


State 393

   25 for-stmt: FOR LPAR assign-expr SEMI SEMI assign-expr RPAR LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 2 (line)

    line             go to state 421
    stmt-list        go to state 30
    stmt             go to state 31
    assign-expr      go to state 32
    for-stmt         go to state 33
    do-while-stmt    go to state 34
    while-stmt       go to state 35
    if-stmt          go to state 36
    logic-expr       go to state 37
    class-def        go to state 38
    func-def         go to state 39
    var-declr        go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 394

   24 for-stmt: FOR LPAR assign-expr SEMI SEMI expr RPAR LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 2 (line)

    line             go to state 422
    stmt-list        go to state 30
    stmt             go to state 31
    assign-expr      go to state 32
    for-stmt         go to state 33
    do-while-stmt    go to state 34
    while-stmt       go to state 35
    if-stmt          go to state 36
    logic-expr       go to state 37
    class-def        go to state 38
    func-def         go to state 39
    var-declr        go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 395

   23 for-stmt: FOR LPAR assign-expr SEMI expr SEMI RPAR LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 2 (line)

    line             go to state 423
    stmt-list        go to state 30
    stmt             go to state 31
    assign-expr      go to state 32
    for-stmt         go to state 33
    do-while-stmt    go to state 34
    while-stmt       go to state 35
    if-stmt          go to state 36
    logic-expr       go to state 37
    class-def        go to state 38
    func-def         go to state 39
    var-declr        go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 396

   22 for-stmt: FOR LPAR assign-expr SEMI expr SEMI assign-expr RPAR . LBRACE line RBRACE

    LBRACE  shift, and go to state 424


State 397

   21 for-stmt: FOR LPAR assign-expr SEMI expr SEMI expr RPAR . LBRACE line RBRACE

    LBRACE  shift, and go to state 425


State 398

   32 for-stmt: FOR LPAR var-declr SEMI SEMI RPAR LBRACE line . RBRACE

    RBRACE  shift, and go to state 426


State 399

   31 for-stmt: FOR LPAR var-declr SEMI SEMI assign-expr RPAR LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 2 (line)

    line             go to state 427
    stmt-list        go to state 30
    stmt             go to state 31
    assign-expr      go to state 32
    for-stmt         go to state 33
    do-while-stmt    go to state 34
    while-stmt       go to state 35
    if-stmt          go to state 36
    logic-expr       go to state 37
    class-def        go to state 38
    func-def         go to state 39
    var-declr        go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 400

   30 for-stmt: FOR LPAR var-declr SEMI SEMI expr RPAR LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 2 (line)

    line             go to state 428
    stmt-list        go to state 30
    stmt             go to state 31
    assign-expr      go to state 32
    for-stmt         go to state 33
    do-while-stmt    go to state 34
    while-stmt       go to state 35
    if-stmt          go to state 36
    logic-expr       go to state 37
    class-def        go to state 38
    func-def         go to state 39
    var-declr        go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 401

   29 for-stmt: FOR LPAR var-declr SEMI expr SEMI RPAR LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 2 (line)

    line             go to state 429
    stmt-list        go to state 30
    stmt             go to state 31
    assign-expr      go to state 32
    for-stmt         go to state 33
    do-while-stmt    go to state 34
    while-stmt       go to state 35
    if-stmt          go to state 36
    logic-expr       go to state 37
    class-def        go to state 38
    func-def         go to state 39
    var-declr        go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 402

   28 for-stmt: FOR LPAR var-declr SEMI expr SEMI assign-expr RPAR . LBRACE line RBRACE

    LBRACE  shift, and go to state 430


State 403

   27 for-stmt: FOR LPAR var-declr SEMI expr SEMI expr RPAR . LBRACE line RBRACE

    LBRACE  shift, and go to state 431


State 404

   97 params: ID COMMA ID COLON var-type .

    $default  reduce using rule 97 (params)


State 405

   94 params: ID COLON var-type COMMA ID . COLON var-type
   95       | ID COLON var-type COMMA ID .

    COLON  shift, and go to state 432

    $default  reduce using rule 95 (params)


State 406

   90 func-def: FUNCTION ID LPAR params RPAR COLON var-type LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 2 (line)

    line             go to state 433
    stmt-list        go to state 30
    stmt             go to state 31
    assign-expr      go to state 32
    for-stmt         go to state 33
    do-while-stmt    go to state 34
    while-stmt       go to state 35
    if-stmt          go to state 36
    logic-expr       go to state 37
    class-def        go to state 38
    func-def         go to state 39
    var-declr        go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 407

   89 func-def: FUNCTION ID LPAR params RPAR LBRACE line RBRACE .

    $default  reduce using rule 89 (func-def)


State 408

   63 if-stmt: IF LPAR assign-expr RPAR LBRACE line RBRACE ELSE . LBRACE line RBRACE
   64        | IF LPAR assign-expr RPAR LBRACE line RBRACE ELSE . stmt

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACE       shift, and go to state 434
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    stmt             go to state 435
    assign-expr      go to state 32
    for-stmt         go to state 33
    do-while-stmt    go to state 34
    while-stmt       go to state 35
    if-stmt          go to state 36
    logic-expr       go to state 37
    class-def        go to state 38
    func-def         go to state 39
    var-declr        go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 409

   60 if-stmt: IF LPAR expr RPAR LBRACE line RBRACE ELSE . LBRACE line RBRACE
   61        | IF LPAR expr RPAR LBRACE line RBRACE ELSE . stmt

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACE       shift, and go to state 436
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    stmt             go to state 437
    assign-expr      go to state 32
    for-stmt         go to state 33
    do-while-stmt    go to state 34
    while-stmt       go to state 35
    if-stmt          go to state 36
    logic-expr       go to state 37
    class-def        go to state 38
    func-def         go to state 39
    var-declr        go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 410

   65 logic-expr: expr . EQ expr
   66           | expr . EQ_STRICT expr
   67           | expr . INEQ expr
   68           | expr . INEQ_STRICT expr
   69           | expr . LT expr
   71           | expr . LT_EQ expr
   72           | expr . GT expr
   73           | expr . GT_EQ expr
   74           | expr . LOGICAL_NULL expr
   75           | expr . LOGICAL_AND expr
   76           | expr . LOGICAL_OR expr
  105 var-declr: LET ID COLON var-type LBRACKET RBRACKET ASSIGN expr .
  157 arit-expr: expr . PLUS expr
  158          | expr . SUB expr
  159          | expr . MULT expr
  160          | expr . DIV expr
  161          | expr . EXP expr
  162          | expr . REM expr
  163 bitw-expr: expr . BITWISE_AND expr
  164          | expr . BITWISE_OR expr
  165          | expr . BITWISE_XOR expr
  166 shift-expr: expr . LSHIFT expr
  167           | expr . RSHIFT expr
  168           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 117
    SUB              shift, and go to state 118
    MULT             shift, and go to state 119
    DIV              shift, and go to state 120
    EXP              shift, and go to state 121
    REM              shift, and go to state 122
    BITWISE_AND      shift, and go to state 123
    BITWISE_OR       shift, and go to state 124
    BITWISE_XOR      shift, and go to state 125
    LOGICAL_NULL     shift, and go to state 126
    LOGICAL_AND      shift, and go to state 127
    LOGICAL_OR       shift, and go to state 128
    EQ               shift, and go to state 129
    EQ_STRICT        shift, and go to state 130
    INEQ             shift, and go to state 131
    INEQ_STRICT      shift, and go to state 132
    LT               shift, and go to state 133
    LT_EQ            shift, and go to state 134
    GT               shift, and go to state 135
    GT_EQ            shift, and go to state 136
    LSHIFT           shift, and go to state 137
    RSHIFT           shift, and go to state 138
    RSHIFT_UNSIGNED  shift, and go to state 139

    $default  reduce using rule 105 (var-declr)


State 411

  186 var-obj: NEW ID LT var-type GT LPAR args-list RPAR .

    $default  reduce using rule 186 (var-obj)


State 412

   65 logic-expr: expr . EQ expr
   66           | expr . EQ_STRICT expr
   67           | expr . INEQ expr
   68           | expr . INEQ_STRICT expr
   69           | expr . LT expr
   71           | expr . LT_EQ expr
   72           | expr . GT expr
   73           | expr . GT_EQ expr
   74           | expr . LOGICAL_NULL expr
   75           | expr . LOGICAL_AND expr
   76           | expr . LOGICAL_OR expr
  112 var-declr: VAR ID COLON var-type LBRACKET RBRACKET ASSIGN expr .
  157 arit-expr: expr . PLUS expr
  158          | expr . SUB expr
  159          | expr . MULT expr
  160          | expr . DIV expr
  161          | expr . EXP expr
  162          | expr . REM expr
  163 bitw-expr: expr . BITWISE_AND expr
  164          | expr . BITWISE_OR expr
  165          | expr . BITWISE_XOR expr
  166 shift-expr: expr . LSHIFT expr
  167           | expr . RSHIFT expr
  168           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 117
    SUB              shift, and go to state 118
    MULT             shift, and go to state 119
    DIV              shift, and go to state 120
    EXP              shift, and go to state 121
    REM              shift, and go to state 122
    BITWISE_AND      shift, and go to state 123
    BITWISE_OR       shift, and go to state 124
    BITWISE_XOR      shift, and go to state 125
    LOGICAL_NULL     shift, and go to state 126
    LOGICAL_AND      shift, and go to state 127
    LOGICAL_OR       shift, and go to state 128
    EQ               shift, and go to state 129
    EQ_STRICT        shift, and go to state 130
    INEQ             shift, and go to state 131
    INEQ_STRICT      shift, and go to state 132
    LT               shift, and go to state 133
    LT_EQ            shift, and go to state 134
    GT               shift, and go to state 135
    GT_EQ            shift, and go to state 136
    LSHIFT           shift, and go to state 137
    RSHIFT           shift, and go to state 138
    RSHIFT_UNSIGNED  shift, and go to state 139

    $default  reduce using rule 112 (var-declr)


State 413

   85 class-att: ID LPAR params RPAR COLON var-type . LBRACE line RBRACE

    LBRACE  shift, and go to state 438


State 414

   84 class-att: ID LPAR params RPAR LBRACE line . RBRACE

    RBRACE  shift, and go to state 439


State 415

   37 for-stmt: FOR LPAR SEMI SEMI assign-expr RPAR LBRACE line RBRACE .

    $default  reduce using rule 37 (for-stmt)


State 416

   36 for-stmt: FOR LPAR SEMI SEMI expr RPAR LBRACE line RBRACE .

    $default  reduce using rule 36 (for-stmt)


State 417

   35 for-stmt: FOR LPAR SEMI expr SEMI RPAR LBRACE line RBRACE .

    $default  reduce using rule 35 (for-stmt)


State 418

   34 for-stmt: FOR LPAR SEMI expr SEMI assign-expr RPAR LBRACE line . RBRACE

    RBRACE  shift, and go to state 440


State 419

   33 for-stmt: FOR LPAR SEMI expr SEMI expr RPAR LBRACE line . RBRACE

    RBRACE  shift, and go to state 441


State 420

   26 for-stmt: FOR LPAR assign-expr SEMI SEMI RPAR LBRACE line RBRACE .

    $default  reduce using rule 26 (for-stmt)


State 421

   25 for-stmt: FOR LPAR assign-expr SEMI SEMI assign-expr RPAR LBRACE line . RBRACE

    RBRACE  shift, and go to state 442


State 422

   24 for-stmt: FOR LPAR assign-expr SEMI SEMI expr RPAR LBRACE line . RBRACE

    RBRACE  shift, and go to state 443


State 423

   23 for-stmt: FOR LPAR assign-expr SEMI expr SEMI RPAR LBRACE line . RBRACE

    RBRACE  shift, and go to state 444


State 424

   22 for-stmt: FOR LPAR assign-expr SEMI expr SEMI assign-expr RPAR LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 2 (line)

    line             go to state 445
    stmt-list        go to state 30
    stmt             go to state 31
    assign-expr      go to state 32
    for-stmt         go to state 33
    do-while-stmt    go to state 34
    while-stmt       go to state 35
    if-stmt          go to state 36
    logic-expr       go to state 37
    class-def        go to state 38
    func-def         go to state 39
    var-declr        go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 425

   21 for-stmt: FOR LPAR assign-expr SEMI expr SEMI expr RPAR LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 2 (line)

    line             go to state 446
    stmt-list        go to state 30
    stmt             go to state 31
    assign-expr      go to state 32
    for-stmt         go to state 33
    do-while-stmt    go to state 34
    while-stmt       go to state 35
    if-stmt          go to state 36
    logic-expr       go to state 37
    class-def        go to state 38
    func-def         go to state 39
    var-declr        go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 426

   32 for-stmt: FOR LPAR var-declr SEMI SEMI RPAR LBRACE line RBRACE .

    $default  reduce using rule 32 (for-stmt)


State 427

   31 for-stmt: FOR LPAR var-declr SEMI SEMI assign-expr RPAR LBRACE line . RBRACE

    RBRACE  shift, and go to state 447


State 428

   30 for-stmt: FOR LPAR var-declr SEMI SEMI expr RPAR LBRACE line . RBRACE

    RBRACE  shift, and go to state 448


State 429

   29 for-stmt: FOR LPAR var-declr SEMI expr SEMI RPAR LBRACE line . RBRACE

    RBRACE  shift, and go to state 449


State 430

   28 for-stmt: FOR LPAR var-declr SEMI expr SEMI assign-expr RPAR LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 2 (line)

    line             go to state 450
    stmt-list        go to state 30
    stmt             go to state 31
    assign-expr      go to state 32
    for-stmt         go to state 33
    do-while-stmt    go to state 34
    while-stmt       go to state 35
    if-stmt          go to state 36
    logic-expr       go to state 37
    class-def        go to state 38
    func-def         go to state 39
    var-declr        go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 431

   27 for-stmt: FOR LPAR var-declr SEMI expr SEMI expr RPAR LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 2 (line)

    line             go to state 451
    stmt-list        go to state 30
    stmt             go to state 31
    assign-expr      go to state 32
    for-stmt         go to state 33
    do-while-stmt    go to state 34
    while-stmt       go to state 35
    if-stmt          go to state 36
    logic-expr       go to state 37
    class-def        go to state 38
    func-def         go to state 39
    var-declr        go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 432

   94 params: ID COLON var-type COMMA ID COLON . var-type

    VOID_RW   shift, and go to state 154
    ANY       shift, and go to state 155
    BOOLTYPE  shift, and go to state 156
    NEVER     shift, and go to state 157
    NUMBER    shift, and go to state 158
    STRING    shift, and go to state 159
    UNKNOWN   shift, and go to state 160

    var-type  go to state 452


State 433

   90 func-def: FUNCTION ID LPAR params RPAR COLON var-type LBRACE line . RBRACE

    RBRACE  shift, and go to state 453


State 434

   63 if-stmt: IF LPAR assign-expr RPAR LBRACE line RBRACE ELSE LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 2 (line)

    line             go to state 454
    stmt-list        go to state 30
    stmt             go to state 31
    assign-expr      go to state 32
    for-stmt         go to state 33
    do-while-stmt    go to state 34
    while-stmt       go to state 35
    if-stmt          go to state 36
    logic-expr       go to state 37
    class-def        go to state 38
    func-def         go to state 39
    var-declr        go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 435

   64 if-stmt: IF LPAR assign-expr RPAR LBRACE line RBRACE ELSE stmt .

    $default  reduce using rule 64 (if-stmt)


State 436

   60 if-stmt: IF LPAR expr RPAR LBRACE line RBRACE ELSE LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 2 (line)

    line             go to state 455
    stmt-list        go to state 30
    stmt             go to state 31
    assign-expr      go to state 32
    for-stmt         go to state 33
    do-while-stmt    go to state 34
    while-stmt       go to state 35
    if-stmt          go to state 36
    logic-expr       go to state 37
    class-def        go to state 38
    func-def         go to state 39
    var-declr        go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 437

   61 if-stmt: IF LPAR expr RPAR LBRACE line RBRACE ELSE stmt .

    $default  reduce using rule 61 (if-stmt)


State 438

   85 class-att: ID LPAR params RPAR COLON var-type LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 2 (line)

    line             go to state 456
    stmt-list        go to state 30
    stmt             go to state 31
    assign-expr      go to state 32
    for-stmt         go to state 33
    do-while-stmt    go to state 34
    while-stmt       go to state 35
    if-stmt          go to state 36
    logic-expr       go to state 37
    class-def        go to state 38
    func-def         go to state 39
    var-declr        go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 439

   84 class-att: ID LPAR params RPAR LBRACE line RBRACE .

    $default  reduce using rule 84 (class-att)


State 440

   34 for-stmt: FOR LPAR SEMI expr SEMI assign-expr RPAR LBRACE line RBRACE .

    $default  reduce using rule 34 (for-stmt)


State 441

   33 for-stmt: FOR LPAR SEMI expr SEMI expr RPAR LBRACE line RBRACE .

    $default  reduce using rule 33 (for-stmt)


State 442

   25 for-stmt: FOR LPAR assign-expr SEMI SEMI assign-expr RPAR LBRACE line RBRACE .

    $default  reduce using rule 25 (for-stmt)


State 443

   24 for-stmt: FOR LPAR assign-expr SEMI SEMI expr RPAR LBRACE line RBRACE .

    $default  reduce using rule 24 (for-stmt)


State 444

   23 for-stmt: FOR LPAR assign-expr SEMI expr SEMI RPAR LBRACE line RBRACE .

    $default  reduce using rule 23 (for-stmt)


State 445

   22 for-stmt: FOR LPAR assign-expr SEMI expr SEMI assign-expr RPAR LBRACE line . RBRACE

    RBRACE  shift, and go to state 457


State 446

   21 for-stmt: FOR LPAR assign-expr SEMI expr SEMI expr RPAR LBRACE line . RBRACE

    RBRACE  shift, and go to state 458


State 447

   31 for-stmt: FOR LPAR var-declr SEMI SEMI assign-expr RPAR LBRACE line RBRACE .

    $default  reduce using rule 31 (for-stmt)


State 448

   30 for-stmt: FOR LPAR var-declr SEMI SEMI expr RPAR LBRACE line RBRACE .

    $default  reduce using rule 30 (for-stmt)


State 449

   29 for-stmt: FOR LPAR var-declr SEMI expr SEMI RPAR LBRACE line RBRACE .

    $default  reduce using rule 29 (for-stmt)


State 450

   28 for-stmt: FOR LPAR var-declr SEMI expr SEMI assign-expr RPAR LBRACE line . RBRACE

    RBRACE  shift, and go to state 459


State 451

   27 for-stmt: FOR LPAR var-declr SEMI expr SEMI expr RPAR LBRACE line . RBRACE

    RBRACE  shift, and go to state 460


State 452

   94 params: ID COLON var-type COMMA ID COLON var-type .

    $default  reduce using rule 94 (params)


State 453

   90 func-def: FUNCTION ID LPAR params RPAR COLON var-type LBRACE line RBRACE .

    $default  reduce using rule 90 (func-def)


State 454

   63 if-stmt: IF LPAR assign-expr RPAR LBRACE line RBRACE ELSE LBRACE line . RBRACE

    RBRACE  shift, and go to state 461


State 455

   60 if-stmt: IF LPAR expr RPAR LBRACE line RBRACE ELSE LBRACE line . RBRACE

    RBRACE  shift, and go to state 462


State 456

   85 class-att: ID LPAR params RPAR COLON var-type LBRACE line . RBRACE

    RBRACE  shift, and go to state 463


State 457

   22 for-stmt: FOR LPAR assign-expr SEMI expr SEMI assign-expr RPAR LBRACE line RBRACE .

    $default  reduce using rule 22 (for-stmt)


State 458

   21 for-stmt: FOR LPAR assign-expr SEMI expr SEMI expr RPAR LBRACE line RBRACE .

    $default  reduce using rule 21 (for-stmt)


State 459

   28 for-stmt: FOR LPAR var-declr SEMI expr SEMI assign-expr RPAR LBRACE line RBRACE .

    $default  reduce using rule 28 (for-stmt)


State 460

   27 for-stmt: FOR LPAR var-declr SEMI expr SEMI expr RPAR LBRACE line RBRACE .

    $default  reduce using rule 27 (for-stmt)


State 461

   63 if-stmt: IF LPAR assign-expr RPAR LBRACE line RBRACE ELSE LBRACE line RBRACE .

    $default  reduce using rule 63 (if-stmt)


State 462

   60 if-stmt: IF LPAR expr RPAR LBRACE line RBRACE ELSE LBRACE line RBRACE .

    $default  reduce using rule 60 (if-stmt)


State 463

   85 class-att: ID LPAR params RPAR COLON var-type LBRACE line RBRACE .

    $default  reduce using rule 85 (class-att)
