Terminals unused in grammar

   ARROW
   TERNARY
   CHAIN
   PIPELINE
   SPREAD
   CASE
   CATCH
   DEBUGGER
   DEFAULT
   DELETE
   ENUM
   EXPORT
   EXTENDS
   FINALLY
   IMPLEMENTS
   IMPORT
   IN
   INSTANCEOF
   INTERFACE
   NULL_RW
   PACKAGE
   SUPER
   SWITCH
   THIS
   THROW
   TRY
   TYPEOF
   WITH
   AWAIT
   YIELD
   STATIC
   AS
   ASYNC
   FROM
   GET
   OF
   SET
   TARGET
   CONSTRUCTOR
   DECLARE
   MODULE
   REQUIRE
   SYMBOL
   TYPE
   UNKNOWN


Grammar

    0 $accept: begin $end

    1 begin: line

    2 line: stmt-list
    3     | %empty

    4 stmt-list: stmt-list stmt
    5          | stmt

    6 stmt: var-declr SEMI
    7     | func-def
    8     | class-def
    9     | expr SEMI
   10     | assign-expr SEMI
   11     | if-stmt
   12     | while-stmt
   13     | do-while-stmt
   14     | for-stmt
   15     | RETURN SEMI
   16     | RETURN expr SEMI
   17     | BREAK SEMI
   18     | CONTINUE SEMI

   19 assign-expr: var-att assignment expr
   20            | ID assignment expr
   21            | vet-idx assignment expr

   22 for-stmt: FOR LPAR assign-expr SEMI expr SEMI expr RPAR LBRACE line RBRACE
   23         | FOR LPAR assign-expr SEMI expr SEMI assign-expr RPAR LBRACE line RBRACE
   24         | FOR LPAR assign-expr SEMI expr SEMI RPAR LBRACE line RBRACE
   25         | FOR LPAR assign-expr SEMI SEMI expr RPAR LBRACE line RBRACE
   26         | FOR LPAR assign-expr SEMI SEMI assign-expr RPAR LBRACE line RBRACE
   27         | FOR LPAR assign-expr SEMI SEMI RPAR LBRACE line RBRACE
   28         | FOR LPAR var-declr SEMI expr SEMI expr RPAR LBRACE line RBRACE
   29         | FOR LPAR var-declr SEMI expr SEMI assign-expr RPAR LBRACE line RBRACE
   30         | FOR LPAR var-declr SEMI expr SEMI RPAR LBRACE line RBRACE
   31         | FOR LPAR var-declr SEMI SEMI expr RPAR LBRACE line RBRACE
   32         | FOR LPAR var-declr SEMI SEMI assign-expr RPAR LBRACE line RBRACE
   33         | FOR LPAR var-declr SEMI SEMI RPAR LBRACE line RBRACE
   34         | FOR LPAR SEMI expr SEMI expr RPAR LBRACE line RBRACE
   35         | FOR LPAR SEMI expr SEMI assign-expr RPAR LBRACE line RBRACE
   36         | FOR LPAR SEMI expr SEMI RPAR LBRACE line RBRACE
   37         | FOR LPAR SEMI SEMI expr RPAR LBRACE line RBRACE
   38         | FOR LPAR SEMI SEMI assign-expr RPAR LBRACE line RBRACE
   39         | FOR LPAR SEMI SEMI RPAR LBRACE line RBRACE

   40 assignment: ASSIGN
   41           | LOGICAL_NULL_ASSIGN
   42           | LOGICAL_AND_ASSIGN
   43           | LOGICAL_OR_ASSIGN
   44           | PLUS_ASSIGN
   45           | SUB_ASSIGN
   46           | MULT_ASSIGN
   47           | DIV_ASSIGN
   48           | EXP_ASSIGN
   49           | REM_ASSIGN
   50           | BITWISE_AND_ASSIGN
   51           | BITWISE_OR_ASSIGN
   52           | BITWISE_XOR_ASSIGN
   53           | LSHIFT_ASSIGN
   54           | RSHIFT_ASSIGN
   55           | RSHIFT_UNSIGNED_ASSIGN

   56 do-while-stmt: DO LBRACE line RBRACE WHILE LPAR expr RPAR
   57              | DO LBRACE line RBRACE WHILE LPAR assign-expr RPAR

   58 while-stmt: WHILE LPAR expr RPAR LBRACE line RBRACE
   59           | WHILE LPAR assign-expr RPAR LBRACE line RBRACE

   60 if-stmt: IF LPAR expr RPAR LBRACE line RBRACE
   61        | IF LPAR expr RPAR LBRACE line RBRACE ELSE LBRACE line RBRACE
   62        | IF LPAR expr RPAR LBRACE line RBRACE ELSE stmt
   63        | IF LPAR assign-expr RPAR LBRACE line RBRACE
   64        | IF LPAR assign-expr RPAR LBRACE line RBRACE ELSE LBRACE line RBRACE
   65        | IF LPAR assign-expr RPAR LBRACE line RBRACE ELSE stmt

   66 logic-expr: expr EQ expr
   67           | expr EQ_STRICT expr
   68           | expr INEQ expr
   69           | expr INEQ_STRICT expr
   70           | expr LT expr
   71           | ID LT expr
   72           | expr LT_EQ expr
   73           | expr GT expr
   74           | expr GT_EQ expr
   75           | expr LOGICAL_NULL expr
   76           | expr LOGICAL_AND expr
   77           | expr LOGICAL_OR expr

   78 class-def: CLASS ID LBRACE class-att-list RBRACE

   79 class-att-list: SEMI class-att-list
   80               | class-att SEMI class-att-list
   81               | class-att
   82               | %empty

   83 class-att: ID COLON var-type
   84          | access-modif ID COLON var-type
   85          | ID LPAR params RPAR LBRACE line RBRACE
   86          | ID LPAR params RPAR COLON var-type LBRACE line RBRACE

   87 access-modif: PUBLIC
   88             | PRIVATE
   89             | PROTECTED

   90 func-def: FUNCTION ID LPAR params RPAR LBRACE line RBRACE
   91         | FUNCTION ID LPAR params RPAR COLON var-type LBRACE line RBRACE

   92 params: COMMA ID
   93       | COMMA ID COLON var-type
   94       | ID COMMA ID
   95       | ID COLON var-type COMMA ID COLON var-type
   96       | ID COLON var-type COMMA ID
   97       | ID COLON var-type
   98       | ID COMMA ID COLON var-type
   99       | %empty

  100 var-declr: var-declr-rw id-list
  101          | var-declr-rw id-list ASSIGN expr
  102          | var-declr-rw id-list ASSIGN obj-def
  103          | var-declr-rw ID COLON var-type
  104          | var-declr-rw ID COLON var-type ASSIGN expr
  105          | var-declr-rw ID COLON var-type LBRACKET RBRACKET
  106          | var-declr-rw ID COLON var-type LBRACKET RBRACKET ASSIGN expr
  107          | CONST_RW id-list ASSIGN expr
  108          | CONST_RW ID COLON var-type ASSIGN expr
  109          | CONST_RW ID COLON var-type LBRACKET RBRACKET ASSIGN expr
  110          | CONST_RW id-list ASSIGN obj-def

  111 var-declr-rw: LET
  112             | VAR

  113 id-list: ID COMMA id-list
  114        | ID

  115 obj-def: LBRACE obj-att-list RBRACE

  116 obj-att-list: COMMA obj-att-list
  117             | obj-att COMMA obj-att-list
  118             | obj-att
  119             | %empty

  120 obj-att: ID COLON var-val

  121 var-type: NUMBER
  122         | STRING
  123         | BOOLTYPE
  124         | UNDEFINED
  125         | ANY
  126         | VOID_RW
  127         | NEVER

  128 expr: idx-safe-expr
  129     | idx-unsafe-expr
  130     | LPAR expr RPAR

  131 idx-unsafe-expr: array-expr
  132                | logic-expr
  133                | var-obj

  134 idx-safe-expr: var-val
  135              | var-att
  136              | arit-expr
  137              | bitw-expr
  138              | shift-expr
  139              | unary-expr
  140              | vet-idx
  141              | ID

  142 vet-idx: ID LBRACKET idx-safe-expr RBRACKET

  143 unary-expr: INCREMENT ID
  144           | INCREMENT var-att
  145           | DECREMENT ID
  146           | DECREMENT var-att
  147           | ID INCREMENT
  148           | var-att INCREMENT
  149           | ID DECREMENT
  150           | var-att DECREMENT
  151           | LOGICAL_NOT expr
  152           | BITWISE_NOT expr

  153 arit-expr: expr PLUS expr
  154          | expr SUB expr
  155          | expr MULT expr
  156          | expr DIV expr
  157          | expr EXP expr
  158          | expr REM expr

  159 bitw-expr: expr BITWISE_AND expr
  160          | expr BITWISE_OR expr
  161          | expr BITWISE_XOR expr

  162 shift-expr: expr LSHIFT expr
  163           | expr RSHIFT expr
  164           | expr RSHIFT_UNSIGNED expr

  165 var-att: ID DOT var-att
  166        | var-att DOT ID
  167        | ID DOT var-met
  168        | var-met DOT ID
  169        | var-met DOT var-att
  170        | var-att DOT var-met
  171        | ID DOT ID

  172 var-met: ID LPAR args-list RPAR

  173 args-list: COMMA args-list
  174          | expr COMMA args-list
  175          | assign-expr COMMA args-list
  176          | expr
  177          | assign-expr
  178          | %empty

  179 var-obj: ID LPAR args-list RPAR
  180        | ID LT var-type GT LPAR args-list RPAR
  181        | NEW ID LPAR args-list RPAR
  182        | NEW ID LT var-type GT LPAR args-list RPAR

  183 var-val: INT_VAL
  184        | REAL_VAL
  185        | STR_VAL
  186        | TRUE_RW
  187        | FALSE_RW
  188        | SUB INT_VAL
  189        | SUB REAL_VAL
  190        | SUB STR_VAL
  191        | SUB TRUE_RW
  192        | SUB FALSE_RW

  193 array-expr: LBRACKET elmts-list RBRACKET

  194 elmts-list: COMMA elmts-list
  195           | var-val COMMA elmts-list
  196           | var-val
  197           | %empty


Terminals, with rules where they appear

$end (0) 0
error (256)
ASSIGN (258) 40 101 102 104 106 107 108 109 110
ARROW (259)
COMMA (260) 92 93 94 95 96 98 113 116 117 173 174 175 194 195
SEMI (261) 6 9 10 15 16 17 18 22 23 24 25 26 27 28 29 30 31 32 33 34
    35 36 37 38 39 79 80
COLON (262) 83 84 86 91 93 95 96 97 98 103 104 105 106 108 109 120
TERNARY (263)
CHAIN (264)
PIPELINE (265)
DOT (266) 165 166 167 168 169 170 171
SPREAD (267)
PLUS (268) 153
INCREMENT (269) 143 144 147 148
PLUS_ASSIGN (270) 44
SUB (271) 154 188 189 190 191 192
DECREMENT (272) 145 146 149 150
SUB_ASSIGN (273) 45
MULT (274) 155
MULT_ASSIGN (275) 46
DIV (276) 156
DIV_ASSIGN (277) 47
EXP (278) 157
EXP_ASSIGN (279) 48
REM (280) 158
REM_ASSIGN (281) 49
BITWISE_NOT (282) 152
BITWISE_AND (283) 159
BITWISE_AND_ASSIGN (284) 50
BITWISE_OR (285) 160
BITWISE_OR_ASSIGN (286) 51
BITWISE_XOR (287) 161
BITWISE_XOR_ASSIGN (288) 52
LOGICAL_NOT (289) 151
LOGICAL_NULL (290) 75
LOGICAL_NULL_ASSIGN (291) 41
LOGICAL_AND (292) 76
LOGICAL_AND_ASSIGN (293) 42
LOGICAL_OR (294) 77
LOGICAL_OR_ASSIGN (295) 43
EQ (296) 66
EQ_STRICT (297) 67
INEQ (298) 68
INEQ_STRICT (299) 69
LT (300) 70 71 180 182
LT_EQ (301) 72
GT (302) 73 180 182
GT_EQ (303) 74
LSHIFT (304) 162
LSHIFT_ASSIGN (305) 53
RSHIFT (306) 163
RSHIFT_ASSIGN (307) 54
RSHIFT_UNSIGNED (308) 164
RSHIFT_UNSIGNED_ASSIGN (309) 55
LPAR (310) 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 56
    57 58 59 60 61 62 63 64 65 85 86 90 91 130 172 179 180 181 182
RPAR (311) 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 56
    57 58 59 60 61 62 63 64 65 85 86 90 91 130 172 179 180 181 182
LBRACE (312) 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39
    56 57 58 59 60 61 62 63 64 65 78 85 86 90 91 115
RBRACE (313) 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39
    56 57 58 59 60 61 62 63 64 65 78 85 86 90 91 115
LBRACKET (314) 105 106 109 142 193
RBRACKET (315) 105 106 109 142 193
INT_VAL (316) 183 188
REAL_VAL (317) 184 189
STR_VAL (318) 185 190
ID (319) 20 71 78 83 84 85 86 90 91 92 93 94 95 96 97 98 103 104 105
    106 108 109 113 114 120 141 142 143 145 147 149 165 166 167 168
    171 172 179 180 181 182
BREAK (320) 17
CASE (321)
CATCH (322)
CLASS (323) 78
CONST_RW (324) 107 108 109 110
CONTINUE (325) 18
DEBUGGER (326)
DEFAULT (327)
DELETE (328)
DO (329) 56 57
ELSE (330) 61 62 64 65
ENUM (331)
EXPORT (332)
EXTENDS (333)
FALSE_RW (334) 187 192
FINALLY (335)
FOR (336) 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39
FUNCTION (337) 90 91
IF (338) 60 61 62 63 64 65
IMPLEMENTS (339)
IMPORT (340)
IN (341)
INSTANCEOF (342)
INTERFACE (343)
LET (344) 111
NEW (345) 181 182
NULL_RW (346)
PACKAGE (347)
PRIVATE (348) 88
PROTECTED (349) 89
PUBLIC (350) 87
RETURN (351) 15 16
SUPER (352)
SWITCH (353)
THIS (354)
THROW (355)
TRUE_RW (356) 186 191
TRY (357)
TYPEOF (358)
VAR (359) 112
VOID_RW (360) 126
WHILE (361) 56 57 58 59
WITH (362)
AWAIT (363)
YIELD (364)
STATIC (365)
AS (366)
ASYNC (367)
FROM (368)
GET (369)
OF (370)
SET (371)
TARGET (372)
ANY (373) 125
BOOLTYPE (374) 123
CONSTRUCTOR (375)
DECLARE (376)
MODULE (377)
REQUIRE (378)
NEVER (379) 127
NUMBER (380) 121
STRING (381) 122
SYMBOL (382)
TYPE (383)
UNDEFINED (384) 124
UNKNOWN (385)
E_ID (386)


Nonterminals, with rules where they appear

$accept (132)
    on left: 0
begin (133)
    on left: 1, on right: 0
line (134)
    on left: 2 3, on right: 1 22 23 24 25 26 27 28 29 30 31 32 33 34
    35 36 37 38 39 56 57 58 59 60 61 62 63 64 65 85 86 90 91
stmt-list (135)
    on left: 4 5, on right: 2 4
stmt (136)
    on left: 6 7 8 9 10 11 12 13 14 15 16 17 18, on right: 4 5 62 65
assign-expr (137)
    on left: 19 20 21, on right: 10 22 23 24 25 26 27 29 32 35 38 57
    59 63 64 65 175 177
for-stmt (138)
    on left: 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39,
    on right: 14
assignment (139)
    on left: 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55, on right:
    19 20 21
do-while-stmt (140)
    on left: 56 57, on right: 13
while-stmt (141)
    on left: 58 59, on right: 12
if-stmt (142)
    on left: 60 61 62 63 64 65, on right: 11
logic-expr (143)
    on left: 66 67 68 69 70 71 72 73 74 75 76 77, on right: 132
class-def (144)
    on left: 78, on right: 8
class-att-list (145)
    on left: 79 80 81 82, on right: 78 79 80
class-att (146)
    on left: 83 84 85 86, on right: 80 81
access-modif (147)
    on left: 87 88 89, on right: 84
func-def (148)
    on left: 90 91, on right: 7
params (149)
    on left: 92 93 94 95 96 97 98 99, on right: 85 86 90 91
var-declr (150)
    on left: 100 101 102 103 104 105 106 107 108 109 110, on right:
    6 28 29 30 31 32 33
var-declr-rw (151)
    on left: 111 112, on right: 100 101 102 103 104 105 106
id-list (152)
    on left: 113 114, on right: 100 101 102 107 110 113
obj-def (153)
    on left: 115, on right: 102 110
obj-att-list (154)
    on left: 116 117 118 119, on right: 115 116 117
obj-att (155)
    on left: 120, on right: 117 118
var-type (156)
    on left: 121 122 123 124 125 126 127, on right: 83 84 86 91 93
    95 96 97 98 103 104 105 106 108 109 180 182
expr (157)
    on left: 128 129 130, on right: 9 16 19 20 21 22 23 24 25 28 29
    30 31 34 35 36 37 56 58 60 61 62 66 67 68 69 70 71 72 73 74 75
    76 77 101 104 106 107 108 109 130 151 152 153 154 155 156 157 158
    159 160 161 162 163 164 174 176
idx-unsafe-expr (158)
    on left: 131 132 133, on right: 129
idx-safe-expr (159)
    on left: 134 135 136 137 138 139 140 141, on right: 128 142
vet-idx (160)
    on left: 142, on right: 21 140
unary-expr (161)
    on left: 143 144 145 146 147 148 149 150 151 152, on right: 139
arit-expr (162)
    on left: 153 154 155 156 157 158, on right: 136
bitw-expr (163)
    on left: 159 160 161, on right: 137
shift-expr (164)
    on left: 162 163 164, on right: 138
var-att (165)
    on left: 165 166 167 168 169 170 171, on right: 19 135 144 146
    148 150 165 166 169 170
var-met (166)
    on left: 172, on right: 167 168 169 170
args-list (167)
    on left: 173 174 175 176 177 178, on right: 172 173 174 175 179
    180 181 182
var-obj (168)
    on left: 179 180 181 182, on right: 133
var-val (169)
    on left: 183 184 185 186 187 188 189 190 191 192, on right: 120
    134 195 196
array-expr (170)
    on left: 193, on right: 131
elmts-list (171)
    on left: 194 195 196 197, on right: 193 194 195


State 0

    0 $accept: . begin $end

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    RETURN       shift, and go to state 23
    TRUE_RW      shift, and go to state 24
    VAR          shift, and go to state 25
    WHILE        shift, and go to state 26

    $default  reduce using rule 3 (line)

    begin            go to state 27
    line             go to state 28
    stmt-list        go to state 29
    stmt             go to state 30
    assign-expr      go to state 31
    for-stmt         go to state 32
    do-while-stmt    go to state 33
    while-stmt       go to state 34
    if-stmt          go to state 35
    logic-expr       go to state 36
    class-def        go to state 37
    func-def         go to state 38
    var-declr        go to state 39
    var-declr-rw     go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 1

  143 unary-expr: INCREMENT . ID
  144           | INCREMENT . var-att

    ID  shift, and go to state 54

    var-att  go to state 55
    var-met  go to state 50


State 2

  188 var-val: SUB . INT_VAL
  189        | SUB . REAL_VAL
  190        | SUB . STR_VAL
  191        | SUB . TRUE_RW
  192        | SUB . FALSE_RW

    INT_VAL   shift, and go to state 56
    REAL_VAL  shift, and go to state 57
    STR_VAL   shift, and go to state 58
    FALSE_RW  shift, and go to state 59
    TRUE_RW   shift, and go to state 60


State 3

  145 unary-expr: DECREMENT . ID
  146           | DECREMENT . var-att

    ID  shift, and go to state 61

    var-att  go to state 62
    var-met  go to state 50


State 4

  152 unary-expr: BITWISE_NOT . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    TRUE_RW      shift, and go to state 24

    logic-expr       go to state 36
    expr             go to state 64
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 5

  151 unary-expr: LOGICAL_NOT . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    TRUE_RW      shift, and go to state 24

    logic-expr       go to state 36
    expr             go to state 67
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 6

  130 expr: LPAR . expr RPAR

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    TRUE_RW      shift, and go to state 24

    logic-expr       go to state 36
    expr             go to state 68
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 7

  193 array-expr: LBRACKET . elmts-list RBRACKET

    COMMA     shift, and go to state 69
    SUB       shift, and go to state 2
    INT_VAL   shift, and go to state 8
    REAL_VAL  shift, and go to state 9
    STR_VAL   shift, and go to state 10
    FALSE_RW  shift, and go to state 17
    TRUE_RW   shift, and go to state 24

    $default  reduce using rule 197 (elmts-list)

    var-val     go to state 70
    elmts-list  go to state 71


State 8

  183 var-val: INT_VAL .

    $default  reduce using rule 183 (var-val)


State 9

  184 var-val: REAL_VAL .

    $default  reduce using rule 184 (var-val)


State 10

  185 var-val: STR_VAL .

    $default  reduce using rule 185 (var-val)


State 11

   20 assign-expr: ID . assignment expr
   71 logic-expr: ID . LT expr
  141 idx-safe-expr: ID .
  142 vet-idx: ID . LBRACKET idx-safe-expr RBRACKET
  147 unary-expr: ID . INCREMENT
  149           | ID . DECREMENT
  165 var-att: ID . DOT var-att
  167        | ID . DOT var-met
  171        | ID . DOT ID
  172 var-met: ID . LPAR args-list RPAR
  179 var-obj: ID . LPAR args-list RPAR
  180        | ID . LT var-type GT LPAR args-list RPAR

    ASSIGN                  shift, and go to state 72
    DOT                     shift, and go to state 73
    INCREMENT               shift, and go to state 74
    PLUS_ASSIGN             shift, and go to state 75
    DECREMENT               shift, and go to state 76
    SUB_ASSIGN              shift, and go to state 77
    MULT_ASSIGN             shift, and go to state 78
    DIV_ASSIGN              shift, and go to state 79
    EXP_ASSIGN              shift, and go to state 80
    REM_ASSIGN              shift, and go to state 81
    BITWISE_AND_ASSIGN      shift, and go to state 82
    BITWISE_OR_ASSIGN       shift, and go to state 83
    BITWISE_XOR_ASSIGN      shift, and go to state 84
    LOGICAL_NULL_ASSIGN     shift, and go to state 85
    LOGICAL_AND_ASSIGN      shift, and go to state 86
    LOGICAL_OR_ASSIGN       shift, and go to state 87
    LT                      shift, and go to state 88
    LSHIFT_ASSIGN           shift, and go to state 89
    RSHIFT_ASSIGN           shift, and go to state 90
    RSHIFT_UNSIGNED_ASSIGN  shift, and go to state 91
    LPAR                    shift, and go to state 92
    LBRACKET                shift, and go to state 93

    $default  reduce using rule 141 (idx-safe-expr)

    assignment  go to state 94


State 12

   17 stmt: BREAK . SEMI

    SEMI  shift, and go to state 95


State 13

   78 class-def: CLASS . ID LBRACE class-att-list RBRACE

    ID  shift, and go to state 96


State 14

  107 var-declr: CONST_RW . id-list ASSIGN expr
  108          | CONST_RW . ID COLON var-type ASSIGN expr
  109          | CONST_RW . ID COLON var-type LBRACKET RBRACKET ASSIGN expr
  110          | CONST_RW . id-list ASSIGN obj-def

    ID  shift, and go to state 97

    id-list  go to state 98


State 15

   18 stmt: CONTINUE . SEMI

    SEMI  shift, and go to state 99


State 16

   56 do-while-stmt: DO . LBRACE line RBRACE WHILE LPAR expr RPAR
   57              | DO . LBRACE line RBRACE WHILE LPAR assign-expr RPAR

    LBRACE  shift, and go to state 100


State 17

  187 var-val: FALSE_RW .

    $default  reduce using rule 187 (var-val)


State 18

   22 for-stmt: FOR . LPAR assign-expr SEMI expr SEMI expr RPAR LBRACE line RBRACE
   23         | FOR . LPAR assign-expr SEMI expr SEMI assign-expr RPAR LBRACE line RBRACE
   24         | FOR . LPAR assign-expr SEMI expr SEMI RPAR LBRACE line RBRACE
   25         | FOR . LPAR assign-expr SEMI SEMI expr RPAR LBRACE line RBRACE
   26         | FOR . LPAR assign-expr SEMI SEMI assign-expr RPAR LBRACE line RBRACE
   27         | FOR . LPAR assign-expr SEMI SEMI RPAR LBRACE line RBRACE
   28         | FOR . LPAR var-declr SEMI expr SEMI expr RPAR LBRACE line RBRACE
   29         | FOR . LPAR var-declr SEMI expr SEMI assign-expr RPAR LBRACE line RBRACE
   30         | FOR . LPAR var-declr SEMI expr SEMI RPAR LBRACE line RBRACE
   31         | FOR . LPAR var-declr SEMI SEMI expr RPAR LBRACE line RBRACE
   32         | FOR . LPAR var-declr SEMI SEMI assign-expr RPAR LBRACE line RBRACE
   33         | FOR . LPAR var-declr SEMI SEMI RPAR LBRACE line RBRACE
   34         | FOR . LPAR SEMI expr SEMI expr RPAR LBRACE line RBRACE
   35         | FOR . LPAR SEMI expr SEMI assign-expr RPAR LBRACE line RBRACE
   36         | FOR . LPAR SEMI expr SEMI RPAR LBRACE line RBRACE
   37         | FOR . LPAR SEMI SEMI expr RPAR LBRACE line RBRACE
   38         | FOR . LPAR SEMI SEMI assign-expr RPAR LBRACE line RBRACE
   39         | FOR . LPAR SEMI SEMI RPAR LBRACE line RBRACE

    LPAR  shift, and go to state 101


State 19

   90 func-def: FUNCTION . ID LPAR params RPAR LBRACE line RBRACE
   91         | FUNCTION . ID LPAR params RPAR COLON var-type LBRACE line RBRACE

    ID  shift, and go to state 102


State 20

   60 if-stmt: IF . LPAR expr RPAR LBRACE line RBRACE
   61        | IF . LPAR expr RPAR LBRACE line RBRACE ELSE LBRACE line RBRACE
   62        | IF . LPAR expr RPAR LBRACE line RBRACE ELSE stmt
   63        | IF . LPAR assign-expr RPAR LBRACE line RBRACE
   64        | IF . LPAR assign-expr RPAR LBRACE line RBRACE ELSE LBRACE line RBRACE
   65        | IF . LPAR assign-expr RPAR LBRACE line RBRACE ELSE stmt

    LPAR  shift, and go to state 103


State 21

  111 var-declr-rw: LET .

    $default  reduce using rule 111 (var-declr-rw)


State 22

  181 var-obj: NEW . ID LPAR args-list RPAR
  182        | NEW . ID LT var-type GT LPAR args-list RPAR

    ID  shift, and go to state 104


State 23

   15 stmt: RETURN . SEMI
   16     | RETURN . expr SEMI

    SEMI         shift, and go to state 105
    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    TRUE_RW      shift, and go to state 24

    logic-expr       go to state 36
    expr             go to state 106
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 24

  186 var-val: TRUE_RW .

    $default  reduce using rule 186 (var-val)


State 25

  112 var-declr-rw: VAR .

    $default  reduce using rule 112 (var-declr-rw)


State 26

   58 while-stmt: WHILE . LPAR expr RPAR LBRACE line RBRACE
   59           | WHILE . LPAR assign-expr RPAR LBRACE line RBRACE

    LPAR  shift, and go to state 107


State 27

    0 $accept: begin . $end

    $end  shift, and go to state 108


State 28

    1 begin: line .

    $default  reduce using rule 1 (begin)


State 29

    2 line: stmt-list .
    4 stmt-list: stmt-list . stmt

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    RETURN       shift, and go to state 23
    TRUE_RW      shift, and go to state 24
    VAR          shift, and go to state 25
    WHILE        shift, and go to state 26

    $default  reduce using rule 2 (line)

    stmt             go to state 109
    assign-expr      go to state 31
    for-stmt         go to state 32
    do-while-stmt    go to state 33
    while-stmt       go to state 34
    if-stmt          go to state 35
    logic-expr       go to state 36
    class-def        go to state 37
    func-def         go to state 38
    var-declr        go to state 39
    var-declr-rw     go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 30

    5 stmt-list: stmt .

    $default  reduce using rule 5 (stmt-list)


State 31

   10 stmt: assign-expr . SEMI

    SEMI  shift, and go to state 110


State 32

   14 stmt: for-stmt .

    $default  reduce using rule 14 (stmt)


State 33

   13 stmt: do-while-stmt .

    $default  reduce using rule 13 (stmt)


State 34

   12 stmt: while-stmt .

    $default  reduce using rule 12 (stmt)


State 35

   11 stmt: if-stmt .

    $default  reduce using rule 11 (stmt)


State 36

  132 idx-unsafe-expr: logic-expr .

    $default  reduce using rule 132 (idx-unsafe-expr)


State 37

    8 stmt: class-def .

    $default  reduce using rule 8 (stmt)


State 38

    7 stmt: func-def .

    $default  reduce using rule 7 (stmt)


State 39

    6 stmt: var-declr . SEMI

    SEMI  shift, and go to state 111


State 40

  100 var-declr: var-declr-rw . id-list
  101          | var-declr-rw . id-list ASSIGN expr
  102          | var-declr-rw . id-list ASSIGN obj-def
  103          | var-declr-rw . ID COLON var-type
  104          | var-declr-rw . ID COLON var-type ASSIGN expr
  105          | var-declr-rw . ID COLON var-type LBRACKET RBRACKET
  106          | var-declr-rw . ID COLON var-type LBRACKET RBRACKET ASSIGN expr

    ID  shift, and go to state 112

    id-list  go to state 113


State 41

    9 stmt: expr . SEMI
   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  153 arit-expr: expr . PLUS expr
  154          | expr . SUB expr
  155          | expr . MULT expr
  156          | expr . DIV expr
  157          | expr . EXP expr
  158          | expr . REM expr
  159 bitw-expr: expr . BITWISE_AND expr
  160          | expr . BITWISE_OR expr
  161          | expr . BITWISE_XOR expr
  162 shift-expr: expr . LSHIFT expr
  163           | expr . RSHIFT expr
  164           | expr . RSHIFT_UNSIGNED expr

    SEMI             shift, and go to state 114
    PLUS             shift, and go to state 115
    SUB              shift, and go to state 116
    MULT             shift, and go to state 117
    DIV              shift, and go to state 118
    EXP              shift, and go to state 119
    REM              shift, and go to state 120
    BITWISE_AND      shift, and go to state 121
    BITWISE_OR       shift, and go to state 122
    BITWISE_XOR      shift, and go to state 123
    LOGICAL_NULL     shift, and go to state 124
    LOGICAL_AND      shift, and go to state 125
    LOGICAL_OR       shift, and go to state 126
    EQ               shift, and go to state 127
    EQ_STRICT        shift, and go to state 128
    INEQ             shift, and go to state 129
    INEQ_STRICT      shift, and go to state 130
    LT               shift, and go to state 131
    LT_EQ            shift, and go to state 132
    GT               shift, and go to state 133
    GT_EQ            shift, and go to state 134
    LSHIFT           shift, and go to state 135
    RSHIFT           shift, and go to state 136
    RSHIFT_UNSIGNED  shift, and go to state 137


State 42

  129 expr: idx-unsafe-expr .

    $default  reduce using rule 129 (expr)


State 43

  128 expr: idx-safe-expr .

    $default  reduce using rule 128 (expr)


State 44

   21 assign-expr: vet-idx . assignment expr
  140 idx-safe-expr: vet-idx .

    ASSIGN                  shift, and go to state 72
    PLUS_ASSIGN             shift, and go to state 75
    SUB_ASSIGN              shift, and go to state 77
    MULT_ASSIGN             shift, and go to state 78
    DIV_ASSIGN              shift, and go to state 79
    EXP_ASSIGN              shift, and go to state 80
    REM_ASSIGN              shift, and go to state 81
    BITWISE_AND_ASSIGN      shift, and go to state 82
    BITWISE_OR_ASSIGN       shift, and go to state 83
    BITWISE_XOR_ASSIGN      shift, and go to state 84
    LOGICAL_NULL_ASSIGN     shift, and go to state 85
    LOGICAL_AND_ASSIGN      shift, and go to state 86
    LOGICAL_OR_ASSIGN       shift, and go to state 87
    LSHIFT_ASSIGN           shift, and go to state 89
    RSHIFT_ASSIGN           shift, and go to state 90
    RSHIFT_UNSIGNED_ASSIGN  shift, and go to state 91

    $default  reduce using rule 140 (idx-safe-expr)

    assignment  go to state 138


State 45

  139 idx-safe-expr: unary-expr .

    $default  reduce using rule 139 (idx-safe-expr)


State 46

  136 idx-safe-expr: arit-expr .

    $default  reduce using rule 136 (idx-safe-expr)


State 47

  137 idx-safe-expr: bitw-expr .

    $default  reduce using rule 137 (idx-safe-expr)


State 48

  138 idx-safe-expr: shift-expr .

    $default  reduce using rule 138 (idx-safe-expr)


State 49

   19 assign-expr: var-att . assignment expr
  135 idx-safe-expr: var-att .
  148 unary-expr: var-att . INCREMENT
  150           | var-att . DECREMENT
  166 var-att: var-att . DOT ID
  170        | var-att . DOT var-met

    ASSIGN                  shift, and go to state 72
    DOT                     shift, and go to state 139
    INCREMENT               shift, and go to state 140
    PLUS_ASSIGN             shift, and go to state 75
    DECREMENT               shift, and go to state 141
    SUB_ASSIGN              shift, and go to state 77
    MULT_ASSIGN             shift, and go to state 78
    DIV_ASSIGN              shift, and go to state 79
    EXP_ASSIGN              shift, and go to state 80
    REM_ASSIGN              shift, and go to state 81
    BITWISE_AND_ASSIGN      shift, and go to state 82
    BITWISE_OR_ASSIGN       shift, and go to state 83
    BITWISE_XOR_ASSIGN      shift, and go to state 84
    LOGICAL_NULL_ASSIGN     shift, and go to state 85
    LOGICAL_AND_ASSIGN      shift, and go to state 86
    LOGICAL_OR_ASSIGN       shift, and go to state 87
    LSHIFT_ASSIGN           shift, and go to state 89
    RSHIFT_ASSIGN           shift, and go to state 90
    RSHIFT_UNSIGNED_ASSIGN  shift, and go to state 91

    $default  reduce using rule 135 (idx-safe-expr)

    assignment  go to state 142


State 50

  168 var-att: var-met . DOT ID
  169        | var-met . DOT var-att

    DOT  shift, and go to state 143


State 51

  133 idx-unsafe-expr: var-obj .

    $default  reduce using rule 133 (idx-unsafe-expr)


State 52

  134 idx-safe-expr: var-val .

    $default  reduce using rule 134 (idx-safe-expr)


State 53

  131 idx-unsafe-expr: array-expr .

    $default  reduce using rule 131 (idx-unsafe-expr)


State 54

  143 unary-expr: INCREMENT ID .
  165 var-att: ID . DOT var-att
  167        | ID . DOT var-met
  171        | ID . DOT ID
  172 var-met: ID . LPAR args-list RPAR

    DOT   shift, and go to state 73
    LPAR  shift, and go to state 144

    $default  reduce using rule 143 (unary-expr)


State 55

  144 unary-expr: INCREMENT var-att .
  166 var-att: var-att . DOT ID
  170        | var-att . DOT var-met

    DOT  shift, and go to state 139

    $default  reduce using rule 144 (unary-expr)


State 56

  188 var-val: SUB INT_VAL .

    $default  reduce using rule 188 (var-val)


State 57

  189 var-val: SUB REAL_VAL .

    $default  reduce using rule 189 (var-val)


State 58

  190 var-val: SUB STR_VAL .

    $default  reduce using rule 190 (var-val)


State 59

  192 var-val: SUB FALSE_RW .

    $default  reduce using rule 192 (var-val)


State 60

  191 var-val: SUB TRUE_RW .

    $default  reduce using rule 191 (var-val)


State 61

  145 unary-expr: DECREMENT ID .
  165 var-att: ID . DOT var-att
  167        | ID . DOT var-met
  171        | ID . DOT ID
  172 var-met: ID . LPAR args-list RPAR

    DOT   shift, and go to state 73
    LPAR  shift, and go to state 144

    $default  reduce using rule 145 (unary-expr)


State 62

  146 unary-expr: DECREMENT var-att .
  166 var-att: var-att . DOT ID
  170        | var-att . DOT var-met

    DOT  shift, and go to state 139

    $default  reduce using rule 146 (unary-expr)


State 63

   71 logic-expr: ID . LT expr
  141 idx-safe-expr: ID .
  142 vet-idx: ID . LBRACKET idx-safe-expr RBRACKET
  147 unary-expr: ID . INCREMENT
  149           | ID . DECREMENT
  165 var-att: ID . DOT var-att
  167        | ID . DOT var-met
  171        | ID . DOT ID
  172 var-met: ID . LPAR args-list RPAR
  179 var-obj: ID . LPAR args-list RPAR
  180        | ID . LT var-type GT LPAR args-list RPAR

    DOT        shift, and go to state 73
    INCREMENT  shift, and go to state 74
    DECREMENT  shift, and go to state 76
    LT         shift, and go to state 88
    LPAR       shift, and go to state 92
    LBRACKET   shift, and go to state 93

    $default  reduce using rule 141 (idx-safe-expr)


State 64

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  152 unary-expr: BITWISE_NOT expr .
  153 arit-expr: expr . PLUS expr
  154          | expr . SUB expr
  155          | expr . MULT expr
  156          | expr . DIV expr
  157          | expr . EXP expr
  158          | expr . REM expr
  159 bitw-expr: expr . BITWISE_AND expr
  160          | expr . BITWISE_OR expr
  161          | expr . BITWISE_XOR expr
  162 shift-expr: expr . LSHIFT expr
  163           | expr . RSHIFT expr
  164           | expr . RSHIFT_UNSIGNED expr

    $default  reduce using rule 152 (unary-expr)


State 65

  140 idx-safe-expr: vet-idx .

    $default  reduce using rule 140 (idx-safe-expr)


State 66

  135 idx-safe-expr: var-att .
  148 unary-expr: var-att . INCREMENT
  150           | var-att . DECREMENT
  166 var-att: var-att . DOT ID
  170        | var-att . DOT var-met

    DOT        shift, and go to state 139
    INCREMENT  shift, and go to state 140
    DECREMENT  shift, and go to state 141

    $default  reduce using rule 135 (idx-safe-expr)


State 67

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  151 unary-expr: LOGICAL_NOT expr .
  153 arit-expr: expr . PLUS expr
  154          | expr . SUB expr
  155          | expr . MULT expr
  156          | expr . DIV expr
  157          | expr . EXP expr
  158          | expr . REM expr
  159 bitw-expr: expr . BITWISE_AND expr
  160          | expr . BITWISE_OR expr
  161          | expr . BITWISE_XOR expr
  162 shift-expr: expr . LSHIFT expr
  163           | expr . RSHIFT expr
  164           | expr . RSHIFT_UNSIGNED expr

    $default  reduce using rule 151 (unary-expr)


State 68

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  130 expr: LPAR expr . RPAR
  153 arit-expr: expr . PLUS expr
  154          | expr . SUB expr
  155          | expr . MULT expr
  156          | expr . DIV expr
  157          | expr . EXP expr
  158          | expr . REM expr
  159 bitw-expr: expr . BITWISE_AND expr
  160          | expr . BITWISE_OR expr
  161          | expr . BITWISE_XOR expr
  162 shift-expr: expr . LSHIFT expr
  163           | expr . RSHIFT expr
  164           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 115
    SUB              shift, and go to state 116
    MULT             shift, and go to state 117
    DIV              shift, and go to state 118
    EXP              shift, and go to state 119
    REM              shift, and go to state 120
    BITWISE_AND      shift, and go to state 121
    BITWISE_OR       shift, and go to state 122
    BITWISE_XOR      shift, and go to state 123
    LOGICAL_NULL     shift, and go to state 124
    LOGICAL_AND      shift, and go to state 125
    LOGICAL_OR       shift, and go to state 126
    EQ               shift, and go to state 127
    EQ_STRICT        shift, and go to state 128
    INEQ             shift, and go to state 129
    INEQ_STRICT      shift, and go to state 130
    LT               shift, and go to state 131
    LT_EQ            shift, and go to state 132
    GT               shift, and go to state 133
    GT_EQ            shift, and go to state 134
    LSHIFT           shift, and go to state 135
    RSHIFT           shift, and go to state 136
    RSHIFT_UNSIGNED  shift, and go to state 137
    RPAR             shift, and go to state 145


State 69

  194 elmts-list: COMMA . elmts-list

    COMMA     shift, and go to state 69
    SUB       shift, and go to state 2
    INT_VAL   shift, and go to state 8
    REAL_VAL  shift, and go to state 9
    STR_VAL   shift, and go to state 10
    FALSE_RW  shift, and go to state 17
    TRUE_RW   shift, and go to state 24

    $default  reduce using rule 197 (elmts-list)

    var-val     go to state 70
    elmts-list  go to state 146


State 70

  195 elmts-list: var-val . COMMA elmts-list
  196           | var-val .

    COMMA  shift, and go to state 147

    $default  reduce using rule 196 (elmts-list)


State 71

  193 array-expr: LBRACKET elmts-list . RBRACKET

    RBRACKET  shift, and go to state 148


State 72

   40 assignment: ASSIGN .

    $default  reduce using rule 40 (assignment)


State 73

  165 var-att: ID DOT . var-att
  167        | ID DOT . var-met
  171        | ID DOT . ID

    ID  shift, and go to state 149

    var-att  go to state 150
    var-met  go to state 151


State 74

  147 unary-expr: ID INCREMENT .

    $default  reduce using rule 147 (unary-expr)


State 75

   44 assignment: PLUS_ASSIGN .

    $default  reduce using rule 44 (assignment)


State 76

  149 unary-expr: ID DECREMENT .

    $default  reduce using rule 149 (unary-expr)


State 77

   45 assignment: SUB_ASSIGN .

    $default  reduce using rule 45 (assignment)


State 78

   46 assignment: MULT_ASSIGN .

    $default  reduce using rule 46 (assignment)


State 79

   47 assignment: DIV_ASSIGN .

    $default  reduce using rule 47 (assignment)


State 80

   48 assignment: EXP_ASSIGN .

    $default  reduce using rule 48 (assignment)


State 81

   49 assignment: REM_ASSIGN .

    $default  reduce using rule 49 (assignment)


State 82

   50 assignment: BITWISE_AND_ASSIGN .

    $default  reduce using rule 50 (assignment)


State 83

   51 assignment: BITWISE_OR_ASSIGN .

    $default  reduce using rule 51 (assignment)


State 84

   52 assignment: BITWISE_XOR_ASSIGN .

    $default  reduce using rule 52 (assignment)


State 85

   41 assignment: LOGICAL_NULL_ASSIGN .

    $default  reduce using rule 41 (assignment)


State 86

   42 assignment: LOGICAL_AND_ASSIGN .

    $default  reduce using rule 42 (assignment)


State 87

   43 assignment: LOGICAL_OR_ASSIGN .

    $default  reduce using rule 43 (assignment)


State 88

   71 logic-expr: ID LT . expr
  180 var-obj: ID LT . var-type GT LPAR args-list RPAR

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    TRUE_RW      shift, and go to state 24
    VOID_RW      shift, and go to state 152
    ANY          shift, and go to state 153
    BOOLTYPE     shift, and go to state 154
    NEVER        shift, and go to state 155
    NUMBER       shift, and go to state 156
    STRING       shift, and go to state 157
    UNDEFINED    shift, and go to state 158

    logic-expr       go to state 36
    var-type         go to state 159
    expr             go to state 160
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 89

   53 assignment: LSHIFT_ASSIGN .

    $default  reduce using rule 53 (assignment)


State 90

   54 assignment: RSHIFT_ASSIGN .

    $default  reduce using rule 54 (assignment)


State 91

   55 assignment: RSHIFT_UNSIGNED_ASSIGN .

    $default  reduce using rule 55 (assignment)


State 92

  172 var-met: ID LPAR . args-list RPAR
  179 var-obj: ID LPAR . args-list RPAR

    COMMA        shift, and go to state 161
    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    TRUE_RW      shift, and go to state 24

    $default  reduce using rule 178 (args-list)

    assign-expr      go to state 162
    logic-expr       go to state 36
    expr             go to state 163
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    args-list        go to state 164
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 93

  142 vet-idx: ID LBRACKET . idx-safe-expr RBRACKET

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    TRUE_RW      shift, and go to state 24

    logic-expr       go to state 36
    expr             go to state 165
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 166
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 94

   20 assign-expr: ID assignment . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    TRUE_RW      shift, and go to state 24

    logic-expr       go to state 36
    expr             go to state 167
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 95

   17 stmt: BREAK SEMI .

    $default  reduce using rule 17 (stmt)


State 96

   78 class-def: CLASS ID . LBRACE class-att-list RBRACE

    LBRACE  shift, and go to state 168


State 97

  108 var-declr: CONST_RW ID . COLON var-type ASSIGN expr
  109          | CONST_RW ID . COLON var-type LBRACKET RBRACKET ASSIGN expr
  113 id-list: ID . COMMA id-list
  114        | ID .

    COMMA  shift, and go to state 169
    COLON  shift, and go to state 170

    $default  reduce using rule 114 (id-list)


State 98

  107 var-declr: CONST_RW id-list . ASSIGN expr
  110          | CONST_RW id-list . ASSIGN obj-def

    ASSIGN  shift, and go to state 171


State 99

   18 stmt: CONTINUE SEMI .

    $default  reduce using rule 18 (stmt)


State 100

   56 do-while-stmt: DO LBRACE . line RBRACE WHILE LPAR expr RPAR
   57              | DO LBRACE . line RBRACE WHILE LPAR assign-expr RPAR

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    RETURN       shift, and go to state 23
    TRUE_RW      shift, and go to state 24
    VAR          shift, and go to state 25
    WHILE        shift, and go to state 26

    $default  reduce using rule 3 (line)

    line             go to state 172
    stmt-list        go to state 29
    stmt             go to state 30
    assign-expr      go to state 31
    for-stmt         go to state 32
    do-while-stmt    go to state 33
    while-stmt       go to state 34
    if-stmt          go to state 35
    logic-expr       go to state 36
    class-def        go to state 37
    func-def         go to state 38
    var-declr        go to state 39
    var-declr-rw     go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 101

   22 for-stmt: FOR LPAR . assign-expr SEMI expr SEMI expr RPAR LBRACE line RBRACE
   23         | FOR LPAR . assign-expr SEMI expr SEMI assign-expr RPAR LBRACE line RBRACE
   24         | FOR LPAR . assign-expr SEMI expr SEMI RPAR LBRACE line RBRACE
   25         | FOR LPAR . assign-expr SEMI SEMI expr RPAR LBRACE line RBRACE
   26         | FOR LPAR . assign-expr SEMI SEMI assign-expr RPAR LBRACE line RBRACE
   27         | FOR LPAR . assign-expr SEMI SEMI RPAR LBRACE line RBRACE
   28         | FOR LPAR . var-declr SEMI expr SEMI expr RPAR LBRACE line RBRACE
   29         | FOR LPAR . var-declr SEMI expr SEMI assign-expr RPAR LBRACE line RBRACE
   30         | FOR LPAR . var-declr SEMI expr SEMI RPAR LBRACE line RBRACE
   31         | FOR LPAR . var-declr SEMI SEMI expr RPAR LBRACE line RBRACE
   32         | FOR LPAR . var-declr SEMI SEMI assign-expr RPAR LBRACE line RBRACE
   33         | FOR LPAR . var-declr SEMI SEMI RPAR LBRACE line RBRACE
   34         | FOR LPAR . SEMI expr SEMI expr RPAR LBRACE line RBRACE
   35         | FOR LPAR . SEMI expr SEMI assign-expr RPAR LBRACE line RBRACE
   36         | FOR LPAR . SEMI expr SEMI RPAR LBRACE line RBRACE
   37         | FOR LPAR . SEMI SEMI expr RPAR LBRACE line RBRACE
   38         | FOR LPAR . SEMI SEMI assign-expr RPAR LBRACE line RBRACE
   39         | FOR LPAR . SEMI SEMI RPAR LBRACE line RBRACE

    SEMI      shift, and go to state 173
    ID        shift, and go to state 174
    CONST_RW  shift, and go to state 14
    LET       shift, and go to state 21
    VAR       shift, and go to state 25

    assign-expr   go to state 175
    var-declr     go to state 176
    var-declr-rw  go to state 40
    vet-idx       go to state 177
    var-att       go to state 178
    var-met       go to state 50


State 102

   90 func-def: FUNCTION ID . LPAR params RPAR LBRACE line RBRACE
   91         | FUNCTION ID . LPAR params RPAR COLON var-type LBRACE line RBRACE

    LPAR  shift, and go to state 179


State 103

   60 if-stmt: IF LPAR . expr RPAR LBRACE line RBRACE
   61        | IF LPAR . expr RPAR LBRACE line RBRACE ELSE LBRACE line RBRACE
   62        | IF LPAR . expr RPAR LBRACE line RBRACE ELSE stmt
   63        | IF LPAR . assign-expr RPAR LBRACE line RBRACE
   64        | IF LPAR . assign-expr RPAR LBRACE line RBRACE ELSE LBRACE line RBRACE
   65        | IF LPAR . assign-expr RPAR LBRACE line RBRACE ELSE stmt

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    TRUE_RW      shift, and go to state 24

    assign-expr      go to state 180
    logic-expr       go to state 36
    expr             go to state 181
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 104

  181 var-obj: NEW ID . LPAR args-list RPAR
  182        | NEW ID . LT var-type GT LPAR args-list RPAR

    LT    shift, and go to state 182
    LPAR  shift, and go to state 183


State 105

   15 stmt: RETURN SEMI .

    $default  reduce using rule 15 (stmt)


State 106

   16 stmt: RETURN expr . SEMI
   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  153 arit-expr: expr . PLUS expr
  154          | expr . SUB expr
  155          | expr . MULT expr
  156          | expr . DIV expr
  157          | expr . EXP expr
  158          | expr . REM expr
  159 bitw-expr: expr . BITWISE_AND expr
  160          | expr . BITWISE_OR expr
  161          | expr . BITWISE_XOR expr
  162 shift-expr: expr . LSHIFT expr
  163           | expr . RSHIFT expr
  164           | expr . RSHIFT_UNSIGNED expr

    SEMI             shift, and go to state 184
    PLUS             shift, and go to state 115
    SUB              shift, and go to state 116
    MULT             shift, and go to state 117
    DIV              shift, and go to state 118
    EXP              shift, and go to state 119
    REM              shift, and go to state 120
    BITWISE_AND      shift, and go to state 121
    BITWISE_OR       shift, and go to state 122
    BITWISE_XOR      shift, and go to state 123
    LOGICAL_NULL     shift, and go to state 124
    LOGICAL_AND      shift, and go to state 125
    LOGICAL_OR       shift, and go to state 126
    EQ               shift, and go to state 127
    EQ_STRICT        shift, and go to state 128
    INEQ             shift, and go to state 129
    INEQ_STRICT      shift, and go to state 130
    LT               shift, and go to state 131
    LT_EQ            shift, and go to state 132
    GT               shift, and go to state 133
    GT_EQ            shift, and go to state 134
    LSHIFT           shift, and go to state 135
    RSHIFT           shift, and go to state 136
    RSHIFT_UNSIGNED  shift, and go to state 137


State 107

   58 while-stmt: WHILE LPAR . expr RPAR LBRACE line RBRACE
   59           | WHILE LPAR . assign-expr RPAR LBRACE line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    TRUE_RW      shift, and go to state 24

    assign-expr      go to state 185
    logic-expr       go to state 36
    expr             go to state 186
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 108

    0 $accept: begin $end .

    $default  accept


State 109

    4 stmt-list: stmt-list stmt .

    $default  reduce using rule 4 (stmt-list)


State 110

   10 stmt: assign-expr SEMI .

    $default  reduce using rule 10 (stmt)


State 111

    6 stmt: var-declr SEMI .

    $default  reduce using rule 6 (stmt)


State 112

  103 var-declr: var-declr-rw ID . COLON var-type
  104          | var-declr-rw ID . COLON var-type ASSIGN expr
  105          | var-declr-rw ID . COLON var-type LBRACKET RBRACKET
  106          | var-declr-rw ID . COLON var-type LBRACKET RBRACKET ASSIGN expr
  113 id-list: ID . COMMA id-list
  114        | ID .

    COMMA  shift, and go to state 169
    COLON  shift, and go to state 187

    $default  reduce using rule 114 (id-list)


State 113

  100 var-declr: var-declr-rw id-list .
  101          | var-declr-rw id-list . ASSIGN expr
  102          | var-declr-rw id-list . ASSIGN obj-def

    ASSIGN  shift, and go to state 188

    $default  reduce using rule 100 (var-declr)


State 114

    9 stmt: expr SEMI .

    $default  reduce using rule 9 (stmt)


State 115

  153 arit-expr: expr PLUS . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    TRUE_RW      shift, and go to state 24

    logic-expr       go to state 36
    expr             go to state 189
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 116

  154 arit-expr: expr SUB . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    TRUE_RW      shift, and go to state 24

    logic-expr       go to state 36
    expr             go to state 190
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 117

  155 arit-expr: expr MULT . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    TRUE_RW      shift, and go to state 24

    logic-expr       go to state 36
    expr             go to state 191
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 118

  156 arit-expr: expr DIV . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    TRUE_RW      shift, and go to state 24

    logic-expr       go to state 36
    expr             go to state 192
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 119

  157 arit-expr: expr EXP . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    TRUE_RW      shift, and go to state 24

    logic-expr       go to state 36
    expr             go to state 193
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 120

  158 arit-expr: expr REM . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    TRUE_RW      shift, and go to state 24

    logic-expr       go to state 36
    expr             go to state 194
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 121

  159 bitw-expr: expr BITWISE_AND . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    TRUE_RW      shift, and go to state 24

    logic-expr       go to state 36
    expr             go to state 195
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 122

  160 bitw-expr: expr BITWISE_OR . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    TRUE_RW      shift, and go to state 24

    logic-expr       go to state 36
    expr             go to state 196
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 123

  161 bitw-expr: expr BITWISE_XOR . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    TRUE_RW      shift, and go to state 24

    logic-expr       go to state 36
    expr             go to state 197
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 124

   75 logic-expr: expr LOGICAL_NULL . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    TRUE_RW      shift, and go to state 24

    logic-expr       go to state 36
    expr             go to state 198
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 125

   76 logic-expr: expr LOGICAL_AND . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    TRUE_RW      shift, and go to state 24

    logic-expr       go to state 36
    expr             go to state 199
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 126

   77 logic-expr: expr LOGICAL_OR . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    TRUE_RW      shift, and go to state 24

    logic-expr       go to state 36
    expr             go to state 200
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 127

   66 logic-expr: expr EQ . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    TRUE_RW      shift, and go to state 24

    logic-expr       go to state 36
    expr             go to state 201
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 128

   67 logic-expr: expr EQ_STRICT . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    TRUE_RW      shift, and go to state 24

    logic-expr       go to state 36
    expr             go to state 202
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 129

   68 logic-expr: expr INEQ . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    TRUE_RW      shift, and go to state 24

    logic-expr       go to state 36
    expr             go to state 203
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 130

   69 logic-expr: expr INEQ_STRICT . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    TRUE_RW      shift, and go to state 24

    logic-expr       go to state 36
    expr             go to state 204
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 131

   70 logic-expr: expr LT . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    TRUE_RW      shift, and go to state 24

    logic-expr       go to state 36
    expr             go to state 205
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 132

   72 logic-expr: expr LT_EQ . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    TRUE_RW      shift, and go to state 24

    logic-expr       go to state 36
    expr             go to state 206
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 133

   73 logic-expr: expr GT . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    TRUE_RW      shift, and go to state 24

    logic-expr       go to state 36
    expr             go to state 207
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 134

   74 logic-expr: expr GT_EQ . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    TRUE_RW      shift, and go to state 24

    logic-expr       go to state 36
    expr             go to state 208
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 135

  162 shift-expr: expr LSHIFT . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    TRUE_RW      shift, and go to state 24

    logic-expr       go to state 36
    expr             go to state 209
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 136

  163 shift-expr: expr RSHIFT . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    TRUE_RW      shift, and go to state 24

    logic-expr       go to state 36
    expr             go to state 210
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 137

  164 shift-expr: expr RSHIFT_UNSIGNED . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    TRUE_RW      shift, and go to state 24

    logic-expr       go to state 36
    expr             go to state 211
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 138

   21 assign-expr: vet-idx assignment . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    TRUE_RW      shift, and go to state 24

    logic-expr       go to state 36
    expr             go to state 212
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 139

  166 var-att: var-att DOT . ID
  170        | var-att DOT . var-met

    ID  shift, and go to state 213

    var-met  go to state 214


State 140

  148 unary-expr: var-att INCREMENT .

    $default  reduce using rule 148 (unary-expr)


State 141

  150 unary-expr: var-att DECREMENT .

    $default  reduce using rule 150 (unary-expr)


State 142

   19 assign-expr: var-att assignment . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    TRUE_RW      shift, and go to state 24

    logic-expr       go to state 36
    expr             go to state 215
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 143

  168 var-att: var-met DOT . ID
  169        | var-met DOT . var-att

    ID  shift, and go to state 216

    var-att  go to state 217
    var-met  go to state 50


State 144

  172 var-met: ID LPAR . args-list RPAR

    COMMA        shift, and go to state 161
    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    TRUE_RW      shift, and go to state 24

    $default  reduce using rule 178 (args-list)

    assign-expr      go to state 162
    logic-expr       go to state 36
    expr             go to state 163
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    args-list        go to state 218
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 145

  130 expr: LPAR expr RPAR .

    $default  reduce using rule 130 (expr)


State 146

  194 elmts-list: COMMA elmts-list .

    $default  reduce using rule 194 (elmts-list)


State 147

  195 elmts-list: var-val COMMA . elmts-list

    COMMA     shift, and go to state 69
    SUB       shift, and go to state 2
    INT_VAL   shift, and go to state 8
    REAL_VAL  shift, and go to state 9
    STR_VAL   shift, and go to state 10
    FALSE_RW  shift, and go to state 17
    TRUE_RW   shift, and go to state 24

    $default  reduce using rule 197 (elmts-list)

    var-val     go to state 70
    elmts-list  go to state 219


State 148

  193 array-expr: LBRACKET elmts-list RBRACKET .

    $default  reduce using rule 193 (array-expr)


State 149

  165 var-att: ID . DOT var-att
  167        | ID . DOT var-met
  171        | ID . DOT ID
  171        | ID DOT ID .
  172 var-met: ID . LPAR args-list RPAR

    DOT   shift, and go to state 73
    LPAR  shift, and go to state 144

    $default  reduce using rule 171 (var-att)


State 150

  165 var-att: ID DOT var-att .
  166        | var-att . DOT ID
  170        | var-att . DOT var-met

    DOT  shift, and go to state 139

    $default  reduce using rule 165 (var-att)


State 151

  167 var-att: ID DOT var-met .
  168        | var-met . DOT ID
  169        | var-met . DOT var-att

    DOT  shift, and go to state 143

    $default  reduce using rule 167 (var-att)


State 152

  126 var-type: VOID_RW .

    $default  reduce using rule 126 (var-type)


State 153

  125 var-type: ANY .

    $default  reduce using rule 125 (var-type)


State 154

  123 var-type: BOOLTYPE .

    $default  reduce using rule 123 (var-type)


State 155

  127 var-type: NEVER .

    $default  reduce using rule 127 (var-type)


State 156

  121 var-type: NUMBER .

    $default  reduce using rule 121 (var-type)


State 157

  122 var-type: STRING .

    $default  reduce using rule 122 (var-type)


State 158

  124 var-type: UNDEFINED .

    $default  reduce using rule 124 (var-type)


State 159

  180 var-obj: ID LT var-type . GT LPAR args-list RPAR

    GT  shift, and go to state 220


State 160

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   71           | ID LT expr .
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  153 arit-expr: expr . PLUS expr
  154          | expr . SUB expr
  155          | expr . MULT expr
  156          | expr . DIV expr
  157          | expr . EXP expr
  158          | expr . REM expr
  159 bitw-expr: expr . BITWISE_AND expr
  160          | expr . BITWISE_OR expr
  161          | expr . BITWISE_XOR expr
  162 shift-expr: expr . LSHIFT expr
  163           | expr . RSHIFT expr
  164           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 115
    SUB              shift, and go to state 116
    MULT             shift, and go to state 117
    DIV              shift, and go to state 118
    EXP              shift, and go to state 119
    REM              shift, and go to state 120
    BITWISE_AND      shift, and go to state 121
    BITWISE_OR       shift, and go to state 122
    BITWISE_XOR      shift, and go to state 123
    LSHIFT           shift, and go to state 135
    RSHIFT           shift, and go to state 136
    RSHIFT_UNSIGNED  shift, and go to state 137

    $default  reduce using rule 71 (logic-expr)


State 161

  173 args-list: COMMA . args-list

    COMMA        shift, and go to state 161
    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    TRUE_RW      shift, and go to state 24

    $default  reduce using rule 178 (args-list)

    assign-expr      go to state 162
    logic-expr       go to state 36
    expr             go to state 163
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    args-list        go to state 221
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 162

  175 args-list: assign-expr . COMMA args-list
  177          | assign-expr .

    COMMA  shift, and go to state 222

    $default  reduce using rule 177 (args-list)


State 163

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  153 arit-expr: expr . PLUS expr
  154          | expr . SUB expr
  155          | expr . MULT expr
  156          | expr . DIV expr
  157          | expr . EXP expr
  158          | expr . REM expr
  159 bitw-expr: expr . BITWISE_AND expr
  160          | expr . BITWISE_OR expr
  161          | expr . BITWISE_XOR expr
  162 shift-expr: expr . LSHIFT expr
  163           | expr . RSHIFT expr
  164           | expr . RSHIFT_UNSIGNED expr
  174 args-list: expr . COMMA args-list
  176          | expr .

    COMMA            shift, and go to state 223
    PLUS             shift, and go to state 115
    SUB              shift, and go to state 116
    MULT             shift, and go to state 117
    DIV              shift, and go to state 118
    EXP              shift, and go to state 119
    REM              shift, and go to state 120
    BITWISE_AND      shift, and go to state 121
    BITWISE_OR       shift, and go to state 122
    BITWISE_XOR      shift, and go to state 123
    LOGICAL_NULL     shift, and go to state 124
    LOGICAL_AND      shift, and go to state 125
    LOGICAL_OR       shift, and go to state 126
    EQ               shift, and go to state 127
    EQ_STRICT        shift, and go to state 128
    INEQ             shift, and go to state 129
    INEQ_STRICT      shift, and go to state 130
    LT               shift, and go to state 131
    LT_EQ            shift, and go to state 132
    GT               shift, and go to state 133
    GT_EQ            shift, and go to state 134
    LSHIFT           shift, and go to state 135
    RSHIFT           shift, and go to state 136
    RSHIFT_UNSIGNED  shift, and go to state 137

    $default  reduce using rule 176 (args-list)


State 164

  172 var-met: ID LPAR args-list . RPAR
  179 var-obj: ID LPAR args-list . RPAR

    RPAR  shift, and go to state 224


State 165

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  153 arit-expr: expr . PLUS expr
  154          | expr . SUB expr
  155          | expr . MULT expr
  156          | expr . DIV expr
  157          | expr . EXP expr
  158          | expr . REM expr
  159 bitw-expr: expr . BITWISE_AND expr
  160          | expr . BITWISE_OR expr
  161          | expr . BITWISE_XOR expr
  162 shift-expr: expr . LSHIFT expr
  163           | expr . RSHIFT expr
  164           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 115
    SUB              shift, and go to state 116
    MULT             shift, and go to state 117
    DIV              shift, and go to state 118
    EXP              shift, and go to state 119
    REM              shift, and go to state 120
    BITWISE_AND      shift, and go to state 121
    BITWISE_OR       shift, and go to state 122
    BITWISE_XOR      shift, and go to state 123
    LOGICAL_NULL     shift, and go to state 124
    LOGICAL_AND      shift, and go to state 125
    LOGICAL_OR       shift, and go to state 126
    EQ               shift, and go to state 127
    EQ_STRICT        shift, and go to state 128
    INEQ             shift, and go to state 129
    INEQ_STRICT      shift, and go to state 130
    LT               shift, and go to state 131
    LT_EQ            shift, and go to state 132
    GT               shift, and go to state 133
    GT_EQ            shift, and go to state 134
    LSHIFT           shift, and go to state 135
    RSHIFT           shift, and go to state 136
    RSHIFT_UNSIGNED  shift, and go to state 137


State 166

  128 expr: idx-safe-expr .
  142 vet-idx: ID LBRACKET idx-safe-expr . RBRACKET

    RBRACKET  shift, and go to state 225

    $default  reduce using rule 128 (expr)


State 167

   20 assign-expr: ID assignment expr .
   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  153 arit-expr: expr . PLUS expr
  154          | expr . SUB expr
  155          | expr . MULT expr
  156          | expr . DIV expr
  157          | expr . EXP expr
  158          | expr . REM expr
  159 bitw-expr: expr . BITWISE_AND expr
  160          | expr . BITWISE_OR expr
  161          | expr . BITWISE_XOR expr
  162 shift-expr: expr . LSHIFT expr
  163           | expr . RSHIFT expr
  164           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 115
    SUB              shift, and go to state 116
    MULT             shift, and go to state 117
    DIV              shift, and go to state 118
    EXP              shift, and go to state 119
    REM              shift, and go to state 120
    BITWISE_AND      shift, and go to state 121
    BITWISE_OR       shift, and go to state 122
    BITWISE_XOR      shift, and go to state 123
    LOGICAL_NULL     shift, and go to state 124
    LOGICAL_AND      shift, and go to state 125
    LOGICAL_OR       shift, and go to state 126
    EQ               shift, and go to state 127
    EQ_STRICT        shift, and go to state 128
    INEQ             shift, and go to state 129
    INEQ_STRICT      shift, and go to state 130
    LT               shift, and go to state 131
    LT_EQ            shift, and go to state 132
    GT               shift, and go to state 133
    GT_EQ            shift, and go to state 134
    LSHIFT           shift, and go to state 135
    RSHIFT           shift, and go to state 136
    RSHIFT_UNSIGNED  shift, and go to state 137

    $default  reduce using rule 20 (assign-expr)


State 168

   78 class-def: CLASS ID LBRACE . class-att-list RBRACE

    SEMI       shift, and go to state 226
    ID         shift, and go to state 227
    PRIVATE    shift, and go to state 228
    PROTECTED  shift, and go to state 229
    PUBLIC     shift, and go to state 230

    $default  reduce using rule 82 (class-att-list)

    class-att-list  go to state 231
    class-att       go to state 232
    access-modif    go to state 233


State 169

  113 id-list: ID COMMA . id-list

    ID  shift, and go to state 234

    id-list  go to state 235


State 170

  108 var-declr: CONST_RW ID COLON . var-type ASSIGN expr
  109          | CONST_RW ID COLON . var-type LBRACKET RBRACKET ASSIGN expr

    VOID_RW    shift, and go to state 152
    ANY        shift, and go to state 153
    BOOLTYPE   shift, and go to state 154
    NEVER      shift, and go to state 155
    NUMBER     shift, and go to state 156
    STRING     shift, and go to state 157
    UNDEFINED  shift, and go to state 158

    var-type  go to state 236


State 171

  107 var-declr: CONST_RW id-list ASSIGN . expr
  110          | CONST_RW id-list ASSIGN . obj-def

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACE       shift, and go to state 237
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    TRUE_RW      shift, and go to state 24

    logic-expr       go to state 36
    obj-def          go to state 238
    expr             go to state 239
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 172

   56 do-while-stmt: DO LBRACE line . RBRACE WHILE LPAR expr RPAR
   57              | DO LBRACE line . RBRACE WHILE LPAR assign-expr RPAR

    RBRACE  shift, and go to state 240


State 173

   34 for-stmt: FOR LPAR SEMI . expr SEMI expr RPAR LBRACE line RBRACE
   35         | FOR LPAR SEMI . expr SEMI assign-expr RPAR LBRACE line RBRACE
   36         | FOR LPAR SEMI . expr SEMI RPAR LBRACE line RBRACE
   37         | FOR LPAR SEMI . SEMI expr RPAR LBRACE line RBRACE
   38         | FOR LPAR SEMI . SEMI assign-expr RPAR LBRACE line RBRACE
   39         | FOR LPAR SEMI . SEMI RPAR LBRACE line RBRACE

    SEMI         shift, and go to state 241
    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    TRUE_RW      shift, and go to state 24

    logic-expr       go to state 36
    expr             go to state 242
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 174

   20 assign-expr: ID . assignment expr
  142 vet-idx: ID . LBRACKET idx-safe-expr RBRACKET
  165 var-att: ID . DOT var-att
  167        | ID . DOT var-met
  171        | ID . DOT ID
  172 var-met: ID . LPAR args-list RPAR

    ASSIGN                  shift, and go to state 72
    DOT                     shift, and go to state 73
    PLUS_ASSIGN             shift, and go to state 75
    SUB_ASSIGN              shift, and go to state 77
    MULT_ASSIGN             shift, and go to state 78
    DIV_ASSIGN              shift, and go to state 79
    EXP_ASSIGN              shift, and go to state 80
    REM_ASSIGN              shift, and go to state 81
    BITWISE_AND_ASSIGN      shift, and go to state 82
    BITWISE_OR_ASSIGN       shift, and go to state 83
    BITWISE_XOR_ASSIGN      shift, and go to state 84
    LOGICAL_NULL_ASSIGN     shift, and go to state 85
    LOGICAL_AND_ASSIGN      shift, and go to state 86
    LOGICAL_OR_ASSIGN       shift, and go to state 87
    LSHIFT_ASSIGN           shift, and go to state 89
    RSHIFT_ASSIGN           shift, and go to state 90
    RSHIFT_UNSIGNED_ASSIGN  shift, and go to state 91
    LPAR                    shift, and go to state 144
    LBRACKET                shift, and go to state 93

    assignment  go to state 94


State 175

   22 for-stmt: FOR LPAR assign-expr . SEMI expr SEMI expr RPAR LBRACE line RBRACE
   23         | FOR LPAR assign-expr . SEMI expr SEMI assign-expr RPAR LBRACE line RBRACE
   24         | FOR LPAR assign-expr . SEMI expr SEMI RPAR LBRACE line RBRACE
   25         | FOR LPAR assign-expr . SEMI SEMI expr RPAR LBRACE line RBRACE
   26         | FOR LPAR assign-expr . SEMI SEMI assign-expr RPAR LBRACE line RBRACE
   27         | FOR LPAR assign-expr . SEMI SEMI RPAR LBRACE line RBRACE

    SEMI  shift, and go to state 243


State 176

   28 for-stmt: FOR LPAR var-declr . SEMI expr SEMI expr RPAR LBRACE line RBRACE
   29         | FOR LPAR var-declr . SEMI expr SEMI assign-expr RPAR LBRACE line RBRACE
   30         | FOR LPAR var-declr . SEMI expr SEMI RPAR LBRACE line RBRACE
   31         | FOR LPAR var-declr . SEMI SEMI expr RPAR LBRACE line RBRACE
   32         | FOR LPAR var-declr . SEMI SEMI assign-expr RPAR LBRACE line RBRACE
   33         | FOR LPAR var-declr . SEMI SEMI RPAR LBRACE line RBRACE

    SEMI  shift, and go to state 244


State 177

   21 assign-expr: vet-idx . assignment expr

    ASSIGN                  shift, and go to state 72
    PLUS_ASSIGN             shift, and go to state 75
    SUB_ASSIGN              shift, and go to state 77
    MULT_ASSIGN             shift, and go to state 78
    DIV_ASSIGN              shift, and go to state 79
    EXP_ASSIGN              shift, and go to state 80
    REM_ASSIGN              shift, and go to state 81
    BITWISE_AND_ASSIGN      shift, and go to state 82
    BITWISE_OR_ASSIGN       shift, and go to state 83
    BITWISE_XOR_ASSIGN      shift, and go to state 84
    LOGICAL_NULL_ASSIGN     shift, and go to state 85
    LOGICAL_AND_ASSIGN      shift, and go to state 86
    LOGICAL_OR_ASSIGN       shift, and go to state 87
    LSHIFT_ASSIGN           shift, and go to state 89
    RSHIFT_ASSIGN           shift, and go to state 90
    RSHIFT_UNSIGNED_ASSIGN  shift, and go to state 91

    assignment  go to state 138


State 178

   19 assign-expr: var-att . assignment expr
  166 var-att: var-att . DOT ID
  170        | var-att . DOT var-met

    ASSIGN                  shift, and go to state 72
    DOT                     shift, and go to state 139
    PLUS_ASSIGN             shift, and go to state 75
    SUB_ASSIGN              shift, and go to state 77
    MULT_ASSIGN             shift, and go to state 78
    DIV_ASSIGN              shift, and go to state 79
    EXP_ASSIGN              shift, and go to state 80
    REM_ASSIGN              shift, and go to state 81
    BITWISE_AND_ASSIGN      shift, and go to state 82
    BITWISE_OR_ASSIGN       shift, and go to state 83
    BITWISE_XOR_ASSIGN      shift, and go to state 84
    LOGICAL_NULL_ASSIGN     shift, and go to state 85
    LOGICAL_AND_ASSIGN      shift, and go to state 86
    LOGICAL_OR_ASSIGN       shift, and go to state 87
    LSHIFT_ASSIGN           shift, and go to state 89
    RSHIFT_ASSIGN           shift, and go to state 90
    RSHIFT_UNSIGNED_ASSIGN  shift, and go to state 91

    assignment  go to state 142


State 179

   90 func-def: FUNCTION ID LPAR . params RPAR LBRACE line RBRACE
   91         | FUNCTION ID LPAR . params RPAR COLON var-type LBRACE line RBRACE

    COMMA  shift, and go to state 245
    ID     shift, and go to state 246

    $default  reduce using rule 99 (params)

    params  go to state 247


State 180

   63 if-stmt: IF LPAR assign-expr . RPAR LBRACE line RBRACE
   64        | IF LPAR assign-expr . RPAR LBRACE line RBRACE ELSE LBRACE line RBRACE
   65        | IF LPAR assign-expr . RPAR LBRACE line RBRACE ELSE stmt

    RPAR  shift, and go to state 248


State 181

   60 if-stmt: IF LPAR expr . RPAR LBRACE line RBRACE
   61        | IF LPAR expr . RPAR LBRACE line RBRACE ELSE LBRACE line RBRACE
   62        | IF LPAR expr . RPAR LBRACE line RBRACE ELSE stmt
   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  153 arit-expr: expr . PLUS expr
  154          | expr . SUB expr
  155          | expr . MULT expr
  156          | expr . DIV expr
  157          | expr . EXP expr
  158          | expr . REM expr
  159 bitw-expr: expr . BITWISE_AND expr
  160          | expr . BITWISE_OR expr
  161          | expr . BITWISE_XOR expr
  162 shift-expr: expr . LSHIFT expr
  163           | expr . RSHIFT expr
  164           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 115
    SUB              shift, and go to state 116
    MULT             shift, and go to state 117
    DIV              shift, and go to state 118
    EXP              shift, and go to state 119
    REM              shift, and go to state 120
    BITWISE_AND      shift, and go to state 121
    BITWISE_OR       shift, and go to state 122
    BITWISE_XOR      shift, and go to state 123
    LOGICAL_NULL     shift, and go to state 124
    LOGICAL_AND      shift, and go to state 125
    LOGICAL_OR       shift, and go to state 126
    EQ               shift, and go to state 127
    EQ_STRICT        shift, and go to state 128
    INEQ             shift, and go to state 129
    INEQ_STRICT      shift, and go to state 130
    LT               shift, and go to state 131
    LT_EQ            shift, and go to state 132
    GT               shift, and go to state 133
    GT_EQ            shift, and go to state 134
    LSHIFT           shift, and go to state 135
    RSHIFT           shift, and go to state 136
    RSHIFT_UNSIGNED  shift, and go to state 137
    RPAR             shift, and go to state 249


State 182

  182 var-obj: NEW ID LT . var-type GT LPAR args-list RPAR

    VOID_RW    shift, and go to state 152
    ANY        shift, and go to state 153
    BOOLTYPE   shift, and go to state 154
    NEVER      shift, and go to state 155
    NUMBER     shift, and go to state 156
    STRING     shift, and go to state 157
    UNDEFINED  shift, and go to state 158

    var-type  go to state 250


State 183

  181 var-obj: NEW ID LPAR . args-list RPAR

    COMMA        shift, and go to state 161
    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    TRUE_RW      shift, and go to state 24

    $default  reduce using rule 178 (args-list)

    assign-expr      go to state 162
    logic-expr       go to state 36
    expr             go to state 163
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    args-list        go to state 251
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 184

   16 stmt: RETURN expr SEMI .

    $default  reduce using rule 16 (stmt)


State 185

   59 while-stmt: WHILE LPAR assign-expr . RPAR LBRACE line RBRACE

    RPAR  shift, and go to state 252


State 186

   58 while-stmt: WHILE LPAR expr . RPAR LBRACE line RBRACE
   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  153 arit-expr: expr . PLUS expr
  154          | expr . SUB expr
  155          | expr . MULT expr
  156          | expr . DIV expr
  157          | expr . EXP expr
  158          | expr . REM expr
  159 bitw-expr: expr . BITWISE_AND expr
  160          | expr . BITWISE_OR expr
  161          | expr . BITWISE_XOR expr
  162 shift-expr: expr . LSHIFT expr
  163           | expr . RSHIFT expr
  164           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 115
    SUB              shift, and go to state 116
    MULT             shift, and go to state 117
    DIV              shift, and go to state 118
    EXP              shift, and go to state 119
    REM              shift, and go to state 120
    BITWISE_AND      shift, and go to state 121
    BITWISE_OR       shift, and go to state 122
    BITWISE_XOR      shift, and go to state 123
    LOGICAL_NULL     shift, and go to state 124
    LOGICAL_AND      shift, and go to state 125
    LOGICAL_OR       shift, and go to state 126
    EQ               shift, and go to state 127
    EQ_STRICT        shift, and go to state 128
    INEQ             shift, and go to state 129
    INEQ_STRICT      shift, and go to state 130
    LT               shift, and go to state 131
    LT_EQ            shift, and go to state 132
    GT               shift, and go to state 133
    GT_EQ            shift, and go to state 134
    LSHIFT           shift, and go to state 135
    RSHIFT           shift, and go to state 136
    RSHIFT_UNSIGNED  shift, and go to state 137
    RPAR             shift, and go to state 253


State 187

  103 var-declr: var-declr-rw ID COLON . var-type
  104          | var-declr-rw ID COLON . var-type ASSIGN expr
  105          | var-declr-rw ID COLON . var-type LBRACKET RBRACKET
  106          | var-declr-rw ID COLON . var-type LBRACKET RBRACKET ASSIGN expr

    VOID_RW    shift, and go to state 152
    ANY        shift, and go to state 153
    BOOLTYPE   shift, and go to state 154
    NEVER      shift, and go to state 155
    NUMBER     shift, and go to state 156
    STRING     shift, and go to state 157
    UNDEFINED  shift, and go to state 158

    var-type  go to state 254


State 188

  101 var-declr: var-declr-rw id-list ASSIGN . expr
  102          | var-declr-rw id-list ASSIGN . obj-def

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACE       shift, and go to state 237
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    TRUE_RW      shift, and go to state 24

    logic-expr       go to state 36
    obj-def          go to state 255
    expr             go to state 256
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 189

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  153 arit-expr: expr . PLUS expr
  153          | expr PLUS expr .
  154          | expr . SUB expr
  155          | expr . MULT expr
  156          | expr . DIV expr
  157          | expr . EXP expr
  158          | expr . REM expr
  159 bitw-expr: expr . BITWISE_AND expr
  160          | expr . BITWISE_OR expr
  161          | expr . BITWISE_XOR expr
  162 shift-expr: expr . LSHIFT expr
  163           | expr . RSHIFT expr
  164           | expr . RSHIFT_UNSIGNED expr

    MULT  shift, and go to state 117
    DIV   shift, and go to state 118
    EXP   shift, and go to state 119
    REM   shift, and go to state 120

    $default  reduce using rule 153 (arit-expr)


State 190

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  153 arit-expr: expr . PLUS expr
  154          | expr . SUB expr
  154          | expr SUB expr .
  155          | expr . MULT expr
  156          | expr . DIV expr
  157          | expr . EXP expr
  158          | expr . REM expr
  159 bitw-expr: expr . BITWISE_AND expr
  160          | expr . BITWISE_OR expr
  161          | expr . BITWISE_XOR expr
  162 shift-expr: expr . LSHIFT expr
  163           | expr . RSHIFT expr
  164           | expr . RSHIFT_UNSIGNED expr

    MULT  shift, and go to state 117
    DIV   shift, and go to state 118
    EXP   shift, and go to state 119
    REM   shift, and go to state 120

    $default  reduce using rule 154 (arit-expr)


State 191

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  153 arit-expr: expr . PLUS expr
  154          | expr . SUB expr
  155          | expr . MULT expr
  155          | expr MULT expr .
  156          | expr . DIV expr
  157          | expr . EXP expr
  158          | expr . REM expr
  159 bitw-expr: expr . BITWISE_AND expr
  160          | expr . BITWISE_OR expr
  161          | expr . BITWISE_XOR expr
  162 shift-expr: expr . LSHIFT expr
  163           | expr . RSHIFT expr
  164           | expr . RSHIFT_UNSIGNED expr

    EXP  shift, and go to state 119

    $default  reduce using rule 155 (arit-expr)


State 192

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  153 arit-expr: expr . PLUS expr
  154          | expr . SUB expr
  155          | expr . MULT expr
  156          | expr . DIV expr
  156          | expr DIV expr .
  157          | expr . EXP expr
  158          | expr . REM expr
  159 bitw-expr: expr . BITWISE_AND expr
  160          | expr . BITWISE_OR expr
  161          | expr . BITWISE_XOR expr
  162 shift-expr: expr . LSHIFT expr
  163           | expr . RSHIFT expr
  164           | expr . RSHIFT_UNSIGNED expr

    EXP  shift, and go to state 119

    $default  reduce using rule 156 (arit-expr)


State 193

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  153 arit-expr: expr . PLUS expr
  154          | expr . SUB expr
  155          | expr . MULT expr
  156          | expr . DIV expr
  157          | expr . EXP expr
  157          | expr EXP expr .
  158          | expr . REM expr
  159 bitw-expr: expr . BITWISE_AND expr
  160          | expr . BITWISE_OR expr
  161          | expr . BITWISE_XOR expr
  162 shift-expr: expr . LSHIFT expr
  163           | expr . RSHIFT expr
  164           | expr . RSHIFT_UNSIGNED expr

    EXP  shift, and go to state 119

    $default  reduce using rule 157 (arit-expr)


State 194

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  153 arit-expr: expr . PLUS expr
  154          | expr . SUB expr
  155          | expr . MULT expr
  156          | expr . DIV expr
  157          | expr . EXP expr
  158          | expr . REM expr
  158          | expr REM expr .
  159 bitw-expr: expr . BITWISE_AND expr
  160          | expr . BITWISE_OR expr
  161          | expr . BITWISE_XOR expr
  162 shift-expr: expr . LSHIFT expr
  163           | expr . RSHIFT expr
  164           | expr . RSHIFT_UNSIGNED expr

    EXP  shift, and go to state 119

    $default  reduce using rule 158 (arit-expr)


State 195

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  153 arit-expr: expr . PLUS expr
  154          | expr . SUB expr
  155          | expr . MULT expr
  156          | expr . DIV expr
  157          | expr . EXP expr
  158          | expr . REM expr
  159 bitw-expr: expr . BITWISE_AND expr
  159          | expr BITWISE_AND expr .
  160          | expr . BITWISE_OR expr
  161          | expr . BITWISE_XOR expr
  162 shift-expr: expr . LSHIFT expr
  163           | expr . RSHIFT expr
  164           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 115
    SUB              shift, and go to state 116
    MULT             shift, and go to state 117
    DIV              shift, and go to state 118
    EXP              shift, and go to state 119
    REM              shift, and go to state 120
    LSHIFT           shift, and go to state 135
    RSHIFT           shift, and go to state 136
    RSHIFT_UNSIGNED  shift, and go to state 137

    $default  reduce using rule 159 (bitw-expr)


State 196

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  153 arit-expr: expr . PLUS expr
  154          | expr . SUB expr
  155          | expr . MULT expr
  156          | expr . DIV expr
  157          | expr . EXP expr
  158          | expr . REM expr
  159 bitw-expr: expr . BITWISE_AND expr
  160          | expr . BITWISE_OR expr
  160          | expr BITWISE_OR expr .
  161          | expr . BITWISE_XOR expr
  162 shift-expr: expr . LSHIFT expr
  163           | expr . RSHIFT expr
  164           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 115
    SUB              shift, and go to state 116
    MULT             shift, and go to state 117
    DIV              shift, and go to state 118
    EXP              shift, and go to state 119
    REM              shift, and go to state 120
    BITWISE_AND      shift, and go to state 121
    BITWISE_XOR      shift, and go to state 123
    LSHIFT           shift, and go to state 135
    RSHIFT           shift, and go to state 136
    RSHIFT_UNSIGNED  shift, and go to state 137

    $default  reduce using rule 160 (bitw-expr)


State 197

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  153 arit-expr: expr . PLUS expr
  154          | expr . SUB expr
  155          | expr . MULT expr
  156          | expr . DIV expr
  157          | expr . EXP expr
  158          | expr . REM expr
  159 bitw-expr: expr . BITWISE_AND expr
  160          | expr . BITWISE_OR expr
  161          | expr . BITWISE_XOR expr
  161          | expr BITWISE_XOR expr .
  162 shift-expr: expr . LSHIFT expr
  163           | expr . RSHIFT expr
  164           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 115
    SUB              shift, and go to state 116
    MULT             shift, and go to state 117
    DIV              shift, and go to state 118
    EXP              shift, and go to state 119
    REM              shift, and go to state 120
    BITWISE_AND      shift, and go to state 121
    LSHIFT           shift, and go to state 135
    RSHIFT           shift, and go to state 136
    RSHIFT_UNSIGNED  shift, and go to state 137

    $default  reduce using rule 161 (bitw-expr)


State 198

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   75           | expr LOGICAL_NULL expr .
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  153 arit-expr: expr . PLUS expr
  154          | expr . SUB expr
  155          | expr . MULT expr
  156          | expr . DIV expr
  157          | expr . EXP expr
  158          | expr . REM expr
  159 bitw-expr: expr . BITWISE_AND expr
  160          | expr . BITWISE_OR expr
  161          | expr . BITWISE_XOR expr
  162 shift-expr: expr . LSHIFT expr
  163           | expr . RSHIFT expr
  164           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 115
    SUB              shift, and go to state 116
    MULT             shift, and go to state 117
    DIV              shift, and go to state 118
    EXP              shift, and go to state 119
    REM              shift, and go to state 120
    BITWISE_AND      shift, and go to state 121
    BITWISE_OR       shift, and go to state 122
    BITWISE_XOR      shift, and go to state 123
    EQ               shift, and go to state 127
    EQ_STRICT        shift, and go to state 128
    INEQ             shift, and go to state 129
    INEQ_STRICT      shift, and go to state 130
    LT               shift, and go to state 131
    LT_EQ            shift, and go to state 132
    GT               shift, and go to state 133
    GT_EQ            shift, and go to state 134
    LSHIFT           shift, and go to state 135
    RSHIFT           shift, and go to state 136
    RSHIFT_UNSIGNED  shift, and go to state 137

    $default  reduce using rule 75 (logic-expr)


State 199

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   76           | expr LOGICAL_AND expr .
   77           | expr . LOGICAL_OR expr
  153 arit-expr: expr . PLUS expr
  154          | expr . SUB expr
  155          | expr . MULT expr
  156          | expr . DIV expr
  157          | expr . EXP expr
  158          | expr . REM expr
  159 bitw-expr: expr . BITWISE_AND expr
  160          | expr . BITWISE_OR expr
  161          | expr . BITWISE_XOR expr
  162 shift-expr: expr . LSHIFT expr
  163           | expr . RSHIFT expr
  164           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 115
    SUB              shift, and go to state 116
    MULT             shift, and go to state 117
    DIV              shift, and go to state 118
    EXP              shift, and go to state 119
    REM              shift, and go to state 120
    BITWISE_AND      shift, and go to state 121
    BITWISE_OR       shift, and go to state 122
    BITWISE_XOR      shift, and go to state 123
    EQ               shift, and go to state 127
    EQ_STRICT        shift, and go to state 128
    INEQ             shift, and go to state 129
    INEQ_STRICT      shift, and go to state 130
    LT               shift, and go to state 131
    LT_EQ            shift, and go to state 132
    GT               shift, and go to state 133
    GT_EQ            shift, and go to state 134
    LSHIFT           shift, and go to state 135
    RSHIFT           shift, and go to state 136
    RSHIFT_UNSIGNED  shift, and go to state 137

    $default  reduce using rule 76 (logic-expr)


State 200

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
   77           | expr LOGICAL_OR expr .
  153 arit-expr: expr . PLUS expr
  154          | expr . SUB expr
  155          | expr . MULT expr
  156          | expr . DIV expr
  157          | expr . EXP expr
  158          | expr . REM expr
  159 bitw-expr: expr . BITWISE_AND expr
  160          | expr . BITWISE_OR expr
  161          | expr . BITWISE_XOR expr
  162 shift-expr: expr . LSHIFT expr
  163           | expr . RSHIFT expr
  164           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 115
    SUB              shift, and go to state 116
    MULT             shift, and go to state 117
    DIV              shift, and go to state 118
    EXP              shift, and go to state 119
    REM              shift, and go to state 120
    BITWISE_AND      shift, and go to state 121
    BITWISE_OR       shift, and go to state 122
    BITWISE_XOR      shift, and go to state 123
    EQ               shift, and go to state 127
    EQ_STRICT        shift, and go to state 128
    INEQ             shift, and go to state 129
    INEQ_STRICT      shift, and go to state 130
    LT               shift, and go to state 131
    LT_EQ            shift, and go to state 132
    GT               shift, and go to state 133
    GT_EQ            shift, and go to state 134
    LSHIFT           shift, and go to state 135
    RSHIFT           shift, and go to state 136
    RSHIFT_UNSIGNED  shift, and go to state 137

    $default  reduce using rule 77 (logic-expr)


State 201

   66 logic-expr: expr . EQ expr
   66           | expr EQ expr .
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  153 arit-expr: expr . PLUS expr
  154          | expr . SUB expr
  155          | expr . MULT expr
  156          | expr . DIV expr
  157          | expr . EXP expr
  158          | expr . REM expr
  159 bitw-expr: expr . BITWISE_AND expr
  160          | expr . BITWISE_OR expr
  161          | expr . BITWISE_XOR expr
  162 shift-expr: expr . LSHIFT expr
  163           | expr . RSHIFT expr
  164           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 115
    SUB              shift, and go to state 116
    MULT             shift, and go to state 117
    DIV              shift, and go to state 118
    EXP              shift, and go to state 119
    REM              shift, and go to state 120
    BITWISE_AND      shift, and go to state 121
    BITWISE_OR       shift, and go to state 122
    BITWISE_XOR      shift, and go to state 123
    LSHIFT           shift, and go to state 135
    RSHIFT           shift, and go to state 136
    RSHIFT_UNSIGNED  shift, and go to state 137

    $default  reduce using rule 66 (logic-expr)


State 202

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   67           | expr EQ_STRICT expr .
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  153 arit-expr: expr . PLUS expr
  154          | expr . SUB expr
  155          | expr . MULT expr
  156          | expr . DIV expr
  157          | expr . EXP expr
  158          | expr . REM expr
  159 bitw-expr: expr . BITWISE_AND expr
  160          | expr . BITWISE_OR expr
  161          | expr . BITWISE_XOR expr
  162 shift-expr: expr . LSHIFT expr
  163           | expr . RSHIFT expr
  164           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 115
    SUB              shift, and go to state 116
    MULT             shift, and go to state 117
    DIV              shift, and go to state 118
    EXP              shift, and go to state 119
    REM              shift, and go to state 120
    BITWISE_AND      shift, and go to state 121
    BITWISE_OR       shift, and go to state 122
    BITWISE_XOR      shift, and go to state 123
    LSHIFT           shift, and go to state 135
    RSHIFT           shift, and go to state 136
    RSHIFT_UNSIGNED  shift, and go to state 137

    $default  reduce using rule 67 (logic-expr)


State 203

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   68           | expr INEQ expr .
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  153 arit-expr: expr . PLUS expr
  154          | expr . SUB expr
  155          | expr . MULT expr
  156          | expr . DIV expr
  157          | expr . EXP expr
  158          | expr . REM expr
  159 bitw-expr: expr . BITWISE_AND expr
  160          | expr . BITWISE_OR expr
  161          | expr . BITWISE_XOR expr
  162 shift-expr: expr . LSHIFT expr
  163           | expr . RSHIFT expr
  164           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 115
    SUB              shift, and go to state 116
    MULT             shift, and go to state 117
    DIV              shift, and go to state 118
    EXP              shift, and go to state 119
    REM              shift, and go to state 120
    BITWISE_AND      shift, and go to state 121
    BITWISE_OR       shift, and go to state 122
    BITWISE_XOR      shift, and go to state 123
    LSHIFT           shift, and go to state 135
    RSHIFT           shift, and go to state 136
    RSHIFT_UNSIGNED  shift, and go to state 137

    $default  reduce using rule 68 (logic-expr)


State 204

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   69           | expr INEQ_STRICT expr .
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  153 arit-expr: expr . PLUS expr
  154          | expr . SUB expr
  155          | expr . MULT expr
  156          | expr . DIV expr
  157          | expr . EXP expr
  158          | expr . REM expr
  159 bitw-expr: expr . BITWISE_AND expr
  160          | expr . BITWISE_OR expr
  161          | expr . BITWISE_XOR expr
  162 shift-expr: expr . LSHIFT expr
  163           | expr . RSHIFT expr
  164           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 115
    SUB              shift, and go to state 116
    MULT             shift, and go to state 117
    DIV              shift, and go to state 118
    EXP              shift, and go to state 119
    REM              shift, and go to state 120
    BITWISE_AND      shift, and go to state 121
    BITWISE_OR       shift, and go to state 122
    BITWISE_XOR      shift, and go to state 123
    LSHIFT           shift, and go to state 135
    RSHIFT           shift, and go to state 136
    RSHIFT_UNSIGNED  shift, and go to state 137

    $default  reduce using rule 69 (logic-expr)


State 205

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   70           | expr LT expr .
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  153 arit-expr: expr . PLUS expr
  154          | expr . SUB expr
  155          | expr . MULT expr
  156          | expr . DIV expr
  157          | expr . EXP expr
  158          | expr . REM expr
  159 bitw-expr: expr . BITWISE_AND expr
  160          | expr . BITWISE_OR expr
  161          | expr . BITWISE_XOR expr
  162 shift-expr: expr . LSHIFT expr
  163           | expr . RSHIFT expr
  164           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 115
    SUB              shift, and go to state 116
    MULT             shift, and go to state 117
    DIV              shift, and go to state 118
    EXP              shift, and go to state 119
    REM              shift, and go to state 120
    BITWISE_AND      shift, and go to state 121
    BITWISE_OR       shift, and go to state 122
    BITWISE_XOR      shift, and go to state 123
    LSHIFT           shift, and go to state 135
    RSHIFT           shift, and go to state 136
    RSHIFT_UNSIGNED  shift, and go to state 137

    $default  reduce using rule 70 (logic-expr)


State 206

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   72           | expr LT_EQ expr .
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  153 arit-expr: expr . PLUS expr
  154          | expr . SUB expr
  155          | expr . MULT expr
  156          | expr . DIV expr
  157          | expr . EXP expr
  158          | expr . REM expr
  159 bitw-expr: expr . BITWISE_AND expr
  160          | expr . BITWISE_OR expr
  161          | expr . BITWISE_XOR expr
  162 shift-expr: expr . LSHIFT expr
  163           | expr . RSHIFT expr
  164           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 115
    SUB              shift, and go to state 116
    MULT             shift, and go to state 117
    DIV              shift, and go to state 118
    EXP              shift, and go to state 119
    REM              shift, and go to state 120
    BITWISE_AND      shift, and go to state 121
    BITWISE_OR       shift, and go to state 122
    BITWISE_XOR      shift, and go to state 123
    LSHIFT           shift, and go to state 135
    RSHIFT           shift, and go to state 136
    RSHIFT_UNSIGNED  shift, and go to state 137

    $default  reduce using rule 72 (logic-expr)


State 207

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   73           | expr GT expr .
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  153 arit-expr: expr . PLUS expr
  154          | expr . SUB expr
  155          | expr . MULT expr
  156          | expr . DIV expr
  157          | expr . EXP expr
  158          | expr . REM expr
  159 bitw-expr: expr . BITWISE_AND expr
  160          | expr . BITWISE_OR expr
  161          | expr . BITWISE_XOR expr
  162 shift-expr: expr . LSHIFT expr
  163           | expr . RSHIFT expr
  164           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 115
    SUB              shift, and go to state 116
    MULT             shift, and go to state 117
    DIV              shift, and go to state 118
    EXP              shift, and go to state 119
    REM              shift, and go to state 120
    BITWISE_AND      shift, and go to state 121
    BITWISE_OR       shift, and go to state 122
    BITWISE_XOR      shift, and go to state 123
    LSHIFT           shift, and go to state 135
    RSHIFT           shift, and go to state 136
    RSHIFT_UNSIGNED  shift, and go to state 137

    $default  reduce using rule 73 (logic-expr)


State 208

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   74           | expr GT_EQ expr .
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  153 arit-expr: expr . PLUS expr
  154          | expr . SUB expr
  155          | expr . MULT expr
  156          | expr . DIV expr
  157          | expr . EXP expr
  158          | expr . REM expr
  159 bitw-expr: expr . BITWISE_AND expr
  160          | expr . BITWISE_OR expr
  161          | expr . BITWISE_XOR expr
  162 shift-expr: expr . LSHIFT expr
  163           | expr . RSHIFT expr
  164           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 115
    SUB              shift, and go to state 116
    MULT             shift, and go to state 117
    DIV              shift, and go to state 118
    EXP              shift, and go to state 119
    REM              shift, and go to state 120
    BITWISE_AND      shift, and go to state 121
    BITWISE_OR       shift, and go to state 122
    BITWISE_XOR      shift, and go to state 123
    LSHIFT           shift, and go to state 135
    RSHIFT           shift, and go to state 136
    RSHIFT_UNSIGNED  shift, and go to state 137

    $default  reduce using rule 74 (logic-expr)


State 209

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  153 arit-expr: expr . PLUS expr
  154          | expr . SUB expr
  155          | expr . MULT expr
  156          | expr . DIV expr
  157          | expr . EXP expr
  158          | expr . REM expr
  159 bitw-expr: expr . BITWISE_AND expr
  160          | expr . BITWISE_OR expr
  161          | expr . BITWISE_XOR expr
  162 shift-expr: expr . LSHIFT expr
  162           | expr LSHIFT expr .
  163           | expr . RSHIFT expr
  164           | expr . RSHIFT_UNSIGNED expr

    PLUS  shift, and go to state 115
    SUB   shift, and go to state 116
    MULT  shift, and go to state 117
    DIV   shift, and go to state 118
    EXP   shift, and go to state 119
    REM   shift, and go to state 120

    $default  reduce using rule 162 (shift-expr)


State 210

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  153 arit-expr: expr . PLUS expr
  154          | expr . SUB expr
  155          | expr . MULT expr
  156          | expr . DIV expr
  157          | expr . EXP expr
  158          | expr . REM expr
  159 bitw-expr: expr . BITWISE_AND expr
  160          | expr . BITWISE_OR expr
  161          | expr . BITWISE_XOR expr
  162 shift-expr: expr . LSHIFT expr
  163           | expr . RSHIFT expr
  163           | expr RSHIFT expr .
  164           | expr . RSHIFT_UNSIGNED expr

    PLUS  shift, and go to state 115
    SUB   shift, and go to state 116
    MULT  shift, and go to state 117
    DIV   shift, and go to state 118
    EXP   shift, and go to state 119
    REM   shift, and go to state 120

    $default  reduce using rule 163 (shift-expr)


State 211

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  153 arit-expr: expr . PLUS expr
  154          | expr . SUB expr
  155          | expr . MULT expr
  156          | expr . DIV expr
  157          | expr . EXP expr
  158          | expr . REM expr
  159 bitw-expr: expr . BITWISE_AND expr
  160          | expr . BITWISE_OR expr
  161          | expr . BITWISE_XOR expr
  162 shift-expr: expr . LSHIFT expr
  163           | expr . RSHIFT expr
  164           | expr . RSHIFT_UNSIGNED expr
  164           | expr RSHIFT_UNSIGNED expr .

    PLUS  shift, and go to state 115
    SUB   shift, and go to state 116
    MULT  shift, and go to state 117
    DIV   shift, and go to state 118
    EXP   shift, and go to state 119
    REM   shift, and go to state 120

    $default  reduce using rule 164 (shift-expr)


State 212

   21 assign-expr: vet-idx assignment expr .
   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  153 arit-expr: expr . PLUS expr
  154          | expr . SUB expr
  155          | expr . MULT expr
  156          | expr . DIV expr
  157          | expr . EXP expr
  158          | expr . REM expr
  159 bitw-expr: expr . BITWISE_AND expr
  160          | expr . BITWISE_OR expr
  161          | expr . BITWISE_XOR expr
  162 shift-expr: expr . LSHIFT expr
  163           | expr . RSHIFT expr
  164           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 115
    SUB              shift, and go to state 116
    MULT             shift, and go to state 117
    DIV              shift, and go to state 118
    EXP              shift, and go to state 119
    REM              shift, and go to state 120
    BITWISE_AND      shift, and go to state 121
    BITWISE_OR       shift, and go to state 122
    BITWISE_XOR      shift, and go to state 123
    LOGICAL_NULL     shift, and go to state 124
    LOGICAL_AND      shift, and go to state 125
    LOGICAL_OR       shift, and go to state 126
    EQ               shift, and go to state 127
    EQ_STRICT        shift, and go to state 128
    INEQ             shift, and go to state 129
    INEQ_STRICT      shift, and go to state 130
    LT               shift, and go to state 131
    LT_EQ            shift, and go to state 132
    GT               shift, and go to state 133
    GT_EQ            shift, and go to state 134
    LSHIFT           shift, and go to state 135
    RSHIFT           shift, and go to state 136
    RSHIFT_UNSIGNED  shift, and go to state 137

    $default  reduce using rule 21 (assign-expr)


State 213

  166 var-att: var-att DOT ID .
  172 var-met: ID . LPAR args-list RPAR

    LPAR  shift, and go to state 144

    $default  reduce using rule 166 (var-att)


State 214

  170 var-att: var-att DOT var-met .

    $default  reduce using rule 170 (var-att)


State 215

   19 assign-expr: var-att assignment expr .
   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  153 arit-expr: expr . PLUS expr
  154          | expr . SUB expr
  155          | expr . MULT expr
  156          | expr . DIV expr
  157          | expr . EXP expr
  158          | expr . REM expr
  159 bitw-expr: expr . BITWISE_AND expr
  160          | expr . BITWISE_OR expr
  161          | expr . BITWISE_XOR expr
  162 shift-expr: expr . LSHIFT expr
  163           | expr . RSHIFT expr
  164           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 115
    SUB              shift, and go to state 116
    MULT             shift, and go to state 117
    DIV              shift, and go to state 118
    EXP              shift, and go to state 119
    REM              shift, and go to state 120
    BITWISE_AND      shift, and go to state 121
    BITWISE_OR       shift, and go to state 122
    BITWISE_XOR      shift, and go to state 123
    LOGICAL_NULL     shift, and go to state 124
    LOGICAL_AND      shift, and go to state 125
    LOGICAL_OR       shift, and go to state 126
    EQ               shift, and go to state 127
    EQ_STRICT        shift, and go to state 128
    INEQ             shift, and go to state 129
    INEQ_STRICT      shift, and go to state 130
    LT               shift, and go to state 131
    LT_EQ            shift, and go to state 132
    GT               shift, and go to state 133
    GT_EQ            shift, and go to state 134
    LSHIFT           shift, and go to state 135
    RSHIFT           shift, and go to state 136
    RSHIFT_UNSIGNED  shift, and go to state 137

    $default  reduce using rule 19 (assign-expr)


State 216

  165 var-att: ID . DOT var-att
  167        | ID . DOT var-met
  168        | var-met DOT ID .
  171        | ID . DOT ID
  172 var-met: ID . LPAR args-list RPAR

    DOT   shift, and go to state 73
    LPAR  shift, and go to state 144

    $default  reduce using rule 168 (var-att)


State 217

  166 var-att: var-att . DOT ID
  169        | var-met DOT var-att .
  170        | var-att . DOT var-met

    DOT  shift, and go to state 139

    $default  reduce using rule 169 (var-att)


State 218

  172 var-met: ID LPAR args-list . RPAR

    RPAR  shift, and go to state 257


State 219

  195 elmts-list: var-val COMMA elmts-list .

    $default  reduce using rule 195 (elmts-list)


State 220

  180 var-obj: ID LT var-type GT . LPAR args-list RPAR

    LPAR  shift, and go to state 258


State 221

  173 args-list: COMMA args-list .

    $default  reduce using rule 173 (args-list)


State 222

  175 args-list: assign-expr COMMA . args-list

    COMMA        shift, and go to state 161
    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    TRUE_RW      shift, and go to state 24

    $default  reduce using rule 178 (args-list)

    assign-expr      go to state 162
    logic-expr       go to state 36
    expr             go to state 163
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    args-list        go to state 259
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 223

  174 args-list: expr COMMA . args-list

    COMMA        shift, and go to state 161
    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    TRUE_RW      shift, and go to state 24

    $default  reduce using rule 178 (args-list)

    assign-expr      go to state 162
    logic-expr       go to state 36
    expr             go to state 163
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    args-list        go to state 260
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 224

  172 var-met: ID LPAR args-list RPAR .
  179 var-obj: ID LPAR args-list RPAR .

    DOT       reduce using rule 172 (var-met)
    $default  reduce using rule 179 (var-obj)


State 225

  142 vet-idx: ID LBRACKET idx-safe-expr RBRACKET .

    $default  reduce using rule 142 (vet-idx)


State 226

   79 class-att-list: SEMI . class-att-list

    SEMI       shift, and go to state 226
    ID         shift, and go to state 227
    PRIVATE    shift, and go to state 228
    PROTECTED  shift, and go to state 229
    PUBLIC     shift, and go to state 230

    $default  reduce using rule 82 (class-att-list)

    class-att-list  go to state 261
    class-att       go to state 232
    access-modif    go to state 233


State 227

   83 class-att: ID . COLON var-type
   85          | ID . LPAR params RPAR LBRACE line RBRACE
   86          | ID . LPAR params RPAR COLON var-type LBRACE line RBRACE

    COLON  shift, and go to state 262
    LPAR   shift, and go to state 263


State 228

   88 access-modif: PRIVATE .

    $default  reduce using rule 88 (access-modif)


State 229

   89 access-modif: PROTECTED .

    $default  reduce using rule 89 (access-modif)


State 230

   87 access-modif: PUBLIC .

    $default  reduce using rule 87 (access-modif)


State 231

   78 class-def: CLASS ID LBRACE class-att-list . RBRACE

    RBRACE  shift, and go to state 264


State 232

   80 class-att-list: class-att . SEMI class-att-list
   81               | class-att .

    SEMI  shift, and go to state 265

    $default  reduce using rule 81 (class-att-list)


State 233

   84 class-att: access-modif . ID COLON var-type

    ID  shift, and go to state 266


State 234

  113 id-list: ID . COMMA id-list
  114        | ID .

    COMMA  shift, and go to state 169

    $default  reduce using rule 114 (id-list)


State 235

  113 id-list: ID COMMA id-list .

    $default  reduce using rule 113 (id-list)


State 236

  108 var-declr: CONST_RW ID COLON var-type . ASSIGN expr
  109          | CONST_RW ID COLON var-type . LBRACKET RBRACKET ASSIGN expr

    ASSIGN    shift, and go to state 267
    LBRACKET  shift, and go to state 268


State 237

  115 obj-def: LBRACE . obj-att-list RBRACE

    COMMA  shift, and go to state 269
    ID     shift, and go to state 270

    $default  reduce using rule 119 (obj-att-list)

    obj-att-list  go to state 271
    obj-att       go to state 272


State 238

  110 var-declr: CONST_RW id-list ASSIGN obj-def .

    $default  reduce using rule 110 (var-declr)


State 239

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  107 var-declr: CONST_RW id-list ASSIGN expr .
  153 arit-expr: expr . PLUS expr
  154          | expr . SUB expr
  155          | expr . MULT expr
  156          | expr . DIV expr
  157          | expr . EXP expr
  158          | expr . REM expr
  159 bitw-expr: expr . BITWISE_AND expr
  160          | expr . BITWISE_OR expr
  161          | expr . BITWISE_XOR expr
  162 shift-expr: expr . LSHIFT expr
  163           | expr . RSHIFT expr
  164           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 115
    SUB              shift, and go to state 116
    MULT             shift, and go to state 117
    DIV              shift, and go to state 118
    EXP              shift, and go to state 119
    REM              shift, and go to state 120
    BITWISE_AND      shift, and go to state 121
    BITWISE_OR       shift, and go to state 122
    BITWISE_XOR      shift, and go to state 123
    LOGICAL_NULL     shift, and go to state 124
    LOGICAL_AND      shift, and go to state 125
    LOGICAL_OR       shift, and go to state 126
    EQ               shift, and go to state 127
    EQ_STRICT        shift, and go to state 128
    INEQ             shift, and go to state 129
    INEQ_STRICT      shift, and go to state 130
    LT               shift, and go to state 131
    LT_EQ            shift, and go to state 132
    GT               shift, and go to state 133
    GT_EQ            shift, and go to state 134
    LSHIFT           shift, and go to state 135
    RSHIFT           shift, and go to state 136
    RSHIFT_UNSIGNED  shift, and go to state 137

    $default  reduce using rule 107 (var-declr)


State 240

   56 do-while-stmt: DO LBRACE line RBRACE . WHILE LPAR expr RPAR
   57              | DO LBRACE line RBRACE . WHILE LPAR assign-expr RPAR

    WHILE  shift, and go to state 273


State 241

   37 for-stmt: FOR LPAR SEMI SEMI . expr RPAR LBRACE line RBRACE
   38         | FOR LPAR SEMI SEMI . assign-expr RPAR LBRACE line RBRACE
   39         | FOR LPAR SEMI SEMI . RPAR LBRACE line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    RPAR         shift, and go to state 274
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    TRUE_RW      shift, and go to state 24

    assign-expr      go to state 275
    logic-expr       go to state 36
    expr             go to state 276
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 242

   34 for-stmt: FOR LPAR SEMI expr . SEMI expr RPAR LBRACE line RBRACE
   35         | FOR LPAR SEMI expr . SEMI assign-expr RPAR LBRACE line RBRACE
   36         | FOR LPAR SEMI expr . SEMI RPAR LBRACE line RBRACE
   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  153 arit-expr: expr . PLUS expr
  154          | expr . SUB expr
  155          | expr . MULT expr
  156          | expr . DIV expr
  157          | expr . EXP expr
  158          | expr . REM expr
  159 bitw-expr: expr . BITWISE_AND expr
  160          | expr . BITWISE_OR expr
  161          | expr . BITWISE_XOR expr
  162 shift-expr: expr . LSHIFT expr
  163           | expr . RSHIFT expr
  164           | expr . RSHIFT_UNSIGNED expr

    SEMI             shift, and go to state 277
    PLUS             shift, and go to state 115
    SUB              shift, and go to state 116
    MULT             shift, and go to state 117
    DIV              shift, and go to state 118
    EXP              shift, and go to state 119
    REM              shift, and go to state 120
    BITWISE_AND      shift, and go to state 121
    BITWISE_OR       shift, and go to state 122
    BITWISE_XOR      shift, and go to state 123
    LOGICAL_NULL     shift, and go to state 124
    LOGICAL_AND      shift, and go to state 125
    LOGICAL_OR       shift, and go to state 126
    EQ               shift, and go to state 127
    EQ_STRICT        shift, and go to state 128
    INEQ             shift, and go to state 129
    INEQ_STRICT      shift, and go to state 130
    LT               shift, and go to state 131
    LT_EQ            shift, and go to state 132
    GT               shift, and go to state 133
    GT_EQ            shift, and go to state 134
    LSHIFT           shift, and go to state 135
    RSHIFT           shift, and go to state 136
    RSHIFT_UNSIGNED  shift, and go to state 137


State 243

   22 for-stmt: FOR LPAR assign-expr SEMI . expr SEMI expr RPAR LBRACE line RBRACE
   23         | FOR LPAR assign-expr SEMI . expr SEMI assign-expr RPAR LBRACE line RBRACE
   24         | FOR LPAR assign-expr SEMI . expr SEMI RPAR LBRACE line RBRACE
   25         | FOR LPAR assign-expr SEMI . SEMI expr RPAR LBRACE line RBRACE
   26         | FOR LPAR assign-expr SEMI . SEMI assign-expr RPAR LBRACE line RBRACE
   27         | FOR LPAR assign-expr SEMI . SEMI RPAR LBRACE line RBRACE

    SEMI         shift, and go to state 278
    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    TRUE_RW      shift, and go to state 24

    logic-expr       go to state 36
    expr             go to state 279
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 244

   28 for-stmt: FOR LPAR var-declr SEMI . expr SEMI expr RPAR LBRACE line RBRACE
   29         | FOR LPAR var-declr SEMI . expr SEMI assign-expr RPAR LBRACE line RBRACE
   30         | FOR LPAR var-declr SEMI . expr SEMI RPAR LBRACE line RBRACE
   31         | FOR LPAR var-declr SEMI . SEMI expr RPAR LBRACE line RBRACE
   32         | FOR LPAR var-declr SEMI . SEMI assign-expr RPAR LBRACE line RBRACE
   33         | FOR LPAR var-declr SEMI . SEMI RPAR LBRACE line RBRACE

    SEMI         shift, and go to state 280
    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    TRUE_RW      shift, and go to state 24

    logic-expr       go to state 36
    expr             go to state 281
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 245

   92 params: COMMA . ID
   93       | COMMA . ID COLON var-type

    ID  shift, and go to state 282


State 246

   94 params: ID . COMMA ID
   95       | ID . COLON var-type COMMA ID COLON var-type
   96       | ID . COLON var-type COMMA ID
   97       | ID . COLON var-type
   98       | ID . COMMA ID COLON var-type

    COMMA  shift, and go to state 283
    COLON  shift, and go to state 284


State 247

   90 func-def: FUNCTION ID LPAR params . RPAR LBRACE line RBRACE
   91         | FUNCTION ID LPAR params . RPAR COLON var-type LBRACE line RBRACE

    RPAR  shift, and go to state 285


State 248

   63 if-stmt: IF LPAR assign-expr RPAR . LBRACE line RBRACE
   64        | IF LPAR assign-expr RPAR . LBRACE line RBRACE ELSE LBRACE line RBRACE
   65        | IF LPAR assign-expr RPAR . LBRACE line RBRACE ELSE stmt

    LBRACE  shift, and go to state 286


State 249

   60 if-stmt: IF LPAR expr RPAR . LBRACE line RBRACE
   61        | IF LPAR expr RPAR . LBRACE line RBRACE ELSE LBRACE line RBRACE
   62        | IF LPAR expr RPAR . LBRACE line RBRACE ELSE stmt

    LBRACE  shift, and go to state 287


State 250

  182 var-obj: NEW ID LT var-type . GT LPAR args-list RPAR

    GT  shift, and go to state 288


State 251

  181 var-obj: NEW ID LPAR args-list . RPAR

    RPAR  shift, and go to state 289


State 252

   59 while-stmt: WHILE LPAR assign-expr RPAR . LBRACE line RBRACE

    LBRACE  shift, and go to state 290


State 253

   58 while-stmt: WHILE LPAR expr RPAR . LBRACE line RBRACE

    LBRACE  shift, and go to state 291


State 254

  103 var-declr: var-declr-rw ID COLON var-type .
  104          | var-declr-rw ID COLON var-type . ASSIGN expr
  105          | var-declr-rw ID COLON var-type . LBRACKET RBRACKET
  106          | var-declr-rw ID COLON var-type . LBRACKET RBRACKET ASSIGN expr

    ASSIGN    shift, and go to state 292
    LBRACKET  shift, and go to state 293

    $default  reduce using rule 103 (var-declr)


State 255

  102 var-declr: var-declr-rw id-list ASSIGN obj-def .

    $default  reduce using rule 102 (var-declr)


State 256

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  101 var-declr: var-declr-rw id-list ASSIGN expr .
  153 arit-expr: expr . PLUS expr
  154          | expr . SUB expr
  155          | expr . MULT expr
  156          | expr . DIV expr
  157          | expr . EXP expr
  158          | expr . REM expr
  159 bitw-expr: expr . BITWISE_AND expr
  160          | expr . BITWISE_OR expr
  161          | expr . BITWISE_XOR expr
  162 shift-expr: expr . LSHIFT expr
  163           | expr . RSHIFT expr
  164           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 115
    SUB              shift, and go to state 116
    MULT             shift, and go to state 117
    DIV              shift, and go to state 118
    EXP              shift, and go to state 119
    REM              shift, and go to state 120
    BITWISE_AND      shift, and go to state 121
    BITWISE_OR       shift, and go to state 122
    BITWISE_XOR      shift, and go to state 123
    LOGICAL_NULL     shift, and go to state 124
    LOGICAL_AND      shift, and go to state 125
    LOGICAL_OR       shift, and go to state 126
    EQ               shift, and go to state 127
    EQ_STRICT        shift, and go to state 128
    INEQ             shift, and go to state 129
    INEQ_STRICT      shift, and go to state 130
    LT               shift, and go to state 131
    LT_EQ            shift, and go to state 132
    GT               shift, and go to state 133
    GT_EQ            shift, and go to state 134
    LSHIFT           shift, and go to state 135
    RSHIFT           shift, and go to state 136
    RSHIFT_UNSIGNED  shift, and go to state 137

    $default  reduce using rule 101 (var-declr)


State 257

  172 var-met: ID LPAR args-list RPAR .

    $default  reduce using rule 172 (var-met)


State 258

  180 var-obj: ID LT var-type GT LPAR . args-list RPAR

    COMMA        shift, and go to state 161
    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    TRUE_RW      shift, and go to state 24

    $default  reduce using rule 178 (args-list)

    assign-expr      go to state 162
    logic-expr       go to state 36
    expr             go to state 163
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    args-list        go to state 294
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 259

  175 args-list: assign-expr COMMA args-list .

    $default  reduce using rule 175 (args-list)


State 260

  174 args-list: expr COMMA args-list .

    $default  reduce using rule 174 (args-list)


State 261

   79 class-att-list: SEMI class-att-list .

    $default  reduce using rule 79 (class-att-list)


State 262

   83 class-att: ID COLON . var-type

    VOID_RW    shift, and go to state 152
    ANY        shift, and go to state 153
    BOOLTYPE   shift, and go to state 154
    NEVER      shift, and go to state 155
    NUMBER     shift, and go to state 156
    STRING     shift, and go to state 157
    UNDEFINED  shift, and go to state 158

    var-type  go to state 295


State 263

   85 class-att: ID LPAR . params RPAR LBRACE line RBRACE
   86          | ID LPAR . params RPAR COLON var-type LBRACE line RBRACE

    COMMA  shift, and go to state 245
    ID     shift, and go to state 246

    $default  reduce using rule 99 (params)

    params  go to state 296


State 264

   78 class-def: CLASS ID LBRACE class-att-list RBRACE .

    $default  reduce using rule 78 (class-def)


State 265

   80 class-att-list: class-att SEMI . class-att-list

    SEMI       shift, and go to state 226
    ID         shift, and go to state 227
    PRIVATE    shift, and go to state 228
    PROTECTED  shift, and go to state 229
    PUBLIC     shift, and go to state 230

    $default  reduce using rule 82 (class-att-list)

    class-att-list  go to state 297
    class-att       go to state 232
    access-modif    go to state 233


State 266

   84 class-att: access-modif ID . COLON var-type

    COLON  shift, and go to state 298


State 267

  108 var-declr: CONST_RW ID COLON var-type ASSIGN . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    TRUE_RW      shift, and go to state 24

    logic-expr       go to state 36
    expr             go to state 299
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 268

  109 var-declr: CONST_RW ID COLON var-type LBRACKET . RBRACKET ASSIGN expr

    RBRACKET  shift, and go to state 300


State 269

  116 obj-att-list: COMMA . obj-att-list

    COMMA  shift, and go to state 269
    ID     shift, and go to state 270

    $default  reduce using rule 119 (obj-att-list)

    obj-att-list  go to state 301
    obj-att       go to state 272


State 270

  120 obj-att: ID . COLON var-val

    COLON  shift, and go to state 302


State 271

  115 obj-def: LBRACE obj-att-list . RBRACE

    RBRACE  shift, and go to state 303


State 272

  117 obj-att-list: obj-att . COMMA obj-att-list
  118             | obj-att .

    COMMA  shift, and go to state 304

    $default  reduce using rule 118 (obj-att-list)


State 273

   56 do-while-stmt: DO LBRACE line RBRACE WHILE . LPAR expr RPAR
   57              | DO LBRACE line RBRACE WHILE . LPAR assign-expr RPAR

    LPAR  shift, and go to state 305


State 274

   39 for-stmt: FOR LPAR SEMI SEMI RPAR . LBRACE line RBRACE

    LBRACE  shift, and go to state 306


State 275

   38 for-stmt: FOR LPAR SEMI SEMI assign-expr . RPAR LBRACE line RBRACE

    RPAR  shift, and go to state 307


State 276

   37 for-stmt: FOR LPAR SEMI SEMI expr . RPAR LBRACE line RBRACE
   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  153 arit-expr: expr . PLUS expr
  154          | expr . SUB expr
  155          | expr . MULT expr
  156          | expr . DIV expr
  157          | expr . EXP expr
  158          | expr . REM expr
  159 bitw-expr: expr . BITWISE_AND expr
  160          | expr . BITWISE_OR expr
  161          | expr . BITWISE_XOR expr
  162 shift-expr: expr . LSHIFT expr
  163           | expr . RSHIFT expr
  164           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 115
    SUB              shift, and go to state 116
    MULT             shift, and go to state 117
    DIV              shift, and go to state 118
    EXP              shift, and go to state 119
    REM              shift, and go to state 120
    BITWISE_AND      shift, and go to state 121
    BITWISE_OR       shift, and go to state 122
    BITWISE_XOR      shift, and go to state 123
    LOGICAL_NULL     shift, and go to state 124
    LOGICAL_AND      shift, and go to state 125
    LOGICAL_OR       shift, and go to state 126
    EQ               shift, and go to state 127
    EQ_STRICT        shift, and go to state 128
    INEQ             shift, and go to state 129
    INEQ_STRICT      shift, and go to state 130
    LT               shift, and go to state 131
    LT_EQ            shift, and go to state 132
    GT               shift, and go to state 133
    GT_EQ            shift, and go to state 134
    LSHIFT           shift, and go to state 135
    RSHIFT           shift, and go to state 136
    RSHIFT_UNSIGNED  shift, and go to state 137
    RPAR             shift, and go to state 308


State 277

   34 for-stmt: FOR LPAR SEMI expr SEMI . expr RPAR LBRACE line RBRACE
   35         | FOR LPAR SEMI expr SEMI . assign-expr RPAR LBRACE line RBRACE
   36         | FOR LPAR SEMI expr SEMI . RPAR LBRACE line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    RPAR         shift, and go to state 309
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    TRUE_RW      shift, and go to state 24

    assign-expr      go to state 310
    logic-expr       go to state 36
    expr             go to state 311
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 278

   25 for-stmt: FOR LPAR assign-expr SEMI SEMI . expr RPAR LBRACE line RBRACE
   26         | FOR LPAR assign-expr SEMI SEMI . assign-expr RPAR LBRACE line RBRACE
   27         | FOR LPAR assign-expr SEMI SEMI . RPAR LBRACE line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    RPAR         shift, and go to state 312
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    TRUE_RW      shift, and go to state 24

    assign-expr      go to state 313
    logic-expr       go to state 36
    expr             go to state 314
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 279

   22 for-stmt: FOR LPAR assign-expr SEMI expr . SEMI expr RPAR LBRACE line RBRACE
   23         | FOR LPAR assign-expr SEMI expr . SEMI assign-expr RPAR LBRACE line RBRACE
   24         | FOR LPAR assign-expr SEMI expr . SEMI RPAR LBRACE line RBRACE
   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  153 arit-expr: expr . PLUS expr
  154          | expr . SUB expr
  155          | expr . MULT expr
  156          | expr . DIV expr
  157          | expr . EXP expr
  158          | expr . REM expr
  159 bitw-expr: expr . BITWISE_AND expr
  160          | expr . BITWISE_OR expr
  161          | expr . BITWISE_XOR expr
  162 shift-expr: expr . LSHIFT expr
  163           | expr . RSHIFT expr
  164           | expr . RSHIFT_UNSIGNED expr

    SEMI             shift, and go to state 315
    PLUS             shift, and go to state 115
    SUB              shift, and go to state 116
    MULT             shift, and go to state 117
    DIV              shift, and go to state 118
    EXP              shift, and go to state 119
    REM              shift, and go to state 120
    BITWISE_AND      shift, and go to state 121
    BITWISE_OR       shift, and go to state 122
    BITWISE_XOR      shift, and go to state 123
    LOGICAL_NULL     shift, and go to state 124
    LOGICAL_AND      shift, and go to state 125
    LOGICAL_OR       shift, and go to state 126
    EQ               shift, and go to state 127
    EQ_STRICT        shift, and go to state 128
    INEQ             shift, and go to state 129
    INEQ_STRICT      shift, and go to state 130
    LT               shift, and go to state 131
    LT_EQ            shift, and go to state 132
    GT               shift, and go to state 133
    GT_EQ            shift, and go to state 134
    LSHIFT           shift, and go to state 135
    RSHIFT           shift, and go to state 136
    RSHIFT_UNSIGNED  shift, and go to state 137


State 280

   31 for-stmt: FOR LPAR var-declr SEMI SEMI . expr RPAR LBRACE line RBRACE
   32         | FOR LPAR var-declr SEMI SEMI . assign-expr RPAR LBRACE line RBRACE
   33         | FOR LPAR var-declr SEMI SEMI . RPAR LBRACE line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    RPAR         shift, and go to state 316
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    TRUE_RW      shift, and go to state 24

    assign-expr      go to state 317
    logic-expr       go to state 36
    expr             go to state 318
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 281

   28 for-stmt: FOR LPAR var-declr SEMI expr . SEMI expr RPAR LBRACE line RBRACE
   29         | FOR LPAR var-declr SEMI expr . SEMI assign-expr RPAR LBRACE line RBRACE
   30         | FOR LPAR var-declr SEMI expr . SEMI RPAR LBRACE line RBRACE
   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  153 arit-expr: expr . PLUS expr
  154          | expr . SUB expr
  155          | expr . MULT expr
  156          | expr . DIV expr
  157          | expr . EXP expr
  158          | expr . REM expr
  159 bitw-expr: expr . BITWISE_AND expr
  160          | expr . BITWISE_OR expr
  161          | expr . BITWISE_XOR expr
  162 shift-expr: expr . LSHIFT expr
  163           | expr . RSHIFT expr
  164           | expr . RSHIFT_UNSIGNED expr

    SEMI             shift, and go to state 319
    PLUS             shift, and go to state 115
    SUB              shift, and go to state 116
    MULT             shift, and go to state 117
    DIV              shift, and go to state 118
    EXP              shift, and go to state 119
    REM              shift, and go to state 120
    BITWISE_AND      shift, and go to state 121
    BITWISE_OR       shift, and go to state 122
    BITWISE_XOR      shift, and go to state 123
    LOGICAL_NULL     shift, and go to state 124
    LOGICAL_AND      shift, and go to state 125
    LOGICAL_OR       shift, and go to state 126
    EQ               shift, and go to state 127
    EQ_STRICT        shift, and go to state 128
    INEQ             shift, and go to state 129
    INEQ_STRICT      shift, and go to state 130
    LT               shift, and go to state 131
    LT_EQ            shift, and go to state 132
    GT               shift, and go to state 133
    GT_EQ            shift, and go to state 134
    LSHIFT           shift, and go to state 135
    RSHIFT           shift, and go to state 136
    RSHIFT_UNSIGNED  shift, and go to state 137


State 282

   92 params: COMMA ID .
   93       | COMMA ID . COLON var-type

    COLON  shift, and go to state 320

    $default  reduce using rule 92 (params)


State 283

   94 params: ID COMMA . ID
   98       | ID COMMA . ID COLON var-type

    ID  shift, and go to state 321


State 284

   95 params: ID COLON . var-type COMMA ID COLON var-type
   96       | ID COLON . var-type COMMA ID
   97       | ID COLON . var-type

    VOID_RW    shift, and go to state 152
    ANY        shift, and go to state 153
    BOOLTYPE   shift, and go to state 154
    NEVER      shift, and go to state 155
    NUMBER     shift, and go to state 156
    STRING     shift, and go to state 157
    UNDEFINED  shift, and go to state 158

    var-type  go to state 322


State 285

   90 func-def: FUNCTION ID LPAR params RPAR . LBRACE line RBRACE
   91         | FUNCTION ID LPAR params RPAR . COLON var-type LBRACE line RBRACE

    COLON   shift, and go to state 323
    LBRACE  shift, and go to state 324


State 286

   63 if-stmt: IF LPAR assign-expr RPAR LBRACE . line RBRACE
   64        | IF LPAR assign-expr RPAR LBRACE . line RBRACE ELSE LBRACE line RBRACE
   65        | IF LPAR assign-expr RPAR LBRACE . line RBRACE ELSE stmt

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    RETURN       shift, and go to state 23
    TRUE_RW      shift, and go to state 24
    VAR          shift, and go to state 25
    WHILE        shift, and go to state 26

    $default  reduce using rule 3 (line)

    line             go to state 325
    stmt-list        go to state 29
    stmt             go to state 30
    assign-expr      go to state 31
    for-stmt         go to state 32
    do-while-stmt    go to state 33
    while-stmt       go to state 34
    if-stmt          go to state 35
    logic-expr       go to state 36
    class-def        go to state 37
    func-def         go to state 38
    var-declr        go to state 39
    var-declr-rw     go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 287

   60 if-stmt: IF LPAR expr RPAR LBRACE . line RBRACE
   61        | IF LPAR expr RPAR LBRACE . line RBRACE ELSE LBRACE line RBRACE
   62        | IF LPAR expr RPAR LBRACE . line RBRACE ELSE stmt

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    RETURN       shift, and go to state 23
    TRUE_RW      shift, and go to state 24
    VAR          shift, and go to state 25
    WHILE        shift, and go to state 26

    $default  reduce using rule 3 (line)

    line             go to state 326
    stmt-list        go to state 29
    stmt             go to state 30
    assign-expr      go to state 31
    for-stmt         go to state 32
    do-while-stmt    go to state 33
    while-stmt       go to state 34
    if-stmt          go to state 35
    logic-expr       go to state 36
    class-def        go to state 37
    func-def         go to state 38
    var-declr        go to state 39
    var-declr-rw     go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 288

  182 var-obj: NEW ID LT var-type GT . LPAR args-list RPAR

    LPAR  shift, and go to state 327


State 289

  181 var-obj: NEW ID LPAR args-list RPAR .

    $default  reduce using rule 181 (var-obj)


State 290

   59 while-stmt: WHILE LPAR assign-expr RPAR LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    RETURN       shift, and go to state 23
    TRUE_RW      shift, and go to state 24
    VAR          shift, and go to state 25
    WHILE        shift, and go to state 26

    $default  reduce using rule 3 (line)

    line             go to state 328
    stmt-list        go to state 29
    stmt             go to state 30
    assign-expr      go to state 31
    for-stmt         go to state 32
    do-while-stmt    go to state 33
    while-stmt       go to state 34
    if-stmt          go to state 35
    logic-expr       go to state 36
    class-def        go to state 37
    func-def         go to state 38
    var-declr        go to state 39
    var-declr-rw     go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 291

   58 while-stmt: WHILE LPAR expr RPAR LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    RETURN       shift, and go to state 23
    TRUE_RW      shift, and go to state 24
    VAR          shift, and go to state 25
    WHILE        shift, and go to state 26

    $default  reduce using rule 3 (line)

    line             go to state 329
    stmt-list        go to state 29
    stmt             go to state 30
    assign-expr      go to state 31
    for-stmt         go to state 32
    do-while-stmt    go to state 33
    while-stmt       go to state 34
    if-stmt          go to state 35
    logic-expr       go to state 36
    class-def        go to state 37
    func-def         go to state 38
    var-declr        go to state 39
    var-declr-rw     go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 292

  104 var-declr: var-declr-rw ID COLON var-type ASSIGN . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    TRUE_RW      shift, and go to state 24

    logic-expr       go to state 36
    expr             go to state 330
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 293

  105 var-declr: var-declr-rw ID COLON var-type LBRACKET . RBRACKET
  106          | var-declr-rw ID COLON var-type LBRACKET . RBRACKET ASSIGN expr

    RBRACKET  shift, and go to state 331


State 294

  180 var-obj: ID LT var-type GT LPAR args-list . RPAR

    RPAR  shift, and go to state 332


State 295

   83 class-att: ID COLON var-type .

    $default  reduce using rule 83 (class-att)


State 296

   85 class-att: ID LPAR params . RPAR LBRACE line RBRACE
   86          | ID LPAR params . RPAR COLON var-type LBRACE line RBRACE

    RPAR  shift, and go to state 333


State 297

   80 class-att-list: class-att SEMI class-att-list .

    $default  reduce using rule 80 (class-att-list)


State 298

   84 class-att: access-modif ID COLON . var-type

    VOID_RW    shift, and go to state 152
    ANY        shift, and go to state 153
    BOOLTYPE   shift, and go to state 154
    NEVER      shift, and go to state 155
    NUMBER     shift, and go to state 156
    STRING     shift, and go to state 157
    UNDEFINED  shift, and go to state 158

    var-type  go to state 334


State 299

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  108 var-declr: CONST_RW ID COLON var-type ASSIGN expr .
  153 arit-expr: expr . PLUS expr
  154          | expr . SUB expr
  155          | expr . MULT expr
  156          | expr . DIV expr
  157          | expr . EXP expr
  158          | expr . REM expr
  159 bitw-expr: expr . BITWISE_AND expr
  160          | expr . BITWISE_OR expr
  161          | expr . BITWISE_XOR expr
  162 shift-expr: expr . LSHIFT expr
  163           | expr . RSHIFT expr
  164           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 115
    SUB              shift, and go to state 116
    MULT             shift, and go to state 117
    DIV              shift, and go to state 118
    EXP              shift, and go to state 119
    REM              shift, and go to state 120
    BITWISE_AND      shift, and go to state 121
    BITWISE_OR       shift, and go to state 122
    BITWISE_XOR      shift, and go to state 123
    LOGICAL_NULL     shift, and go to state 124
    LOGICAL_AND      shift, and go to state 125
    LOGICAL_OR       shift, and go to state 126
    EQ               shift, and go to state 127
    EQ_STRICT        shift, and go to state 128
    INEQ             shift, and go to state 129
    INEQ_STRICT      shift, and go to state 130
    LT               shift, and go to state 131
    LT_EQ            shift, and go to state 132
    GT               shift, and go to state 133
    GT_EQ            shift, and go to state 134
    LSHIFT           shift, and go to state 135
    RSHIFT           shift, and go to state 136
    RSHIFT_UNSIGNED  shift, and go to state 137

    $default  reduce using rule 108 (var-declr)


State 300

  109 var-declr: CONST_RW ID COLON var-type LBRACKET RBRACKET . ASSIGN expr

    ASSIGN  shift, and go to state 335


State 301

  116 obj-att-list: COMMA obj-att-list .

    $default  reduce using rule 116 (obj-att-list)


State 302

  120 obj-att: ID COLON . var-val

    SUB       shift, and go to state 2
    INT_VAL   shift, and go to state 8
    REAL_VAL  shift, and go to state 9
    STR_VAL   shift, and go to state 10
    FALSE_RW  shift, and go to state 17
    TRUE_RW   shift, and go to state 24

    var-val  go to state 336


State 303

  115 obj-def: LBRACE obj-att-list RBRACE .

    $default  reduce using rule 115 (obj-def)


State 304

  117 obj-att-list: obj-att COMMA . obj-att-list

    COMMA  shift, and go to state 269
    ID     shift, and go to state 270

    $default  reduce using rule 119 (obj-att-list)

    obj-att-list  go to state 337
    obj-att       go to state 272


State 305

   56 do-while-stmt: DO LBRACE line RBRACE WHILE LPAR . expr RPAR
   57              | DO LBRACE line RBRACE WHILE LPAR . assign-expr RPAR

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    TRUE_RW      shift, and go to state 24

    assign-expr      go to state 338
    logic-expr       go to state 36
    expr             go to state 339
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 306

   39 for-stmt: FOR LPAR SEMI SEMI RPAR LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    RETURN       shift, and go to state 23
    TRUE_RW      shift, and go to state 24
    VAR          shift, and go to state 25
    WHILE        shift, and go to state 26

    $default  reduce using rule 3 (line)

    line             go to state 340
    stmt-list        go to state 29
    stmt             go to state 30
    assign-expr      go to state 31
    for-stmt         go to state 32
    do-while-stmt    go to state 33
    while-stmt       go to state 34
    if-stmt          go to state 35
    logic-expr       go to state 36
    class-def        go to state 37
    func-def         go to state 38
    var-declr        go to state 39
    var-declr-rw     go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 307

   38 for-stmt: FOR LPAR SEMI SEMI assign-expr RPAR . LBRACE line RBRACE

    LBRACE  shift, and go to state 341


State 308

   37 for-stmt: FOR LPAR SEMI SEMI expr RPAR . LBRACE line RBRACE

    LBRACE  shift, and go to state 342


State 309

   36 for-stmt: FOR LPAR SEMI expr SEMI RPAR . LBRACE line RBRACE

    LBRACE  shift, and go to state 343


State 310

   35 for-stmt: FOR LPAR SEMI expr SEMI assign-expr . RPAR LBRACE line RBRACE

    RPAR  shift, and go to state 344


State 311

   34 for-stmt: FOR LPAR SEMI expr SEMI expr . RPAR LBRACE line RBRACE
   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  153 arit-expr: expr . PLUS expr
  154          | expr . SUB expr
  155          | expr . MULT expr
  156          | expr . DIV expr
  157          | expr . EXP expr
  158          | expr . REM expr
  159 bitw-expr: expr . BITWISE_AND expr
  160          | expr . BITWISE_OR expr
  161          | expr . BITWISE_XOR expr
  162 shift-expr: expr . LSHIFT expr
  163           | expr . RSHIFT expr
  164           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 115
    SUB              shift, and go to state 116
    MULT             shift, and go to state 117
    DIV              shift, and go to state 118
    EXP              shift, and go to state 119
    REM              shift, and go to state 120
    BITWISE_AND      shift, and go to state 121
    BITWISE_OR       shift, and go to state 122
    BITWISE_XOR      shift, and go to state 123
    LOGICAL_NULL     shift, and go to state 124
    LOGICAL_AND      shift, and go to state 125
    LOGICAL_OR       shift, and go to state 126
    EQ               shift, and go to state 127
    EQ_STRICT        shift, and go to state 128
    INEQ             shift, and go to state 129
    INEQ_STRICT      shift, and go to state 130
    LT               shift, and go to state 131
    LT_EQ            shift, and go to state 132
    GT               shift, and go to state 133
    GT_EQ            shift, and go to state 134
    LSHIFT           shift, and go to state 135
    RSHIFT           shift, and go to state 136
    RSHIFT_UNSIGNED  shift, and go to state 137
    RPAR             shift, and go to state 345


State 312

   27 for-stmt: FOR LPAR assign-expr SEMI SEMI RPAR . LBRACE line RBRACE

    LBRACE  shift, and go to state 346


State 313

   26 for-stmt: FOR LPAR assign-expr SEMI SEMI assign-expr . RPAR LBRACE line RBRACE

    RPAR  shift, and go to state 347


State 314

   25 for-stmt: FOR LPAR assign-expr SEMI SEMI expr . RPAR LBRACE line RBRACE
   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  153 arit-expr: expr . PLUS expr
  154          | expr . SUB expr
  155          | expr . MULT expr
  156          | expr . DIV expr
  157          | expr . EXP expr
  158          | expr . REM expr
  159 bitw-expr: expr . BITWISE_AND expr
  160          | expr . BITWISE_OR expr
  161          | expr . BITWISE_XOR expr
  162 shift-expr: expr . LSHIFT expr
  163           | expr . RSHIFT expr
  164           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 115
    SUB              shift, and go to state 116
    MULT             shift, and go to state 117
    DIV              shift, and go to state 118
    EXP              shift, and go to state 119
    REM              shift, and go to state 120
    BITWISE_AND      shift, and go to state 121
    BITWISE_OR       shift, and go to state 122
    BITWISE_XOR      shift, and go to state 123
    LOGICAL_NULL     shift, and go to state 124
    LOGICAL_AND      shift, and go to state 125
    LOGICAL_OR       shift, and go to state 126
    EQ               shift, and go to state 127
    EQ_STRICT        shift, and go to state 128
    INEQ             shift, and go to state 129
    INEQ_STRICT      shift, and go to state 130
    LT               shift, and go to state 131
    LT_EQ            shift, and go to state 132
    GT               shift, and go to state 133
    GT_EQ            shift, and go to state 134
    LSHIFT           shift, and go to state 135
    RSHIFT           shift, and go to state 136
    RSHIFT_UNSIGNED  shift, and go to state 137
    RPAR             shift, and go to state 348


State 315

   22 for-stmt: FOR LPAR assign-expr SEMI expr SEMI . expr RPAR LBRACE line RBRACE
   23         | FOR LPAR assign-expr SEMI expr SEMI . assign-expr RPAR LBRACE line RBRACE
   24         | FOR LPAR assign-expr SEMI expr SEMI . RPAR LBRACE line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    RPAR         shift, and go to state 349
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    TRUE_RW      shift, and go to state 24

    assign-expr      go to state 350
    logic-expr       go to state 36
    expr             go to state 351
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 316

   33 for-stmt: FOR LPAR var-declr SEMI SEMI RPAR . LBRACE line RBRACE

    LBRACE  shift, and go to state 352


State 317

   32 for-stmt: FOR LPAR var-declr SEMI SEMI assign-expr . RPAR LBRACE line RBRACE

    RPAR  shift, and go to state 353


State 318

   31 for-stmt: FOR LPAR var-declr SEMI SEMI expr . RPAR LBRACE line RBRACE
   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  153 arit-expr: expr . PLUS expr
  154          | expr . SUB expr
  155          | expr . MULT expr
  156          | expr . DIV expr
  157          | expr . EXP expr
  158          | expr . REM expr
  159 bitw-expr: expr . BITWISE_AND expr
  160          | expr . BITWISE_OR expr
  161          | expr . BITWISE_XOR expr
  162 shift-expr: expr . LSHIFT expr
  163           | expr . RSHIFT expr
  164           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 115
    SUB              shift, and go to state 116
    MULT             shift, and go to state 117
    DIV              shift, and go to state 118
    EXP              shift, and go to state 119
    REM              shift, and go to state 120
    BITWISE_AND      shift, and go to state 121
    BITWISE_OR       shift, and go to state 122
    BITWISE_XOR      shift, and go to state 123
    LOGICAL_NULL     shift, and go to state 124
    LOGICAL_AND      shift, and go to state 125
    LOGICAL_OR       shift, and go to state 126
    EQ               shift, and go to state 127
    EQ_STRICT        shift, and go to state 128
    INEQ             shift, and go to state 129
    INEQ_STRICT      shift, and go to state 130
    LT               shift, and go to state 131
    LT_EQ            shift, and go to state 132
    GT               shift, and go to state 133
    GT_EQ            shift, and go to state 134
    LSHIFT           shift, and go to state 135
    RSHIFT           shift, and go to state 136
    RSHIFT_UNSIGNED  shift, and go to state 137
    RPAR             shift, and go to state 354


State 319

   28 for-stmt: FOR LPAR var-declr SEMI expr SEMI . expr RPAR LBRACE line RBRACE
   29         | FOR LPAR var-declr SEMI expr SEMI . assign-expr RPAR LBRACE line RBRACE
   30         | FOR LPAR var-declr SEMI expr SEMI . RPAR LBRACE line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    RPAR         shift, and go to state 355
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    TRUE_RW      shift, and go to state 24

    assign-expr      go to state 356
    logic-expr       go to state 36
    expr             go to state 357
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 320

   93 params: COMMA ID COLON . var-type

    VOID_RW    shift, and go to state 152
    ANY        shift, and go to state 153
    BOOLTYPE   shift, and go to state 154
    NEVER      shift, and go to state 155
    NUMBER     shift, and go to state 156
    STRING     shift, and go to state 157
    UNDEFINED  shift, and go to state 158

    var-type  go to state 358


State 321

   94 params: ID COMMA ID .
   98       | ID COMMA ID . COLON var-type

    COLON  shift, and go to state 359

    $default  reduce using rule 94 (params)


State 322

   95 params: ID COLON var-type . COMMA ID COLON var-type
   96       | ID COLON var-type . COMMA ID
   97       | ID COLON var-type .

    COMMA  shift, and go to state 360

    $default  reduce using rule 97 (params)


State 323

   91 func-def: FUNCTION ID LPAR params RPAR COLON . var-type LBRACE line RBRACE

    VOID_RW    shift, and go to state 152
    ANY        shift, and go to state 153
    BOOLTYPE   shift, and go to state 154
    NEVER      shift, and go to state 155
    NUMBER     shift, and go to state 156
    STRING     shift, and go to state 157
    UNDEFINED  shift, and go to state 158

    var-type  go to state 361


State 324

   90 func-def: FUNCTION ID LPAR params RPAR LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    RETURN       shift, and go to state 23
    TRUE_RW      shift, and go to state 24
    VAR          shift, and go to state 25
    WHILE        shift, and go to state 26

    $default  reduce using rule 3 (line)

    line             go to state 362
    stmt-list        go to state 29
    stmt             go to state 30
    assign-expr      go to state 31
    for-stmt         go to state 32
    do-while-stmt    go to state 33
    while-stmt       go to state 34
    if-stmt          go to state 35
    logic-expr       go to state 36
    class-def        go to state 37
    func-def         go to state 38
    var-declr        go to state 39
    var-declr-rw     go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 325

   63 if-stmt: IF LPAR assign-expr RPAR LBRACE line . RBRACE
   64        | IF LPAR assign-expr RPAR LBRACE line . RBRACE ELSE LBRACE line RBRACE
   65        | IF LPAR assign-expr RPAR LBRACE line . RBRACE ELSE stmt

    RBRACE  shift, and go to state 363


State 326

   60 if-stmt: IF LPAR expr RPAR LBRACE line . RBRACE
   61        | IF LPAR expr RPAR LBRACE line . RBRACE ELSE LBRACE line RBRACE
   62        | IF LPAR expr RPAR LBRACE line . RBRACE ELSE stmt

    RBRACE  shift, and go to state 364


State 327

  182 var-obj: NEW ID LT var-type GT LPAR . args-list RPAR

    COMMA        shift, and go to state 161
    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    TRUE_RW      shift, and go to state 24

    $default  reduce using rule 178 (args-list)

    assign-expr      go to state 162
    logic-expr       go to state 36
    expr             go to state 163
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    args-list        go to state 365
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 328

   59 while-stmt: WHILE LPAR assign-expr RPAR LBRACE line . RBRACE

    RBRACE  shift, and go to state 366


State 329

   58 while-stmt: WHILE LPAR expr RPAR LBRACE line . RBRACE

    RBRACE  shift, and go to state 367


State 330

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  104 var-declr: var-declr-rw ID COLON var-type ASSIGN expr .
  153 arit-expr: expr . PLUS expr
  154          | expr . SUB expr
  155          | expr . MULT expr
  156          | expr . DIV expr
  157          | expr . EXP expr
  158          | expr . REM expr
  159 bitw-expr: expr . BITWISE_AND expr
  160          | expr . BITWISE_OR expr
  161          | expr . BITWISE_XOR expr
  162 shift-expr: expr . LSHIFT expr
  163           | expr . RSHIFT expr
  164           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 115
    SUB              shift, and go to state 116
    MULT             shift, and go to state 117
    DIV              shift, and go to state 118
    EXP              shift, and go to state 119
    REM              shift, and go to state 120
    BITWISE_AND      shift, and go to state 121
    BITWISE_OR       shift, and go to state 122
    BITWISE_XOR      shift, and go to state 123
    LOGICAL_NULL     shift, and go to state 124
    LOGICAL_AND      shift, and go to state 125
    LOGICAL_OR       shift, and go to state 126
    EQ               shift, and go to state 127
    EQ_STRICT        shift, and go to state 128
    INEQ             shift, and go to state 129
    INEQ_STRICT      shift, and go to state 130
    LT               shift, and go to state 131
    LT_EQ            shift, and go to state 132
    GT               shift, and go to state 133
    GT_EQ            shift, and go to state 134
    LSHIFT           shift, and go to state 135
    RSHIFT           shift, and go to state 136
    RSHIFT_UNSIGNED  shift, and go to state 137

    $default  reduce using rule 104 (var-declr)


State 331

  105 var-declr: var-declr-rw ID COLON var-type LBRACKET RBRACKET .
  106          | var-declr-rw ID COLON var-type LBRACKET RBRACKET . ASSIGN expr

    ASSIGN  shift, and go to state 368

    $default  reduce using rule 105 (var-declr)


State 332

  180 var-obj: ID LT var-type GT LPAR args-list RPAR .

    $default  reduce using rule 180 (var-obj)


State 333

   85 class-att: ID LPAR params RPAR . LBRACE line RBRACE
   86          | ID LPAR params RPAR . COLON var-type LBRACE line RBRACE

    COLON   shift, and go to state 369
    LBRACE  shift, and go to state 370


State 334

   84 class-att: access-modif ID COLON var-type .

    $default  reduce using rule 84 (class-att)


State 335

  109 var-declr: CONST_RW ID COLON var-type LBRACKET RBRACKET ASSIGN . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    TRUE_RW      shift, and go to state 24

    logic-expr       go to state 36
    expr             go to state 371
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 336

  120 obj-att: ID COLON var-val .

    $default  reduce using rule 120 (obj-att)


State 337

  117 obj-att-list: obj-att COMMA obj-att-list .

    $default  reduce using rule 117 (obj-att-list)


State 338

   57 do-while-stmt: DO LBRACE line RBRACE WHILE LPAR assign-expr . RPAR

    RPAR  shift, and go to state 372


State 339

   56 do-while-stmt: DO LBRACE line RBRACE WHILE LPAR expr . RPAR
   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  153 arit-expr: expr . PLUS expr
  154          | expr . SUB expr
  155          | expr . MULT expr
  156          | expr . DIV expr
  157          | expr . EXP expr
  158          | expr . REM expr
  159 bitw-expr: expr . BITWISE_AND expr
  160          | expr . BITWISE_OR expr
  161          | expr . BITWISE_XOR expr
  162 shift-expr: expr . LSHIFT expr
  163           | expr . RSHIFT expr
  164           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 115
    SUB              shift, and go to state 116
    MULT             shift, and go to state 117
    DIV              shift, and go to state 118
    EXP              shift, and go to state 119
    REM              shift, and go to state 120
    BITWISE_AND      shift, and go to state 121
    BITWISE_OR       shift, and go to state 122
    BITWISE_XOR      shift, and go to state 123
    LOGICAL_NULL     shift, and go to state 124
    LOGICAL_AND      shift, and go to state 125
    LOGICAL_OR       shift, and go to state 126
    EQ               shift, and go to state 127
    EQ_STRICT        shift, and go to state 128
    INEQ             shift, and go to state 129
    INEQ_STRICT      shift, and go to state 130
    LT               shift, and go to state 131
    LT_EQ            shift, and go to state 132
    GT               shift, and go to state 133
    GT_EQ            shift, and go to state 134
    LSHIFT           shift, and go to state 135
    RSHIFT           shift, and go to state 136
    RSHIFT_UNSIGNED  shift, and go to state 137
    RPAR             shift, and go to state 373


State 340

   39 for-stmt: FOR LPAR SEMI SEMI RPAR LBRACE line . RBRACE

    RBRACE  shift, and go to state 374


State 341

   38 for-stmt: FOR LPAR SEMI SEMI assign-expr RPAR LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    RETURN       shift, and go to state 23
    TRUE_RW      shift, and go to state 24
    VAR          shift, and go to state 25
    WHILE        shift, and go to state 26

    $default  reduce using rule 3 (line)

    line             go to state 375
    stmt-list        go to state 29
    stmt             go to state 30
    assign-expr      go to state 31
    for-stmt         go to state 32
    do-while-stmt    go to state 33
    while-stmt       go to state 34
    if-stmt          go to state 35
    logic-expr       go to state 36
    class-def        go to state 37
    func-def         go to state 38
    var-declr        go to state 39
    var-declr-rw     go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 342

   37 for-stmt: FOR LPAR SEMI SEMI expr RPAR LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    RETURN       shift, and go to state 23
    TRUE_RW      shift, and go to state 24
    VAR          shift, and go to state 25
    WHILE        shift, and go to state 26

    $default  reduce using rule 3 (line)

    line             go to state 376
    stmt-list        go to state 29
    stmt             go to state 30
    assign-expr      go to state 31
    for-stmt         go to state 32
    do-while-stmt    go to state 33
    while-stmt       go to state 34
    if-stmt          go to state 35
    logic-expr       go to state 36
    class-def        go to state 37
    func-def         go to state 38
    var-declr        go to state 39
    var-declr-rw     go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 343

   36 for-stmt: FOR LPAR SEMI expr SEMI RPAR LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    RETURN       shift, and go to state 23
    TRUE_RW      shift, and go to state 24
    VAR          shift, and go to state 25
    WHILE        shift, and go to state 26

    $default  reduce using rule 3 (line)

    line             go to state 377
    stmt-list        go to state 29
    stmt             go to state 30
    assign-expr      go to state 31
    for-stmt         go to state 32
    do-while-stmt    go to state 33
    while-stmt       go to state 34
    if-stmt          go to state 35
    logic-expr       go to state 36
    class-def        go to state 37
    func-def         go to state 38
    var-declr        go to state 39
    var-declr-rw     go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 344

   35 for-stmt: FOR LPAR SEMI expr SEMI assign-expr RPAR . LBRACE line RBRACE

    LBRACE  shift, and go to state 378


State 345

   34 for-stmt: FOR LPAR SEMI expr SEMI expr RPAR . LBRACE line RBRACE

    LBRACE  shift, and go to state 379


State 346

   27 for-stmt: FOR LPAR assign-expr SEMI SEMI RPAR LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    RETURN       shift, and go to state 23
    TRUE_RW      shift, and go to state 24
    VAR          shift, and go to state 25
    WHILE        shift, and go to state 26

    $default  reduce using rule 3 (line)

    line             go to state 380
    stmt-list        go to state 29
    stmt             go to state 30
    assign-expr      go to state 31
    for-stmt         go to state 32
    do-while-stmt    go to state 33
    while-stmt       go to state 34
    if-stmt          go to state 35
    logic-expr       go to state 36
    class-def        go to state 37
    func-def         go to state 38
    var-declr        go to state 39
    var-declr-rw     go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 347

   26 for-stmt: FOR LPAR assign-expr SEMI SEMI assign-expr RPAR . LBRACE line RBRACE

    LBRACE  shift, and go to state 381


State 348

   25 for-stmt: FOR LPAR assign-expr SEMI SEMI expr RPAR . LBRACE line RBRACE

    LBRACE  shift, and go to state 382


State 349

   24 for-stmt: FOR LPAR assign-expr SEMI expr SEMI RPAR . LBRACE line RBRACE

    LBRACE  shift, and go to state 383


State 350

   23 for-stmt: FOR LPAR assign-expr SEMI expr SEMI assign-expr . RPAR LBRACE line RBRACE

    RPAR  shift, and go to state 384


State 351

   22 for-stmt: FOR LPAR assign-expr SEMI expr SEMI expr . RPAR LBRACE line RBRACE
   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  153 arit-expr: expr . PLUS expr
  154          | expr . SUB expr
  155          | expr . MULT expr
  156          | expr . DIV expr
  157          | expr . EXP expr
  158          | expr . REM expr
  159 bitw-expr: expr . BITWISE_AND expr
  160          | expr . BITWISE_OR expr
  161          | expr . BITWISE_XOR expr
  162 shift-expr: expr . LSHIFT expr
  163           | expr . RSHIFT expr
  164           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 115
    SUB              shift, and go to state 116
    MULT             shift, and go to state 117
    DIV              shift, and go to state 118
    EXP              shift, and go to state 119
    REM              shift, and go to state 120
    BITWISE_AND      shift, and go to state 121
    BITWISE_OR       shift, and go to state 122
    BITWISE_XOR      shift, and go to state 123
    LOGICAL_NULL     shift, and go to state 124
    LOGICAL_AND      shift, and go to state 125
    LOGICAL_OR       shift, and go to state 126
    EQ               shift, and go to state 127
    EQ_STRICT        shift, and go to state 128
    INEQ             shift, and go to state 129
    INEQ_STRICT      shift, and go to state 130
    LT               shift, and go to state 131
    LT_EQ            shift, and go to state 132
    GT               shift, and go to state 133
    GT_EQ            shift, and go to state 134
    LSHIFT           shift, and go to state 135
    RSHIFT           shift, and go to state 136
    RSHIFT_UNSIGNED  shift, and go to state 137
    RPAR             shift, and go to state 385


State 352

   33 for-stmt: FOR LPAR var-declr SEMI SEMI RPAR LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    RETURN       shift, and go to state 23
    TRUE_RW      shift, and go to state 24
    VAR          shift, and go to state 25
    WHILE        shift, and go to state 26

    $default  reduce using rule 3 (line)

    line             go to state 386
    stmt-list        go to state 29
    stmt             go to state 30
    assign-expr      go to state 31
    for-stmt         go to state 32
    do-while-stmt    go to state 33
    while-stmt       go to state 34
    if-stmt          go to state 35
    logic-expr       go to state 36
    class-def        go to state 37
    func-def         go to state 38
    var-declr        go to state 39
    var-declr-rw     go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 353

   32 for-stmt: FOR LPAR var-declr SEMI SEMI assign-expr RPAR . LBRACE line RBRACE

    LBRACE  shift, and go to state 387


State 354

   31 for-stmt: FOR LPAR var-declr SEMI SEMI expr RPAR . LBRACE line RBRACE

    LBRACE  shift, and go to state 388


State 355

   30 for-stmt: FOR LPAR var-declr SEMI expr SEMI RPAR . LBRACE line RBRACE

    LBRACE  shift, and go to state 389


State 356

   29 for-stmt: FOR LPAR var-declr SEMI expr SEMI assign-expr . RPAR LBRACE line RBRACE

    RPAR  shift, and go to state 390


State 357

   28 for-stmt: FOR LPAR var-declr SEMI expr SEMI expr . RPAR LBRACE line RBRACE
   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  153 arit-expr: expr . PLUS expr
  154          | expr . SUB expr
  155          | expr . MULT expr
  156          | expr . DIV expr
  157          | expr . EXP expr
  158          | expr . REM expr
  159 bitw-expr: expr . BITWISE_AND expr
  160          | expr . BITWISE_OR expr
  161          | expr . BITWISE_XOR expr
  162 shift-expr: expr . LSHIFT expr
  163           | expr . RSHIFT expr
  164           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 115
    SUB              shift, and go to state 116
    MULT             shift, and go to state 117
    DIV              shift, and go to state 118
    EXP              shift, and go to state 119
    REM              shift, and go to state 120
    BITWISE_AND      shift, and go to state 121
    BITWISE_OR       shift, and go to state 122
    BITWISE_XOR      shift, and go to state 123
    LOGICAL_NULL     shift, and go to state 124
    LOGICAL_AND      shift, and go to state 125
    LOGICAL_OR       shift, and go to state 126
    EQ               shift, and go to state 127
    EQ_STRICT        shift, and go to state 128
    INEQ             shift, and go to state 129
    INEQ_STRICT      shift, and go to state 130
    LT               shift, and go to state 131
    LT_EQ            shift, and go to state 132
    GT               shift, and go to state 133
    GT_EQ            shift, and go to state 134
    LSHIFT           shift, and go to state 135
    RSHIFT           shift, and go to state 136
    RSHIFT_UNSIGNED  shift, and go to state 137
    RPAR             shift, and go to state 391


State 358

   93 params: COMMA ID COLON var-type .

    $default  reduce using rule 93 (params)


State 359

   98 params: ID COMMA ID COLON . var-type

    VOID_RW    shift, and go to state 152
    ANY        shift, and go to state 153
    BOOLTYPE   shift, and go to state 154
    NEVER      shift, and go to state 155
    NUMBER     shift, and go to state 156
    STRING     shift, and go to state 157
    UNDEFINED  shift, and go to state 158

    var-type  go to state 392


State 360

   95 params: ID COLON var-type COMMA . ID COLON var-type
   96       | ID COLON var-type COMMA . ID

    ID  shift, and go to state 393


State 361

   91 func-def: FUNCTION ID LPAR params RPAR COLON var-type . LBRACE line RBRACE

    LBRACE  shift, and go to state 394


State 362

   90 func-def: FUNCTION ID LPAR params RPAR LBRACE line . RBRACE

    RBRACE  shift, and go to state 395


State 363

   63 if-stmt: IF LPAR assign-expr RPAR LBRACE line RBRACE .
   64        | IF LPAR assign-expr RPAR LBRACE line RBRACE . ELSE LBRACE line RBRACE
   65        | IF LPAR assign-expr RPAR LBRACE line RBRACE . ELSE stmt

    ELSE  shift, and go to state 396

    $default  reduce using rule 63 (if-stmt)


State 364

   60 if-stmt: IF LPAR expr RPAR LBRACE line RBRACE .
   61        | IF LPAR expr RPAR LBRACE line RBRACE . ELSE LBRACE line RBRACE
   62        | IF LPAR expr RPAR LBRACE line RBRACE . ELSE stmt

    ELSE  shift, and go to state 397

    $default  reduce using rule 60 (if-stmt)


State 365

  182 var-obj: NEW ID LT var-type GT LPAR args-list . RPAR

    RPAR  shift, and go to state 398


State 366

   59 while-stmt: WHILE LPAR assign-expr RPAR LBRACE line RBRACE .

    $default  reduce using rule 59 (while-stmt)


State 367

   58 while-stmt: WHILE LPAR expr RPAR LBRACE line RBRACE .

    $default  reduce using rule 58 (while-stmt)


State 368

  106 var-declr: var-declr-rw ID COLON var-type LBRACKET RBRACKET ASSIGN . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 63
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    TRUE_RW      shift, and go to state 24

    logic-expr       go to state 36
    expr             go to state 399
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 65
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 66
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 369

   86 class-att: ID LPAR params RPAR COLON . var-type LBRACE line RBRACE

    VOID_RW    shift, and go to state 152
    ANY        shift, and go to state 153
    BOOLTYPE   shift, and go to state 154
    NEVER      shift, and go to state 155
    NUMBER     shift, and go to state 156
    STRING     shift, and go to state 157
    UNDEFINED  shift, and go to state 158

    var-type  go to state 400


State 370

   85 class-att: ID LPAR params RPAR LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    RETURN       shift, and go to state 23
    TRUE_RW      shift, and go to state 24
    VAR          shift, and go to state 25
    WHILE        shift, and go to state 26

    $default  reduce using rule 3 (line)

    line             go to state 401
    stmt-list        go to state 29
    stmt             go to state 30
    assign-expr      go to state 31
    for-stmt         go to state 32
    do-while-stmt    go to state 33
    while-stmt       go to state 34
    if-stmt          go to state 35
    logic-expr       go to state 36
    class-def        go to state 37
    func-def         go to state 38
    var-declr        go to state 39
    var-declr-rw     go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 371

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  109 var-declr: CONST_RW ID COLON var-type LBRACKET RBRACKET ASSIGN expr .
  153 arit-expr: expr . PLUS expr
  154          | expr . SUB expr
  155          | expr . MULT expr
  156          | expr . DIV expr
  157          | expr . EXP expr
  158          | expr . REM expr
  159 bitw-expr: expr . BITWISE_AND expr
  160          | expr . BITWISE_OR expr
  161          | expr . BITWISE_XOR expr
  162 shift-expr: expr . LSHIFT expr
  163           | expr . RSHIFT expr
  164           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 115
    SUB              shift, and go to state 116
    MULT             shift, and go to state 117
    DIV              shift, and go to state 118
    EXP              shift, and go to state 119
    REM              shift, and go to state 120
    BITWISE_AND      shift, and go to state 121
    BITWISE_OR       shift, and go to state 122
    BITWISE_XOR      shift, and go to state 123
    LOGICAL_NULL     shift, and go to state 124
    LOGICAL_AND      shift, and go to state 125
    LOGICAL_OR       shift, and go to state 126
    EQ               shift, and go to state 127
    EQ_STRICT        shift, and go to state 128
    INEQ             shift, and go to state 129
    INEQ_STRICT      shift, and go to state 130
    LT               shift, and go to state 131
    LT_EQ            shift, and go to state 132
    GT               shift, and go to state 133
    GT_EQ            shift, and go to state 134
    LSHIFT           shift, and go to state 135
    RSHIFT           shift, and go to state 136
    RSHIFT_UNSIGNED  shift, and go to state 137

    $default  reduce using rule 109 (var-declr)


State 372

   57 do-while-stmt: DO LBRACE line RBRACE WHILE LPAR assign-expr RPAR .

    $default  reduce using rule 57 (do-while-stmt)


State 373

   56 do-while-stmt: DO LBRACE line RBRACE WHILE LPAR expr RPAR .

    $default  reduce using rule 56 (do-while-stmt)


State 374

   39 for-stmt: FOR LPAR SEMI SEMI RPAR LBRACE line RBRACE .

    $default  reduce using rule 39 (for-stmt)


State 375

   38 for-stmt: FOR LPAR SEMI SEMI assign-expr RPAR LBRACE line . RBRACE

    RBRACE  shift, and go to state 402


State 376

   37 for-stmt: FOR LPAR SEMI SEMI expr RPAR LBRACE line . RBRACE

    RBRACE  shift, and go to state 403


State 377

   36 for-stmt: FOR LPAR SEMI expr SEMI RPAR LBRACE line . RBRACE

    RBRACE  shift, and go to state 404


State 378

   35 for-stmt: FOR LPAR SEMI expr SEMI assign-expr RPAR LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    RETURN       shift, and go to state 23
    TRUE_RW      shift, and go to state 24
    VAR          shift, and go to state 25
    WHILE        shift, and go to state 26

    $default  reduce using rule 3 (line)

    line             go to state 405
    stmt-list        go to state 29
    stmt             go to state 30
    assign-expr      go to state 31
    for-stmt         go to state 32
    do-while-stmt    go to state 33
    while-stmt       go to state 34
    if-stmt          go to state 35
    logic-expr       go to state 36
    class-def        go to state 37
    func-def         go to state 38
    var-declr        go to state 39
    var-declr-rw     go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 379

   34 for-stmt: FOR LPAR SEMI expr SEMI expr RPAR LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    RETURN       shift, and go to state 23
    TRUE_RW      shift, and go to state 24
    VAR          shift, and go to state 25
    WHILE        shift, and go to state 26

    $default  reduce using rule 3 (line)

    line             go to state 406
    stmt-list        go to state 29
    stmt             go to state 30
    assign-expr      go to state 31
    for-stmt         go to state 32
    do-while-stmt    go to state 33
    while-stmt       go to state 34
    if-stmt          go to state 35
    logic-expr       go to state 36
    class-def        go to state 37
    func-def         go to state 38
    var-declr        go to state 39
    var-declr-rw     go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 380

   27 for-stmt: FOR LPAR assign-expr SEMI SEMI RPAR LBRACE line . RBRACE

    RBRACE  shift, and go to state 407


State 381

   26 for-stmt: FOR LPAR assign-expr SEMI SEMI assign-expr RPAR LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    RETURN       shift, and go to state 23
    TRUE_RW      shift, and go to state 24
    VAR          shift, and go to state 25
    WHILE        shift, and go to state 26

    $default  reduce using rule 3 (line)

    line             go to state 408
    stmt-list        go to state 29
    stmt             go to state 30
    assign-expr      go to state 31
    for-stmt         go to state 32
    do-while-stmt    go to state 33
    while-stmt       go to state 34
    if-stmt          go to state 35
    logic-expr       go to state 36
    class-def        go to state 37
    func-def         go to state 38
    var-declr        go to state 39
    var-declr-rw     go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 382

   25 for-stmt: FOR LPAR assign-expr SEMI SEMI expr RPAR LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    RETURN       shift, and go to state 23
    TRUE_RW      shift, and go to state 24
    VAR          shift, and go to state 25
    WHILE        shift, and go to state 26

    $default  reduce using rule 3 (line)

    line             go to state 409
    stmt-list        go to state 29
    stmt             go to state 30
    assign-expr      go to state 31
    for-stmt         go to state 32
    do-while-stmt    go to state 33
    while-stmt       go to state 34
    if-stmt          go to state 35
    logic-expr       go to state 36
    class-def        go to state 37
    func-def         go to state 38
    var-declr        go to state 39
    var-declr-rw     go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 383

   24 for-stmt: FOR LPAR assign-expr SEMI expr SEMI RPAR LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    RETURN       shift, and go to state 23
    TRUE_RW      shift, and go to state 24
    VAR          shift, and go to state 25
    WHILE        shift, and go to state 26

    $default  reduce using rule 3 (line)

    line             go to state 410
    stmt-list        go to state 29
    stmt             go to state 30
    assign-expr      go to state 31
    for-stmt         go to state 32
    do-while-stmt    go to state 33
    while-stmt       go to state 34
    if-stmt          go to state 35
    logic-expr       go to state 36
    class-def        go to state 37
    func-def         go to state 38
    var-declr        go to state 39
    var-declr-rw     go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 384

   23 for-stmt: FOR LPAR assign-expr SEMI expr SEMI assign-expr RPAR . LBRACE line RBRACE

    LBRACE  shift, and go to state 411


State 385

   22 for-stmt: FOR LPAR assign-expr SEMI expr SEMI expr RPAR . LBRACE line RBRACE

    LBRACE  shift, and go to state 412


State 386

   33 for-stmt: FOR LPAR var-declr SEMI SEMI RPAR LBRACE line . RBRACE

    RBRACE  shift, and go to state 413


State 387

   32 for-stmt: FOR LPAR var-declr SEMI SEMI assign-expr RPAR LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    RETURN       shift, and go to state 23
    TRUE_RW      shift, and go to state 24
    VAR          shift, and go to state 25
    WHILE        shift, and go to state 26

    $default  reduce using rule 3 (line)

    line             go to state 414
    stmt-list        go to state 29
    stmt             go to state 30
    assign-expr      go to state 31
    for-stmt         go to state 32
    do-while-stmt    go to state 33
    while-stmt       go to state 34
    if-stmt          go to state 35
    logic-expr       go to state 36
    class-def        go to state 37
    func-def         go to state 38
    var-declr        go to state 39
    var-declr-rw     go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 388

   31 for-stmt: FOR LPAR var-declr SEMI SEMI expr RPAR LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    RETURN       shift, and go to state 23
    TRUE_RW      shift, and go to state 24
    VAR          shift, and go to state 25
    WHILE        shift, and go to state 26

    $default  reduce using rule 3 (line)

    line             go to state 415
    stmt-list        go to state 29
    stmt             go to state 30
    assign-expr      go to state 31
    for-stmt         go to state 32
    do-while-stmt    go to state 33
    while-stmt       go to state 34
    if-stmt          go to state 35
    logic-expr       go to state 36
    class-def        go to state 37
    func-def         go to state 38
    var-declr        go to state 39
    var-declr-rw     go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 389

   30 for-stmt: FOR LPAR var-declr SEMI expr SEMI RPAR LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    RETURN       shift, and go to state 23
    TRUE_RW      shift, and go to state 24
    VAR          shift, and go to state 25
    WHILE        shift, and go to state 26

    $default  reduce using rule 3 (line)

    line             go to state 416
    stmt-list        go to state 29
    stmt             go to state 30
    assign-expr      go to state 31
    for-stmt         go to state 32
    do-while-stmt    go to state 33
    while-stmt       go to state 34
    if-stmt          go to state 35
    logic-expr       go to state 36
    class-def        go to state 37
    func-def         go to state 38
    var-declr        go to state 39
    var-declr-rw     go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 390

   29 for-stmt: FOR LPAR var-declr SEMI expr SEMI assign-expr RPAR . LBRACE line RBRACE

    LBRACE  shift, and go to state 417


State 391

   28 for-stmt: FOR LPAR var-declr SEMI expr SEMI expr RPAR . LBRACE line RBRACE

    LBRACE  shift, and go to state 418


State 392

   98 params: ID COMMA ID COLON var-type .

    $default  reduce using rule 98 (params)


State 393

   95 params: ID COLON var-type COMMA ID . COLON var-type
   96       | ID COLON var-type COMMA ID .

    COLON  shift, and go to state 419

    $default  reduce using rule 96 (params)


State 394

   91 func-def: FUNCTION ID LPAR params RPAR COLON var-type LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    RETURN       shift, and go to state 23
    TRUE_RW      shift, and go to state 24
    VAR          shift, and go to state 25
    WHILE        shift, and go to state 26

    $default  reduce using rule 3 (line)

    line             go to state 420
    stmt-list        go to state 29
    stmt             go to state 30
    assign-expr      go to state 31
    for-stmt         go to state 32
    do-while-stmt    go to state 33
    while-stmt       go to state 34
    if-stmt          go to state 35
    logic-expr       go to state 36
    class-def        go to state 37
    func-def         go to state 38
    var-declr        go to state 39
    var-declr-rw     go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 395

   90 func-def: FUNCTION ID LPAR params RPAR LBRACE line RBRACE .

    $default  reduce using rule 90 (func-def)


State 396

   64 if-stmt: IF LPAR assign-expr RPAR LBRACE line RBRACE ELSE . LBRACE line RBRACE
   65        | IF LPAR assign-expr RPAR LBRACE line RBRACE ELSE . stmt

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACE       shift, and go to state 421
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    RETURN       shift, and go to state 23
    TRUE_RW      shift, and go to state 24
    VAR          shift, and go to state 25
    WHILE        shift, and go to state 26

    stmt             go to state 422
    assign-expr      go to state 31
    for-stmt         go to state 32
    do-while-stmt    go to state 33
    while-stmt       go to state 34
    if-stmt          go to state 35
    logic-expr       go to state 36
    class-def        go to state 37
    func-def         go to state 38
    var-declr        go to state 39
    var-declr-rw     go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 397

   61 if-stmt: IF LPAR expr RPAR LBRACE line RBRACE ELSE . LBRACE line RBRACE
   62        | IF LPAR expr RPAR LBRACE line RBRACE ELSE . stmt

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACE       shift, and go to state 423
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    RETURN       shift, and go to state 23
    TRUE_RW      shift, and go to state 24
    VAR          shift, and go to state 25
    WHILE        shift, and go to state 26

    stmt             go to state 424
    assign-expr      go to state 31
    for-stmt         go to state 32
    do-while-stmt    go to state 33
    while-stmt       go to state 34
    if-stmt          go to state 35
    logic-expr       go to state 36
    class-def        go to state 37
    func-def         go to state 38
    var-declr        go to state 39
    var-declr-rw     go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 398

  182 var-obj: NEW ID LT var-type GT LPAR args-list RPAR .

    $default  reduce using rule 182 (var-obj)


State 399

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  106 var-declr: var-declr-rw ID COLON var-type LBRACKET RBRACKET ASSIGN expr .
  153 arit-expr: expr . PLUS expr
  154          | expr . SUB expr
  155          | expr . MULT expr
  156          | expr . DIV expr
  157          | expr . EXP expr
  158          | expr . REM expr
  159 bitw-expr: expr . BITWISE_AND expr
  160          | expr . BITWISE_OR expr
  161          | expr . BITWISE_XOR expr
  162 shift-expr: expr . LSHIFT expr
  163           | expr . RSHIFT expr
  164           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 115
    SUB              shift, and go to state 116
    MULT             shift, and go to state 117
    DIV              shift, and go to state 118
    EXP              shift, and go to state 119
    REM              shift, and go to state 120
    BITWISE_AND      shift, and go to state 121
    BITWISE_OR       shift, and go to state 122
    BITWISE_XOR      shift, and go to state 123
    LOGICAL_NULL     shift, and go to state 124
    LOGICAL_AND      shift, and go to state 125
    LOGICAL_OR       shift, and go to state 126
    EQ               shift, and go to state 127
    EQ_STRICT        shift, and go to state 128
    INEQ             shift, and go to state 129
    INEQ_STRICT      shift, and go to state 130
    LT               shift, and go to state 131
    LT_EQ            shift, and go to state 132
    GT               shift, and go to state 133
    GT_EQ            shift, and go to state 134
    LSHIFT           shift, and go to state 135
    RSHIFT           shift, and go to state 136
    RSHIFT_UNSIGNED  shift, and go to state 137

    $default  reduce using rule 106 (var-declr)


State 400

   86 class-att: ID LPAR params RPAR COLON var-type . LBRACE line RBRACE

    LBRACE  shift, and go to state 425


State 401

   85 class-att: ID LPAR params RPAR LBRACE line . RBRACE

    RBRACE  shift, and go to state 426


State 402

   38 for-stmt: FOR LPAR SEMI SEMI assign-expr RPAR LBRACE line RBRACE .

    $default  reduce using rule 38 (for-stmt)


State 403

   37 for-stmt: FOR LPAR SEMI SEMI expr RPAR LBRACE line RBRACE .

    $default  reduce using rule 37 (for-stmt)


State 404

   36 for-stmt: FOR LPAR SEMI expr SEMI RPAR LBRACE line RBRACE .

    $default  reduce using rule 36 (for-stmt)


State 405

   35 for-stmt: FOR LPAR SEMI expr SEMI assign-expr RPAR LBRACE line . RBRACE

    RBRACE  shift, and go to state 427


State 406

   34 for-stmt: FOR LPAR SEMI expr SEMI expr RPAR LBRACE line . RBRACE

    RBRACE  shift, and go to state 428


State 407

   27 for-stmt: FOR LPAR assign-expr SEMI SEMI RPAR LBRACE line RBRACE .

    $default  reduce using rule 27 (for-stmt)


State 408

   26 for-stmt: FOR LPAR assign-expr SEMI SEMI assign-expr RPAR LBRACE line . RBRACE

    RBRACE  shift, and go to state 429


State 409

   25 for-stmt: FOR LPAR assign-expr SEMI SEMI expr RPAR LBRACE line . RBRACE

    RBRACE  shift, and go to state 430


State 410

   24 for-stmt: FOR LPAR assign-expr SEMI expr SEMI RPAR LBRACE line . RBRACE

    RBRACE  shift, and go to state 431


State 411

   23 for-stmt: FOR LPAR assign-expr SEMI expr SEMI assign-expr RPAR LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    RETURN       shift, and go to state 23
    TRUE_RW      shift, and go to state 24
    VAR          shift, and go to state 25
    WHILE        shift, and go to state 26

    $default  reduce using rule 3 (line)

    line             go to state 432
    stmt-list        go to state 29
    stmt             go to state 30
    assign-expr      go to state 31
    for-stmt         go to state 32
    do-while-stmt    go to state 33
    while-stmt       go to state 34
    if-stmt          go to state 35
    logic-expr       go to state 36
    class-def        go to state 37
    func-def         go to state 38
    var-declr        go to state 39
    var-declr-rw     go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 412

   22 for-stmt: FOR LPAR assign-expr SEMI expr SEMI expr RPAR LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    RETURN       shift, and go to state 23
    TRUE_RW      shift, and go to state 24
    VAR          shift, and go to state 25
    WHILE        shift, and go to state 26

    $default  reduce using rule 3 (line)

    line             go to state 433
    stmt-list        go to state 29
    stmt             go to state 30
    assign-expr      go to state 31
    for-stmt         go to state 32
    do-while-stmt    go to state 33
    while-stmt       go to state 34
    if-stmt          go to state 35
    logic-expr       go to state 36
    class-def        go to state 37
    func-def         go to state 38
    var-declr        go to state 39
    var-declr-rw     go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 413

   33 for-stmt: FOR LPAR var-declr SEMI SEMI RPAR LBRACE line RBRACE .

    $default  reduce using rule 33 (for-stmt)


State 414

   32 for-stmt: FOR LPAR var-declr SEMI SEMI assign-expr RPAR LBRACE line . RBRACE

    RBRACE  shift, and go to state 434


State 415

   31 for-stmt: FOR LPAR var-declr SEMI SEMI expr RPAR LBRACE line . RBRACE

    RBRACE  shift, and go to state 435


State 416

   30 for-stmt: FOR LPAR var-declr SEMI expr SEMI RPAR LBRACE line . RBRACE

    RBRACE  shift, and go to state 436


State 417

   29 for-stmt: FOR LPAR var-declr SEMI expr SEMI assign-expr RPAR LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    RETURN       shift, and go to state 23
    TRUE_RW      shift, and go to state 24
    VAR          shift, and go to state 25
    WHILE        shift, and go to state 26

    $default  reduce using rule 3 (line)

    line             go to state 437
    stmt-list        go to state 29
    stmt             go to state 30
    assign-expr      go to state 31
    for-stmt         go to state 32
    do-while-stmt    go to state 33
    while-stmt       go to state 34
    if-stmt          go to state 35
    logic-expr       go to state 36
    class-def        go to state 37
    func-def         go to state 38
    var-declr        go to state 39
    var-declr-rw     go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 418

   28 for-stmt: FOR LPAR var-declr SEMI expr SEMI expr RPAR LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    RETURN       shift, and go to state 23
    TRUE_RW      shift, and go to state 24
    VAR          shift, and go to state 25
    WHILE        shift, and go to state 26

    $default  reduce using rule 3 (line)

    line             go to state 438
    stmt-list        go to state 29
    stmt             go to state 30
    assign-expr      go to state 31
    for-stmt         go to state 32
    do-while-stmt    go to state 33
    while-stmt       go to state 34
    if-stmt          go to state 35
    logic-expr       go to state 36
    class-def        go to state 37
    func-def         go to state 38
    var-declr        go to state 39
    var-declr-rw     go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 419

   95 params: ID COLON var-type COMMA ID COLON . var-type

    VOID_RW    shift, and go to state 152
    ANY        shift, and go to state 153
    BOOLTYPE   shift, and go to state 154
    NEVER      shift, and go to state 155
    NUMBER     shift, and go to state 156
    STRING     shift, and go to state 157
    UNDEFINED  shift, and go to state 158

    var-type  go to state 439


State 420

   91 func-def: FUNCTION ID LPAR params RPAR COLON var-type LBRACE line . RBRACE

    RBRACE  shift, and go to state 440


State 421

   64 if-stmt: IF LPAR assign-expr RPAR LBRACE line RBRACE ELSE LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    RETURN       shift, and go to state 23
    TRUE_RW      shift, and go to state 24
    VAR          shift, and go to state 25
    WHILE        shift, and go to state 26

    $default  reduce using rule 3 (line)

    line             go to state 441
    stmt-list        go to state 29
    stmt             go to state 30
    assign-expr      go to state 31
    for-stmt         go to state 32
    do-while-stmt    go to state 33
    while-stmt       go to state 34
    if-stmt          go to state 35
    logic-expr       go to state 36
    class-def        go to state 37
    func-def         go to state 38
    var-declr        go to state 39
    var-declr-rw     go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 422

   65 if-stmt: IF LPAR assign-expr RPAR LBRACE line RBRACE ELSE stmt .

    $default  reduce using rule 65 (if-stmt)


State 423

   61 if-stmt: IF LPAR expr RPAR LBRACE line RBRACE ELSE LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    RETURN       shift, and go to state 23
    TRUE_RW      shift, and go to state 24
    VAR          shift, and go to state 25
    WHILE        shift, and go to state 26

    $default  reduce using rule 3 (line)

    line             go to state 442
    stmt-list        go to state 29
    stmt             go to state 30
    assign-expr      go to state 31
    for-stmt         go to state 32
    do-while-stmt    go to state 33
    while-stmt       go to state 34
    if-stmt          go to state 35
    logic-expr       go to state 36
    class-def        go to state 37
    func-def         go to state 38
    var-declr        go to state 39
    var-declr-rw     go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 424

   62 if-stmt: IF LPAR expr RPAR LBRACE line RBRACE ELSE stmt .

    $default  reduce using rule 62 (if-stmt)


State 425

   86 class-att: ID LPAR params RPAR COLON var-type LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    RETURN       shift, and go to state 23
    TRUE_RW      shift, and go to state 24
    VAR          shift, and go to state 25
    WHILE        shift, and go to state 26

    $default  reduce using rule 3 (line)

    line             go to state 443
    stmt-list        go to state 29
    stmt             go to state 30
    assign-expr      go to state 31
    for-stmt         go to state 32
    do-while-stmt    go to state 33
    while-stmt       go to state 34
    if-stmt          go to state 35
    logic-expr       go to state 36
    class-def        go to state 37
    func-def         go to state 38
    var-declr        go to state 39
    var-declr-rw     go to state 40
    expr             go to state 41
    idx-unsafe-expr  go to state 42
    idx-safe-expr    go to state 43
    vet-idx          go to state 44
    unary-expr       go to state 45
    arit-expr        go to state 46
    bitw-expr        go to state 47
    shift-expr       go to state 48
    var-att          go to state 49
    var-met          go to state 50
    var-obj          go to state 51
    var-val          go to state 52
    array-expr       go to state 53


State 426

   85 class-att: ID LPAR params RPAR LBRACE line RBRACE .

    $default  reduce using rule 85 (class-att)


State 427

   35 for-stmt: FOR LPAR SEMI expr SEMI assign-expr RPAR LBRACE line RBRACE .

    $default  reduce using rule 35 (for-stmt)


State 428

   34 for-stmt: FOR LPAR SEMI expr SEMI expr RPAR LBRACE line RBRACE .

    $default  reduce using rule 34 (for-stmt)


State 429

   26 for-stmt: FOR LPAR assign-expr SEMI SEMI assign-expr RPAR LBRACE line RBRACE .

    $default  reduce using rule 26 (for-stmt)


State 430

   25 for-stmt: FOR LPAR assign-expr SEMI SEMI expr RPAR LBRACE line RBRACE .

    $default  reduce using rule 25 (for-stmt)


State 431

   24 for-stmt: FOR LPAR assign-expr SEMI expr SEMI RPAR LBRACE line RBRACE .

    $default  reduce using rule 24 (for-stmt)


State 432

   23 for-stmt: FOR LPAR assign-expr SEMI expr SEMI assign-expr RPAR LBRACE line . RBRACE

    RBRACE  shift, and go to state 444


State 433

   22 for-stmt: FOR LPAR assign-expr SEMI expr SEMI expr RPAR LBRACE line . RBRACE

    RBRACE  shift, and go to state 445


State 434

   32 for-stmt: FOR LPAR var-declr SEMI SEMI assign-expr RPAR LBRACE line RBRACE .

    $default  reduce using rule 32 (for-stmt)


State 435

   31 for-stmt: FOR LPAR var-declr SEMI SEMI expr RPAR LBRACE line RBRACE .

    $default  reduce using rule 31 (for-stmt)


State 436

   30 for-stmt: FOR LPAR var-declr SEMI expr SEMI RPAR LBRACE line RBRACE .

    $default  reduce using rule 30 (for-stmt)


State 437

   29 for-stmt: FOR LPAR var-declr SEMI expr SEMI assign-expr RPAR LBRACE line . RBRACE

    RBRACE  shift, and go to state 446


State 438

   28 for-stmt: FOR LPAR var-declr SEMI expr SEMI expr RPAR LBRACE line . RBRACE

    RBRACE  shift, and go to state 447


State 439

   95 params: ID COLON var-type COMMA ID COLON var-type .

    $default  reduce using rule 95 (params)


State 440

   91 func-def: FUNCTION ID LPAR params RPAR COLON var-type LBRACE line RBRACE .

    $default  reduce using rule 91 (func-def)


State 441

   64 if-stmt: IF LPAR assign-expr RPAR LBRACE line RBRACE ELSE LBRACE line . RBRACE

    RBRACE  shift, and go to state 448


State 442

   61 if-stmt: IF LPAR expr RPAR LBRACE line RBRACE ELSE LBRACE line . RBRACE

    RBRACE  shift, and go to state 449


State 443

   86 class-att: ID LPAR params RPAR COLON var-type LBRACE line . RBRACE

    RBRACE  shift, and go to state 450


State 444

   23 for-stmt: FOR LPAR assign-expr SEMI expr SEMI assign-expr RPAR LBRACE line RBRACE .

    $default  reduce using rule 23 (for-stmt)


State 445

   22 for-stmt: FOR LPAR assign-expr SEMI expr SEMI expr RPAR LBRACE line RBRACE .

    $default  reduce using rule 22 (for-stmt)


State 446

   29 for-stmt: FOR LPAR var-declr SEMI expr SEMI assign-expr RPAR LBRACE line RBRACE .

    $default  reduce using rule 29 (for-stmt)


State 447

   28 for-stmt: FOR LPAR var-declr SEMI expr SEMI expr RPAR LBRACE line RBRACE .

    $default  reduce using rule 28 (for-stmt)


State 448

   64 if-stmt: IF LPAR assign-expr RPAR LBRACE line RBRACE ELSE LBRACE line RBRACE .

    $default  reduce using rule 64 (if-stmt)


State 449

   61 if-stmt: IF LPAR expr RPAR LBRACE line RBRACE ELSE LBRACE line RBRACE .

    $default  reduce using rule 61 (if-stmt)


State 450

   86 class-att: ID LPAR params RPAR COLON var-type LBRACE line RBRACE .

    $default  reduce using rule 86 (class-att)
