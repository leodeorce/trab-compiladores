Terminals unused in grammar

   ARROW
   TERNARY
   CHAIN
   PIPELINE
   SPREAD
   CASE
   CATCH
   DEBUGGER
   DEFAULT
   DELETE
   ENUM
   EXPORT
   EXTENDS
   FINALLY
   IMPLEMENTS
   IMPORT
   IN
   INSTANCEOF
   INTERFACE
   PACKAGE
   SUPER
   SWITCH
   THIS
   THROW
   TRY
   TYPEOF
   WITH
   AWAIT
   YIELD
   STATIC
   AS
   ASYNC
   FROM
   GET
   OF
   SET
   TARGET
   CONSTRUCTOR
   DECLARE
   MODULE
   REQUIRE
   SYMBOL
   TYPE


Grammar

    0 $accept: begin $end

    1 begin: line

    2 line: stmt-list
    3     | %empty

    4 stmt-list: stmt-list stmt
    5          | stmt

    6 stmt: var-declr SEMI
    7     | func-def
    8     | class-def
    9     | expr SEMI
   10     | assign-expr SEMI
   11     | if-stmt
   12     | while-stmt
   13     | do-while-stmt
   14     | for-stmt
   15     | RETURN SEMI
   16     | RETURN expr SEMI
   17     | BREAK SEMI
   18     | CONTINUE SEMI

   19 assign-expr: var-att assignment expr
   20            | ID assignment expr
   21            | vet-idx assignment expr

   22 for-stmt: FOR LPAR assign-expr SEMI expr SEMI expr RPAR LBRACE line RBRACE
   23         | FOR LPAR assign-expr SEMI expr SEMI assign-expr RPAR LBRACE line RBRACE
   24         | FOR LPAR assign-expr SEMI expr SEMI RPAR LBRACE line RBRACE
   25         | FOR LPAR assign-expr SEMI SEMI expr RPAR LBRACE line RBRACE
   26         | FOR LPAR assign-expr SEMI SEMI assign-expr RPAR LBRACE line RBRACE
   27         | FOR LPAR assign-expr SEMI SEMI RPAR LBRACE line RBRACE
   28         | FOR LPAR var-declr SEMI expr SEMI expr RPAR LBRACE line RBRACE
   29         | FOR LPAR var-declr SEMI expr SEMI assign-expr RPAR LBRACE line RBRACE
   30         | FOR LPAR var-declr SEMI expr SEMI RPAR LBRACE line RBRACE
   31         | FOR LPAR var-declr SEMI SEMI expr RPAR LBRACE line RBRACE
   32         | FOR LPAR var-declr SEMI SEMI assign-expr RPAR LBRACE line RBRACE
   33         | FOR LPAR var-declr SEMI SEMI RPAR LBRACE line RBRACE
   34         | FOR LPAR SEMI expr SEMI expr RPAR LBRACE line RBRACE
   35         | FOR LPAR SEMI expr SEMI assign-expr RPAR LBRACE line RBRACE
   36         | FOR LPAR SEMI expr SEMI RPAR LBRACE line RBRACE
   37         | FOR LPAR SEMI SEMI expr RPAR LBRACE line RBRACE
   38         | FOR LPAR SEMI SEMI assign-expr RPAR LBRACE line RBRACE
   39         | FOR LPAR SEMI SEMI RPAR LBRACE line RBRACE

   40 assignment: ASSIGN
   41           | LOGICAL_NULL_ASSIGN
   42           | LOGICAL_AND_ASSIGN
   43           | LOGICAL_OR_ASSIGN
   44           | PLUS_ASSIGN
   45           | SUB_ASSIGN
   46           | MULT_ASSIGN
   47           | DIV_ASSIGN
   48           | EXP_ASSIGN
   49           | REM_ASSIGN
   50           | BITWISE_AND_ASSIGN
   51           | BITWISE_OR_ASSIGN
   52           | BITWISE_XOR_ASSIGN
   53           | LSHIFT_ASSIGN
   54           | RSHIFT_ASSIGN
   55           | RSHIFT_UNSIGNED_ASSIGN

   56 do-while-stmt: DO LBRACE line RBRACE WHILE LPAR expr RPAR
   57              | DO LBRACE line RBRACE WHILE LPAR assign-expr RPAR

   58 while-stmt: WHILE LPAR expr RPAR LBRACE line RBRACE
   59           | WHILE LPAR assign-expr RPAR LBRACE line RBRACE

   60 if-stmt: IF LPAR expr RPAR LBRACE line RBRACE
   61        | IF LPAR expr RPAR LBRACE line RBRACE ELSE LBRACE line RBRACE
   62        | IF LPAR expr RPAR LBRACE line RBRACE ELSE stmt
   63        | IF LPAR assign-expr RPAR LBRACE line RBRACE
   64        | IF LPAR assign-expr RPAR LBRACE line RBRACE ELSE LBRACE line RBRACE
   65        | IF LPAR assign-expr RPAR LBRACE line RBRACE ELSE stmt

   66 logic-expr: expr EQ expr
   67           | expr EQ_STRICT expr
   68           | expr INEQ expr
   69           | expr INEQ_STRICT expr
   70           | expr LT expr
   71           | ID LT expr
   72           | expr LT_EQ expr
   73           | expr GT expr
   74           | expr GT_EQ expr
   75           | expr LOGICAL_NULL expr
   76           | expr LOGICAL_AND expr
   77           | expr LOGICAL_OR expr

   78 class-def: CLASS ID LBRACE class-att-list RBRACE

   79 class-att-list: SEMI class-att-list
   80               | class-att SEMI class-att-list
   81               | class-att
   82               | %empty

   83 class-att: ID COLON var-type
   84          | access-modif ID COLON var-type
   85          | ID LPAR params RPAR LBRACE line RBRACE
   86          | ID LPAR params RPAR COLON var-type LBRACE line RBRACE

   87 access-modif: PUBLIC
   88             | PRIVATE
   89             | PROTECTED

   90 func-def: FUNCTION ID LPAR params RPAR LBRACE line RBRACE
   91         | FUNCTION ID LPAR params RPAR COLON var-type LBRACE line RBRACE

   92 params: COMMA ID
   93       | COMMA ID COLON var-type
   94       | ID COMMA ID
   95       | ID COLON var-type COMMA ID COLON var-type
   96       | ID COLON var-type COMMA ID
   97       | ID COLON var-type
   98       | ID COMMA ID COLON var-type
   99       | %empty

  100 var-declr: LET id-list
  101          | LET id-list ASSIGN expr
  102          | LET id-list ASSIGN obj-def
  103          | LET ID COLON var-type
  104          | LET ID COLON var-type ASSIGN expr
  105          | LET ID COLON var-type LBRACKET RBRACKET
  106          | LET ID COLON var-type LBRACKET RBRACKET ASSIGN expr
  107          | VAR id-list
  108          | VAR id-list ASSIGN expr
  109          | VAR id-list ASSIGN obj-def
  110          | VAR ID COLON var-type
  111          | VAR ID COLON var-type ASSIGN expr
  112          | VAR ID COLON var-type LBRACKET RBRACKET
  113          | VAR ID COLON var-type LBRACKET RBRACKET ASSIGN expr
  114          | CONST_RW id-list ASSIGN expr
  115          | CONST_RW ID COLON var-type ASSIGN expr
  116          | CONST_RW ID COLON var-type LBRACKET RBRACKET ASSIGN expr
  117          | CONST_RW id-list ASSIGN obj-def

  118 id-list: ID COMMA id-list
  119        | ID

  120 obj-def: LBRACE obj-att-list RBRACE

  121 obj-att-list: COMMA obj-att-list
  122             | obj-att COMMA obj-att-list
  123             | obj-att
  124             | %empty

  125 obj-att: ID COLON var-val

  126 var-type: NUMBER
  127         | STRING
  128         | UNKNOWN
  129         | BOOLTYPE
  130         | ANY
  131         | VOID_RW
  132         | NEVER

  133 expr: idx-safe-expr
  134     | idx-unsafe-expr
  135     | LPAR expr RPAR

  136 idx-unsafe-expr: array-expr
  137                | logic-expr
  138                | var-obj

  139 idx-safe-expr: var-val
  140              | var-att
  141              | arit-expr
  142              | bitw-expr
  143              | shift-expr
  144              | unary-expr
  145              | vet-idx
  146              | ID

  147 vet-idx: ID LBRACKET idx-safe-expr RBRACKET

  148 unary-expr: INCREMENT ID
  149           | INCREMENT var-att
  150           | DECREMENT ID
  151           | DECREMENT var-att
  152           | ID INCREMENT
  153           | var-att INCREMENT
  154           | ID DECREMENT
  155           | var-att DECREMENT
  156           | LOGICAL_NOT expr
  157           | BITWISE_NOT expr

  158 arit-expr: expr PLUS expr
  159          | expr SUB expr
  160          | expr MULT expr
  161          | expr DIV expr
  162          | expr EXP expr
  163          | expr REM expr

  164 bitw-expr: expr BITWISE_AND expr
  165          | expr BITWISE_OR expr
  166          | expr BITWISE_XOR expr

  167 shift-expr: expr LSHIFT expr
  168           | expr RSHIFT expr
  169           | expr RSHIFT_UNSIGNED expr

  170 var-att: ID DOT var-att
  171        | var-att DOT ID
  172        | ID DOT var-met
  173        | var-met DOT ID
  174        | var-met DOT var-att
  175        | var-att DOT var-met
  176        | ID DOT ID

  177 var-met: ID LPAR args-list RPAR

  178 args-list: COMMA args-list
  179          | expr COMMA args-list
  180          | assign-expr COMMA args-list
  181          | expr
  182          | assign-expr
  183          | %empty

  184 var-obj: ID LPAR args-list RPAR
  185        | ID LT var-type GT LPAR args-list RPAR
  186        | NEW ID LPAR args-list RPAR
  187        | NEW ID LT var-type GT LPAR args-list RPAR

  188 var-val: INT_VAL
  189        | REAL_VAL
  190        | STR_VAL
  191        | TRUE_RW
  192        | FALSE_RW
  193        | SUB INT_VAL
  194        | SUB REAL_VAL
  195        | SUB STR_VAL
  196        | SUB TRUE_RW
  197        | SUB FALSE_RW
  198        | NULL_RW
  199        | UNDEFINED

  200 array-expr: LBRACKET elmts-list RBRACKET

  201 elmts-list: COMMA elmts-list
  202           | var-val COMMA elmts-list
  203           | var-val
  204           | %empty


Terminals, with rules where they appear

$end (0) 0
error (256)
ASSIGN (258) 40 101 102 104 106 108 109 111 113 114 115 116 117
ARROW (259)
COMMA (260) 92 93 94 95 96 98 118 121 122 178 179 180 201 202
SEMI (261) 6 9 10 15 16 17 18 22 23 24 25 26 27 28 29 30 31 32 33 34
    35 36 37 38 39 79 80
COLON (262) 83 84 86 91 93 95 96 97 98 103 104 105 106 110 111 112
    113 115 116 125
TERNARY (263)
CHAIN (264)
PIPELINE (265)
DOT (266) 170 171 172 173 174 175 176
SPREAD (267)
PLUS (268) 158
INCREMENT (269) 148 149 152 153
PLUS_ASSIGN (270) 44
SUB (271) 159 193 194 195 196 197
DECREMENT (272) 150 151 154 155
SUB_ASSIGN (273) 45
MULT (274) 160
MULT_ASSIGN (275) 46
DIV (276) 161
DIV_ASSIGN (277) 47
EXP (278) 162
EXP_ASSIGN (279) 48
REM (280) 163
REM_ASSIGN (281) 49
BITWISE_NOT (282) 157
BITWISE_AND (283) 164
BITWISE_AND_ASSIGN (284) 50
BITWISE_OR (285) 165
BITWISE_OR_ASSIGN (286) 51
BITWISE_XOR (287) 166
BITWISE_XOR_ASSIGN (288) 52
LOGICAL_NOT (289) 156
LOGICAL_NULL (290) 75
LOGICAL_NULL_ASSIGN (291) 41
LOGICAL_AND (292) 76
LOGICAL_AND_ASSIGN (293) 42
LOGICAL_OR (294) 77
LOGICAL_OR_ASSIGN (295) 43
EQ (296) 66
EQ_STRICT (297) 67
INEQ (298) 68
INEQ_STRICT (299) 69
LT (300) 70 71 185 187
LT_EQ (301) 72
GT (302) 73 185 187
GT_EQ (303) 74
LSHIFT (304) 167
LSHIFT_ASSIGN (305) 53
RSHIFT (306) 168
RSHIFT_ASSIGN (307) 54
RSHIFT_UNSIGNED (308) 169
RSHIFT_UNSIGNED_ASSIGN (309) 55
LPAR (310) 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 56
    57 58 59 60 61 62 63 64 65 85 86 90 91 135 177 184 185 186 187
RPAR (311) 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 56
    57 58 59 60 61 62 63 64 65 85 86 90 91 135 177 184 185 186 187
LBRACE (312) 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39
    56 57 58 59 60 61 62 63 64 65 78 85 86 90 91 120
RBRACE (313) 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39
    56 57 58 59 60 61 62 63 64 65 78 85 86 90 91 120
LBRACKET (314) 105 106 112 113 116 147 200
RBRACKET (315) 105 106 112 113 116 147 200
INT_VAL (316) 188 193
REAL_VAL (317) 189 194
STR_VAL (318) 190 195
ID (319) 20 71 78 83 84 85 86 90 91 92 93 94 95 96 97 98 103 104 105
    106 110 111 112 113 115 116 118 119 125 146 147 148 150 152 154
    170 171 172 173 176 177 184 185 186 187
BREAK (320) 17
CASE (321)
CATCH (322)
CLASS (323) 78
CONST_RW (324) 114 115 116 117
CONTINUE (325) 18
DEBUGGER (326)
DEFAULT (327)
DELETE (328)
DO (329) 56 57
ELSE (330) 61 62 64 65
ENUM (331)
EXPORT (332)
EXTENDS (333)
FALSE_RW (334) 192 197
FINALLY (335)
FOR (336) 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39
FUNCTION (337) 90 91
IF (338) 60 61 62 63 64 65
IMPLEMENTS (339)
IMPORT (340)
IN (341)
INSTANCEOF (342)
INTERFACE (343)
LET (344) 100 101 102 103 104 105 106
NEW (345) 186 187
NULL_RW (346) 198
PACKAGE (347)
PRIVATE (348) 88
PROTECTED (349) 89
PUBLIC (350) 87
RETURN (351) 15 16
SUPER (352)
SWITCH (353)
THIS (354)
THROW (355)
TRUE_RW (356) 191 196
TRY (357)
TYPEOF (358)
VAR (359) 107 108 109 110 111 112 113
VOID_RW (360) 131
WHILE (361) 56 57 58 59
WITH (362)
AWAIT (363)
YIELD (364)
STATIC (365)
AS (366)
ASYNC (367)
FROM (368)
GET (369)
OF (370)
SET (371)
TARGET (372)
ANY (373) 130
BOOLTYPE (374) 129
CONSTRUCTOR (375)
DECLARE (376)
MODULE (377)
REQUIRE (378)
NEVER (379) 132
NUMBER (380) 126
STRING (381) 127
SYMBOL (382)
TYPE (383)
UNDEFINED (384) 199
UNKNOWN (385) 128
E_ID (386)


Nonterminals, with rules where they appear

$accept (132)
    on left: 0
begin (133)
    on left: 1, on right: 0
line (134)
    on left: 2 3, on right: 1 22 23 24 25 26 27 28 29 30 31 32 33 34
    35 36 37 38 39 56 57 58 59 60 61 62 63 64 65 85 86 90 91
stmt-list (135)
    on left: 4 5, on right: 2 4
stmt (136)
    on left: 6 7 8 9 10 11 12 13 14 15 16 17 18, on right: 4 5 62 65
assign-expr (137)
    on left: 19 20 21, on right: 10 22 23 24 25 26 27 29 32 35 38 57
    59 63 64 65 180 182
for-stmt (138)
    on left: 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39,
    on right: 14
assignment (139)
    on left: 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55, on right:
    19 20 21
do-while-stmt (140)
    on left: 56 57, on right: 13
while-stmt (141)
    on left: 58 59, on right: 12
if-stmt (142)
    on left: 60 61 62 63 64 65, on right: 11
logic-expr (143)
    on left: 66 67 68 69 70 71 72 73 74 75 76 77, on right: 137
class-def (144)
    on left: 78, on right: 8
class-att-list (145)
    on left: 79 80 81 82, on right: 78 79 80
class-att (146)
    on left: 83 84 85 86, on right: 80 81
access-modif (147)
    on left: 87 88 89, on right: 84
func-def (148)
    on left: 90 91, on right: 7
params (149)
    on left: 92 93 94 95 96 97 98 99, on right: 85 86 90 91
var-declr (150)
    on left: 100 101 102 103 104 105 106 107 108 109 110 111 112 113
    114 115 116 117, on right: 6 28 29 30 31 32 33
id-list (151)
    on left: 118 119, on right: 100 101 102 107 108 109 114 117 118
obj-def (152)
    on left: 120, on right: 102 109 117
obj-att-list (153)
    on left: 121 122 123 124, on right: 120 121 122
obj-att (154)
    on left: 125, on right: 122 123
var-type (155)
    on left: 126 127 128 129 130 131 132, on right: 83 84 86 91 93
    95 96 97 98 103 104 105 106 110 111 112 113 115 116 185 187
expr (156)
    on left: 133 134 135, on right: 9 16 19 20 21 22 23 24 25 28 29
    30 31 34 35 36 37 56 58 60 61 62 66 67 68 69 70 71 72 73 74 75
    76 77 101 104 106 108 111 113 114 115 116 135 156 157 158 159 160
    161 162 163 164 165 166 167 168 169 179 181
idx-unsafe-expr (157)
    on left: 136 137 138, on right: 134
idx-safe-expr (158)
    on left: 139 140 141 142 143 144 145 146, on right: 133 147
vet-idx (159)
    on left: 147, on right: 21 145
unary-expr (160)
    on left: 148 149 150 151 152 153 154 155 156 157, on right: 144
arit-expr (161)
    on left: 158 159 160 161 162 163, on right: 141
bitw-expr (162)
    on left: 164 165 166, on right: 142
shift-expr (163)
    on left: 167 168 169, on right: 143
var-att (164)
    on left: 170 171 172 173 174 175 176, on right: 19 140 149 151
    153 155 170 171 174 175
var-met (165)
    on left: 177, on right: 172 173 174 175
args-list (166)
    on left: 178 179 180 181 182 183, on right: 177 178 179 180 184
    185 186 187
var-obj (167)
    on left: 184 185 186 187, on right: 138
var-val (168)
    on left: 188 189 190 191 192 193 194 195 196 197 198 199, on right:
    125 139 202 203
array-expr (169)
    on left: 200, on right: 136
elmts-list (170)
    on left: 201 202 203 204, on right: 200 201 202


State 0

    0 $accept: . begin $end

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 3 (line)

    begin            go to state 29
    line             go to state 30
    stmt-list        go to state 31
    stmt             go to state 32
    assign-expr      go to state 33
    for-stmt         go to state 34
    do-while-stmt    go to state 35
    while-stmt       go to state 36
    if-stmt          go to state 37
    logic-expr       go to state 38
    class-def        go to state 39
    func-def         go to state 40
    var-declr        go to state 41
    expr             go to state 42
    idx-unsafe-expr  go to state 43
    idx-safe-expr    go to state 44
    vet-idx          go to state 45
    unary-expr       go to state 46
    arit-expr        go to state 47
    bitw-expr        go to state 48
    shift-expr       go to state 49
    var-att          go to state 50
    var-met          go to state 51
    var-obj          go to state 52
    var-val          go to state 53
    array-expr       go to state 54


State 1

  148 unary-expr: INCREMENT . ID
  149           | INCREMENT . var-att

    ID  shift, and go to state 55

    var-att  go to state 56
    var-met  go to state 51


State 2

  193 var-val: SUB . INT_VAL
  194        | SUB . REAL_VAL
  195        | SUB . STR_VAL
  196        | SUB . TRUE_RW
  197        | SUB . FALSE_RW

    INT_VAL   shift, and go to state 57
    REAL_VAL  shift, and go to state 58
    STR_VAL   shift, and go to state 59
    FALSE_RW  shift, and go to state 60
    TRUE_RW   shift, and go to state 61


State 3

  150 unary-expr: DECREMENT . ID
  151           | DECREMENT . var-att

    ID  shift, and go to state 62

    var-att  go to state 63
    var-met  go to state 51


State 4

  157 unary-expr: BITWISE_NOT . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 64
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 38
    expr             go to state 65
    idx-unsafe-expr  go to state 43
    idx-safe-expr    go to state 44
    vet-idx          go to state 66
    unary-expr       go to state 46
    arit-expr        go to state 47
    bitw-expr        go to state 48
    shift-expr       go to state 49
    var-att          go to state 67
    var-met          go to state 51
    var-obj          go to state 52
    var-val          go to state 53
    array-expr       go to state 54


State 5

  156 unary-expr: LOGICAL_NOT . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 64
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 38
    expr             go to state 68
    idx-unsafe-expr  go to state 43
    idx-safe-expr    go to state 44
    vet-idx          go to state 66
    unary-expr       go to state 46
    arit-expr        go to state 47
    bitw-expr        go to state 48
    shift-expr       go to state 49
    var-att          go to state 67
    var-met          go to state 51
    var-obj          go to state 52
    var-val          go to state 53
    array-expr       go to state 54


State 6

  135 expr: LPAR . expr RPAR

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 64
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 38
    expr             go to state 69
    idx-unsafe-expr  go to state 43
    idx-safe-expr    go to state 44
    vet-idx          go to state 66
    unary-expr       go to state 46
    arit-expr        go to state 47
    bitw-expr        go to state 48
    shift-expr       go to state 49
    var-att          go to state 67
    var-met          go to state 51
    var-obj          go to state 52
    var-val          go to state 53
    array-expr       go to state 54


State 7

  200 array-expr: LBRACKET . elmts-list RBRACKET

    COMMA      shift, and go to state 70
    SUB        shift, and go to state 2
    INT_VAL    shift, and go to state 8
    REAL_VAL   shift, and go to state 9
    STR_VAL    shift, and go to state 10
    FALSE_RW   shift, and go to state 17
    NULL_RW    shift, and go to state 23
    TRUE_RW    shift, and go to state 25
    UNDEFINED  shift, and go to state 28

    $default  reduce using rule 204 (elmts-list)

    var-val     go to state 71
    elmts-list  go to state 72


State 8

  188 var-val: INT_VAL .

    $default  reduce using rule 188 (var-val)


State 9

  189 var-val: REAL_VAL .

    $default  reduce using rule 189 (var-val)


State 10

  190 var-val: STR_VAL .

    $default  reduce using rule 190 (var-val)


State 11

   20 assign-expr: ID . assignment expr
   71 logic-expr: ID . LT expr
  146 idx-safe-expr: ID .
  147 vet-idx: ID . LBRACKET idx-safe-expr RBRACKET
  152 unary-expr: ID . INCREMENT
  154           | ID . DECREMENT
  170 var-att: ID . DOT var-att
  172        | ID . DOT var-met
  176        | ID . DOT ID
  177 var-met: ID . LPAR args-list RPAR
  184 var-obj: ID . LPAR args-list RPAR
  185        | ID . LT var-type GT LPAR args-list RPAR

    ASSIGN                  shift, and go to state 73
    DOT                     shift, and go to state 74
    INCREMENT               shift, and go to state 75
    PLUS_ASSIGN             shift, and go to state 76
    DECREMENT               shift, and go to state 77
    SUB_ASSIGN              shift, and go to state 78
    MULT_ASSIGN             shift, and go to state 79
    DIV_ASSIGN              shift, and go to state 80
    EXP_ASSIGN              shift, and go to state 81
    REM_ASSIGN              shift, and go to state 82
    BITWISE_AND_ASSIGN      shift, and go to state 83
    BITWISE_OR_ASSIGN       shift, and go to state 84
    BITWISE_XOR_ASSIGN      shift, and go to state 85
    LOGICAL_NULL_ASSIGN     shift, and go to state 86
    LOGICAL_AND_ASSIGN      shift, and go to state 87
    LOGICAL_OR_ASSIGN       shift, and go to state 88
    LT                      shift, and go to state 89
    LSHIFT_ASSIGN           shift, and go to state 90
    RSHIFT_ASSIGN           shift, and go to state 91
    RSHIFT_UNSIGNED_ASSIGN  shift, and go to state 92
    LPAR                    shift, and go to state 93
    LBRACKET                shift, and go to state 94

    $default  reduce using rule 146 (idx-safe-expr)

    assignment  go to state 95


State 12

   17 stmt: BREAK . SEMI

    SEMI  shift, and go to state 96


State 13

   78 class-def: CLASS . ID LBRACE class-att-list RBRACE

    ID  shift, and go to state 97


State 14

  114 var-declr: CONST_RW . id-list ASSIGN expr
  115          | CONST_RW . ID COLON var-type ASSIGN expr
  116          | CONST_RW . ID COLON var-type LBRACKET RBRACKET ASSIGN expr
  117          | CONST_RW . id-list ASSIGN obj-def

    ID  shift, and go to state 98

    id-list  go to state 99


State 15

   18 stmt: CONTINUE . SEMI

    SEMI  shift, and go to state 100


State 16

   56 do-while-stmt: DO . LBRACE line RBRACE WHILE LPAR expr RPAR
   57              | DO . LBRACE line RBRACE WHILE LPAR assign-expr RPAR

    LBRACE  shift, and go to state 101


State 17

  192 var-val: FALSE_RW .

    $default  reduce using rule 192 (var-val)


State 18

   22 for-stmt: FOR . LPAR assign-expr SEMI expr SEMI expr RPAR LBRACE line RBRACE
   23         | FOR . LPAR assign-expr SEMI expr SEMI assign-expr RPAR LBRACE line RBRACE
   24         | FOR . LPAR assign-expr SEMI expr SEMI RPAR LBRACE line RBRACE
   25         | FOR . LPAR assign-expr SEMI SEMI expr RPAR LBRACE line RBRACE
   26         | FOR . LPAR assign-expr SEMI SEMI assign-expr RPAR LBRACE line RBRACE
   27         | FOR . LPAR assign-expr SEMI SEMI RPAR LBRACE line RBRACE
   28         | FOR . LPAR var-declr SEMI expr SEMI expr RPAR LBRACE line RBRACE
   29         | FOR . LPAR var-declr SEMI expr SEMI assign-expr RPAR LBRACE line RBRACE
   30         | FOR . LPAR var-declr SEMI expr SEMI RPAR LBRACE line RBRACE
   31         | FOR . LPAR var-declr SEMI SEMI expr RPAR LBRACE line RBRACE
   32         | FOR . LPAR var-declr SEMI SEMI assign-expr RPAR LBRACE line RBRACE
   33         | FOR . LPAR var-declr SEMI SEMI RPAR LBRACE line RBRACE
   34         | FOR . LPAR SEMI expr SEMI expr RPAR LBRACE line RBRACE
   35         | FOR . LPAR SEMI expr SEMI assign-expr RPAR LBRACE line RBRACE
   36         | FOR . LPAR SEMI expr SEMI RPAR LBRACE line RBRACE
   37         | FOR . LPAR SEMI SEMI expr RPAR LBRACE line RBRACE
   38         | FOR . LPAR SEMI SEMI assign-expr RPAR LBRACE line RBRACE
   39         | FOR . LPAR SEMI SEMI RPAR LBRACE line RBRACE

    LPAR  shift, and go to state 102


State 19

   90 func-def: FUNCTION . ID LPAR params RPAR LBRACE line RBRACE
   91         | FUNCTION . ID LPAR params RPAR COLON var-type LBRACE line RBRACE

    ID  shift, and go to state 103


State 20

   60 if-stmt: IF . LPAR expr RPAR LBRACE line RBRACE
   61        | IF . LPAR expr RPAR LBRACE line RBRACE ELSE LBRACE line RBRACE
   62        | IF . LPAR expr RPAR LBRACE line RBRACE ELSE stmt
   63        | IF . LPAR assign-expr RPAR LBRACE line RBRACE
   64        | IF . LPAR assign-expr RPAR LBRACE line RBRACE ELSE LBRACE line RBRACE
   65        | IF . LPAR assign-expr RPAR LBRACE line RBRACE ELSE stmt

    LPAR  shift, and go to state 104


State 21

  100 var-declr: LET . id-list
  101          | LET . id-list ASSIGN expr
  102          | LET . id-list ASSIGN obj-def
  103          | LET . ID COLON var-type
  104          | LET . ID COLON var-type ASSIGN expr
  105          | LET . ID COLON var-type LBRACKET RBRACKET
  106          | LET . ID COLON var-type LBRACKET RBRACKET ASSIGN expr

    ID  shift, and go to state 105

    id-list  go to state 106


State 22

  186 var-obj: NEW . ID LPAR args-list RPAR
  187        | NEW . ID LT var-type GT LPAR args-list RPAR

    ID  shift, and go to state 107


State 23

  198 var-val: NULL_RW .

    $default  reduce using rule 198 (var-val)


State 24

   15 stmt: RETURN . SEMI
   16     | RETURN . expr SEMI

    SEMI         shift, and go to state 108
    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 64
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 38
    expr             go to state 109
    idx-unsafe-expr  go to state 43
    idx-safe-expr    go to state 44
    vet-idx          go to state 66
    unary-expr       go to state 46
    arit-expr        go to state 47
    bitw-expr        go to state 48
    shift-expr       go to state 49
    var-att          go to state 67
    var-met          go to state 51
    var-obj          go to state 52
    var-val          go to state 53
    array-expr       go to state 54


State 25

  191 var-val: TRUE_RW .

    $default  reduce using rule 191 (var-val)


State 26

  107 var-declr: VAR . id-list
  108          | VAR . id-list ASSIGN expr
  109          | VAR . id-list ASSIGN obj-def
  110          | VAR . ID COLON var-type
  111          | VAR . ID COLON var-type ASSIGN expr
  112          | VAR . ID COLON var-type LBRACKET RBRACKET
  113          | VAR . ID COLON var-type LBRACKET RBRACKET ASSIGN expr

    ID  shift, and go to state 110

    id-list  go to state 111


State 27

   58 while-stmt: WHILE . LPAR expr RPAR LBRACE line RBRACE
   59           | WHILE . LPAR assign-expr RPAR LBRACE line RBRACE

    LPAR  shift, and go to state 112


State 28

  199 var-val: UNDEFINED .

    $default  reduce using rule 199 (var-val)


State 29

    0 $accept: begin . $end

    $end  shift, and go to state 113


State 30

    1 begin: line .

    $default  reduce using rule 1 (begin)


State 31

    2 line: stmt-list .
    4 stmt-list: stmt-list . stmt

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 2 (line)

    stmt             go to state 114
    assign-expr      go to state 33
    for-stmt         go to state 34
    do-while-stmt    go to state 35
    while-stmt       go to state 36
    if-stmt          go to state 37
    logic-expr       go to state 38
    class-def        go to state 39
    func-def         go to state 40
    var-declr        go to state 41
    expr             go to state 42
    idx-unsafe-expr  go to state 43
    idx-safe-expr    go to state 44
    vet-idx          go to state 45
    unary-expr       go to state 46
    arit-expr        go to state 47
    bitw-expr        go to state 48
    shift-expr       go to state 49
    var-att          go to state 50
    var-met          go to state 51
    var-obj          go to state 52
    var-val          go to state 53
    array-expr       go to state 54


State 32

    5 stmt-list: stmt .

    $default  reduce using rule 5 (stmt-list)


State 33

   10 stmt: assign-expr . SEMI

    SEMI  shift, and go to state 115


State 34

   14 stmt: for-stmt .

    $default  reduce using rule 14 (stmt)


State 35

   13 stmt: do-while-stmt .

    $default  reduce using rule 13 (stmt)


State 36

   12 stmt: while-stmt .

    $default  reduce using rule 12 (stmt)


State 37

   11 stmt: if-stmt .

    $default  reduce using rule 11 (stmt)


State 38

  137 idx-unsafe-expr: logic-expr .

    $default  reduce using rule 137 (idx-unsafe-expr)


State 39

    8 stmt: class-def .

    $default  reduce using rule 8 (stmt)


State 40

    7 stmt: func-def .

    $default  reduce using rule 7 (stmt)


State 41

    6 stmt: var-declr . SEMI

    SEMI  shift, and go to state 116


State 42

    9 stmt: expr . SEMI
   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  158 arit-expr: expr . PLUS expr
  159          | expr . SUB expr
  160          | expr . MULT expr
  161          | expr . DIV expr
  162          | expr . EXP expr
  163          | expr . REM expr
  164 bitw-expr: expr . BITWISE_AND expr
  165          | expr . BITWISE_OR expr
  166          | expr . BITWISE_XOR expr
  167 shift-expr: expr . LSHIFT expr
  168           | expr . RSHIFT expr
  169           | expr . RSHIFT_UNSIGNED expr

    SEMI             shift, and go to state 117
    PLUS             shift, and go to state 118
    SUB              shift, and go to state 119
    MULT             shift, and go to state 120
    DIV              shift, and go to state 121
    EXP              shift, and go to state 122
    REM              shift, and go to state 123
    BITWISE_AND      shift, and go to state 124
    BITWISE_OR       shift, and go to state 125
    BITWISE_XOR      shift, and go to state 126
    LOGICAL_NULL     shift, and go to state 127
    LOGICAL_AND      shift, and go to state 128
    LOGICAL_OR       shift, and go to state 129
    EQ               shift, and go to state 130
    EQ_STRICT        shift, and go to state 131
    INEQ             shift, and go to state 132
    INEQ_STRICT      shift, and go to state 133
    LT               shift, and go to state 134
    LT_EQ            shift, and go to state 135
    GT               shift, and go to state 136
    GT_EQ            shift, and go to state 137
    LSHIFT           shift, and go to state 138
    RSHIFT           shift, and go to state 139
    RSHIFT_UNSIGNED  shift, and go to state 140


State 43

  134 expr: idx-unsafe-expr .

    $default  reduce using rule 134 (expr)


State 44

  133 expr: idx-safe-expr .

    $default  reduce using rule 133 (expr)


State 45

   21 assign-expr: vet-idx . assignment expr
  145 idx-safe-expr: vet-idx .

    ASSIGN                  shift, and go to state 73
    PLUS_ASSIGN             shift, and go to state 76
    SUB_ASSIGN              shift, and go to state 78
    MULT_ASSIGN             shift, and go to state 79
    DIV_ASSIGN              shift, and go to state 80
    EXP_ASSIGN              shift, and go to state 81
    REM_ASSIGN              shift, and go to state 82
    BITWISE_AND_ASSIGN      shift, and go to state 83
    BITWISE_OR_ASSIGN       shift, and go to state 84
    BITWISE_XOR_ASSIGN      shift, and go to state 85
    LOGICAL_NULL_ASSIGN     shift, and go to state 86
    LOGICAL_AND_ASSIGN      shift, and go to state 87
    LOGICAL_OR_ASSIGN       shift, and go to state 88
    LSHIFT_ASSIGN           shift, and go to state 90
    RSHIFT_ASSIGN           shift, and go to state 91
    RSHIFT_UNSIGNED_ASSIGN  shift, and go to state 92

    $default  reduce using rule 145 (idx-safe-expr)

    assignment  go to state 141


State 46

  144 idx-safe-expr: unary-expr .

    $default  reduce using rule 144 (idx-safe-expr)


State 47

  141 idx-safe-expr: arit-expr .

    $default  reduce using rule 141 (idx-safe-expr)


State 48

  142 idx-safe-expr: bitw-expr .

    $default  reduce using rule 142 (idx-safe-expr)


State 49

  143 idx-safe-expr: shift-expr .

    $default  reduce using rule 143 (idx-safe-expr)


State 50

   19 assign-expr: var-att . assignment expr
  140 idx-safe-expr: var-att .
  153 unary-expr: var-att . INCREMENT
  155           | var-att . DECREMENT
  171 var-att: var-att . DOT ID
  175        | var-att . DOT var-met

    ASSIGN                  shift, and go to state 73
    DOT                     shift, and go to state 142
    INCREMENT               shift, and go to state 143
    PLUS_ASSIGN             shift, and go to state 76
    DECREMENT               shift, and go to state 144
    SUB_ASSIGN              shift, and go to state 78
    MULT_ASSIGN             shift, and go to state 79
    DIV_ASSIGN              shift, and go to state 80
    EXP_ASSIGN              shift, and go to state 81
    REM_ASSIGN              shift, and go to state 82
    BITWISE_AND_ASSIGN      shift, and go to state 83
    BITWISE_OR_ASSIGN       shift, and go to state 84
    BITWISE_XOR_ASSIGN      shift, and go to state 85
    LOGICAL_NULL_ASSIGN     shift, and go to state 86
    LOGICAL_AND_ASSIGN      shift, and go to state 87
    LOGICAL_OR_ASSIGN       shift, and go to state 88
    LSHIFT_ASSIGN           shift, and go to state 90
    RSHIFT_ASSIGN           shift, and go to state 91
    RSHIFT_UNSIGNED_ASSIGN  shift, and go to state 92

    $default  reduce using rule 140 (idx-safe-expr)

    assignment  go to state 145


State 51

  173 var-att: var-met . DOT ID
  174        | var-met . DOT var-att

    DOT  shift, and go to state 146


State 52

  138 idx-unsafe-expr: var-obj .

    $default  reduce using rule 138 (idx-unsafe-expr)


State 53

  139 idx-safe-expr: var-val .

    $default  reduce using rule 139 (idx-safe-expr)


State 54

  136 idx-unsafe-expr: array-expr .

    $default  reduce using rule 136 (idx-unsafe-expr)


State 55

  148 unary-expr: INCREMENT ID .
  170 var-att: ID . DOT var-att
  172        | ID . DOT var-met
  176        | ID . DOT ID
  177 var-met: ID . LPAR args-list RPAR

    DOT   shift, and go to state 74
    LPAR  shift, and go to state 147

    $default  reduce using rule 148 (unary-expr)


State 56

  149 unary-expr: INCREMENT var-att .
  171 var-att: var-att . DOT ID
  175        | var-att . DOT var-met

    DOT  shift, and go to state 142

    $default  reduce using rule 149 (unary-expr)


State 57

  193 var-val: SUB INT_VAL .

    $default  reduce using rule 193 (var-val)


State 58

  194 var-val: SUB REAL_VAL .

    $default  reduce using rule 194 (var-val)


State 59

  195 var-val: SUB STR_VAL .

    $default  reduce using rule 195 (var-val)


State 60

  197 var-val: SUB FALSE_RW .

    $default  reduce using rule 197 (var-val)


State 61

  196 var-val: SUB TRUE_RW .

    $default  reduce using rule 196 (var-val)


State 62

  150 unary-expr: DECREMENT ID .
  170 var-att: ID . DOT var-att
  172        | ID . DOT var-met
  176        | ID . DOT ID
  177 var-met: ID . LPAR args-list RPAR

    DOT   shift, and go to state 74
    LPAR  shift, and go to state 147

    $default  reduce using rule 150 (unary-expr)


State 63

  151 unary-expr: DECREMENT var-att .
  171 var-att: var-att . DOT ID
  175        | var-att . DOT var-met

    DOT  shift, and go to state 142

    $default  reduce using rule 151 (unary-expr)


State 64

   71 logic-expr: ID . LT expr
  146 idx-safe-expr: ID .
  147 vet-idx: ID . LBRACKET idx-safe-expr RBRACKET
  152 unary-expr: ID . INCREMENT
  154           | ID . DECREMENT
  170 var-att: ID . DOT var-att
  172        | ID . DOT var-met
  176        | ID . DOT ID
  177 var-met: ID . LPAR args-list RPAR
  184 var-obj: ID . LPAR args-list RPAR
  185        | ID . LT var-type GT LPAR args-list RPAR

    DOT        shift, and go to state 74
    INCREMENT  shift, and go to state 75
    DECREMENT  shift, and go to state 77
    LT         shift, and go to state 89
    LPAR       shift, and go to state 93
    LBRACKET   shift, and go to state 94

    $default  reduce using rule 146 (idx-safe-expr)


State 65

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  157 unary-expr: BITWISE_NOT expr .
  158 arit-expr: expr . PLUS expr
  159          | expr . SUB expr
  160          | expr . MULT expr
  161          | expr . DIV expr
  162          | expr . EXP expr
  163          | expr . REM expr
  164 bitw-expr: expr . BITWISE_AND expr
  165          | expr . BITWISE_OR expr
  166          | expr . BITWISE_XOR expr
  167 shift-expr: expr . LSHIFT expr
  168           | expr . RSHIFT expr
  169           | expr . RSHIFT_UNSIGNED expr

    $default  reduce using rule 157 (unary-expr)


State 66

  145 idx-safe-expr: vet-idx .

    $default  reduce using rule 145 (idx-safe-expr)


State 67

  140 idx-safe-expr: var-att .
  153 unary-expr: var-att . INCREMENT
  155           | var-att . DECREMENT
  171 var-att: var-att . DOT ID
  175        | var-att . DOT var-met

    DOT        shift, and go to state 142
    INCREMENT  shift, and go to state 143
    DECREMENT  shift, and go to state 144

    $default  reduce using rule 140 (idx-safe-expr)


State 68

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  156 unary-expr: LOGICAL_NOT expr .
  158 arit-expr: expr . PLUS expr
  159          | expr . SUB expr
  160          | expr . MULT expr
  161          | expr . DIV expr
  162          | expr . EXP expr
  163          | expr . REM expr
  164 bitw-expr: expr . BITWISE_AND expr
  165          | expr . BITWISE_OR expr
  166          | expr . BITWISE_XOR expr
  167 shift-expr: expr . LSHIFT expr
  168           | expr . RSHIFT expr
  169           | expr . RSHIFT_UNSIGNED expr

    $default  reduce using rule 156 (unary-expr)


State 69

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  135 expr: LPAR expr . RPAR
  158 arit-expr: expr . PLUS expr
  159          | expr . SUB expr
  160          | expr . MULT expr
  161          | expr . DIV expr
  162          | expr . EXP expr
  163          | expr . REM expr
  164 bitw-expr: expr . BITWISE_AND expr
  165          | expr . BITWISE_OR expr
  166          | expr . BITWISE_XOR expr
  167 shift-expr: expr . LSHIFT expr
  168           | expr . RSHIFT expr
  169           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 118
    SUB              shift, and go to state 119
    MULT             shift, and go to state 120
    DIV              shift, and go to state 121
    EXP              shift, and go to state 122
    REM              shift, and go to state 123
    BITWISE_AND      shift, and go to state 124
    BITWISE_OR       shift, and go to state 125
    BITWISE_XOR      shift, and go to state 126
    LOGICAL_NULL     shift, and go to state 127
    LOGICAL_AND      shift, and go to state 128
    LOGICAL_OR       shift, and go to state 129
    EQ               shift, and go to state 130
    EQ_STRICT        shift, and go to state 131
    INEQ             shift, and go to state 132
    INEQ_STRICT      shift, and go to state 133
    LT               shift, and go to state 134
    LT_EQ            shift, and go to state 135
    GT               shift, and go to state 136
    GT_EQ            shift, and go to state 137
    LSHIFT           shift, and go to state 138
    RSHIFT           shift, and go to state 139
    RSHIFT_UNSIGNED  shift, and go to state 140
    RPAR             shift, and go to state 148


State 70

  201 elmts-list: COMMA . elmts-list

    COMMA      shift, and go to state 70
    SUB        shift, and go to state 2
    INT_VAL    shift, and go to state 8
    REAL_VAL   shift, and go to state 9
    STR_VAL    shift, and go to state 10
    FALSE_RW   shift, and go to state 17
    NULL_RW    shift, and go to state 23
    TRUE_RW    shift, and go to state 25
    UNDEFINED  shift, and go to state 28

    $default  reduce using rule 204 (elmts-list)

    var-val     go to state 71
    elmts-list  go to state 149


State 71

  202 elmts-list: var-val . COMMA elmts-list
  203           | var-val .

    COMMA  shift, and go to state 150

    $default  reduce using rule 203 (elmts-list)


State 72

  200 array-expr: LBRACKET elmts-list . RBRACKET

    RBRACKET  shift, and go to state 151


State 73

   40 assignment: ASSIGN .

    $default  reduce using rule 40 (assignment)


State 74

  170 var-att: ID DOT . var-att
  172        | ID DOT . var-met
  176        | ID DOT . ID

    ID  shift, and go to state 152

    var-att  go to state 153
    var-met  go to state 154


State 75

  152 unary-expr: ID INCREMENT .

    $default  reduce using rule 152 (unary-expr)


State 76

   44 assignment: PLUS_ASSIGN .

    $default  reduce using rule 44 (assignment)


State 77

  154 unary-expr: ID DECREMENT .

    $default  reduce using rule 154 (unary-expr)


State 78

   45 assignment: SUB_ASSIGN .

    $default  reduce using rule 45 (assignment)


State 79

   46 assignment: MULT_ASSIGN .

    $default  reduce using rule 46 (assignment)


State 80

   47 assignment: DIV_ASSIGN .

    $default  reduce using rule 47 (assignment)


State 81

   48 assignment: EXP_ASSIGN .

    $default  reduce using rule 48 (assignment)


State 82

   49 assignment: REM_ASSIGN .

    $default  reduce using rule 49 (assignment)


State 83

   50 assignment: BITWISE_AND_ASSIGN .

    $default  reduce using rule 50 (assignment)


State 84

   51 assignment: BITWISE_OR_ASSIGN .

    $default  reduce using rule 51 (assignment)


State 85

   52 assignment: BITWISE_XOR_ASSIGN .

    $default  reduce using rule 52 (assignment)


State 86

   41 assignment: LOGICAL_NULL_ASSIGN .

    $default  reduce using rule 41 (assignment)


State 87

   42 assignment: LOGICAL_AND_ASSIGN .

    $default  reduce using rule 42 (assignment)


State 88

   43 assignment: LOGICAL_OR_ASSIGN .

    $default  reduce using rule 43 (assignment)


State 89

   71 logic-expr: ID LT . expr
  185 var-obj: ID LT . var-type GT LPAR args-list RPAR

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 64
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    VOID_RW      shift, and go to state 155
    ANY          shift, and go to state 156
    BOOLTYPE     shift, and go to state 157
    NEVER        shift, and go to state 158
    NUMBER       shift, and go to state 159
    STRING       shift, and go to state 160
    UNDEFINED    shift, and go to state 28
    UNKNOWN      shift, and go to state 161

    logic-expr       go to state 38
    var-type         go to state 162
    expr             go to state 163
    idx-unsafe-expr  go to state 43
    idx-safe-expr    go to state 44
    vet-idx          go to state 66
    unary-expr       go to state 46
    arit-expr        go to state 47
    bitw-expr        go to state 48
    shift-expr       go to state 49
    var-att          go to state 67
    var-met          go to state 51
    var-obj          go to state 52
    var-val          go to state 53
    array-expr       go to state 54


State 90

   53 assignment: LSHIFT_ASSIGN .

    $default  reduce using rule 53 (assignment)


State 91

   54 assignment: RSHIFT_ASSIGN .

    $default  reduce using rule 54 (assignment)


State 92

   55 assignment: RSHIFT_UNSIGNED_ASSIGN .

    $default  reduce using rule 55 (assignment)


State 93

  177 var-met: ID LPAR . args-list RPAR
  184 var-obj: ID LPAR . args-list RPAR

    COMMA        shift, and go to state 164
    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 183 (args-list)

    assign-expr      go to state 165
    logic-expr       go to state 38
    expr             go to state 166
    idx-unsafe-expr  go to state 43
    idx-safe-expr    go to state 44
    vet-idx          go to state 45
    unary-expr       go to state 46
    arit-expr        go to state 47
    bitw-expr        go to state 48
    shift-expr       go to state 49
    var-att          go to state 50
    var-met          go to state 51
    args-list        go to state 167
    var-obj          go to state 52
    var-val          go to state 53
    array-expr       go to state 54


State 94

  147 vet-idx: ID LBRACKET . idx-safe-expr RBRACKET

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 64
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 38
    expr             go to state 168
    idx-unsafe-expr  go to state 43
    idx-safe-expr    go to state 169
    vet-idx          go to state 66
    unary-expr       go to state 46
    arit-expr        go to state 47
    bitw-expr        go to state 48
    shift-expr       go to state 49
    var-att          go to state 67
    var-met          go to state 51
    var-obj          go to state 52
    var-val          go to state 53
    array-expr       go to state 54


State 95

   20 assign-expr: ID assignment . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 64
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 38
    expr             go to state 170
    idx-unsafe-expr  go to state 43
    idx-safe-expr    go to state 44
    vet-idx          go to state 66
    unary-expr       go to state 46
    arit-expr        go to state 47
    bitw-expr        go to state 48
    shift-expr       go to state 49
    var-att          go to state 67
    var-met          go to state 51
    var-obj          go to state 52
    var-val          go to state 53
    array-expr       go to state 54


State 96

   17 stmt: BREAK SEMI .

    $default  reduce using rule 17 (stmt)


State 97

   78 class-def: CLASS ID . LBRACE class-att-list RBRACE

    LBRACE  shift, and go to state 171


State 98

  115 var-declr: CONST_RW ID . COLON var-type ASSIGN expr
  116          | CONST_RW ID . COLON var-type LBRACKET RBRACKET ASSIGN expr
  118 id-list: ID . COMMA id-list
  119        | ID .

    COMMA  shift, and go to state 172
    COLON  shift, and go to state 173

    $default  reduce using rule 119 (id-list)


State 99

  114 var-declr: CONST_RW id-list . ASSIGN expr
  117          | CONST_RW id-list . ASSIGN obj-def

    ASSIGN  shift, and go to state 174


State 100

   18 stmt: CONTINUE SEMI .

    $default  reduce using rule 18 (stmt)


State 101

   56 do-while-stmt: DO LBRACE . line RBRACE WHILE LPAR expr RPAR
   57              | DO LBRACE . line RBRACE WHILE LPAR assign-expr RPAR

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 3 (line)

    line             go to state 175
    stmt-list        go to state 31
    stmt             go to state 32
    assign-expr      go to state 33
    for-stmt         go to state 34
    do-while-stmt    go to state 35
    while-stmt       go to state 36
    if-stmt          go to state 37
    logic-expr       go to state 38
    class-def        go to state 39
    func-def         go to state 40
    var-declr        go to state 41
    expr             go to state 42
    idx-unsafe-expr  go to state 43
    idx-safe-expr    go to state 44
    vet-idx          go to state 45
    unary-expr       go to state 46
    arit-expr        go to state 47
    bitw-expr        go to state 48
    shift-expr       go to state 49
    var-att          go to state 50
    var-met          go to state 51
    var-obj          go to state 52
    var-val          go to state 53
    array-expr       go to state 54


State 102

   22 for-stmt: FOR LPAR . assign-expr SEMI expr SEMI expr RPAR LBRACE line RBRACE
   23         | FOR LPAR . assign-expr SEMI expr SEMI assign-expr RPAR LBRACE line RBRACE
   24         | FOR LPAR . assign-expr SEMI expr SEMI RPAR LBRACE line RBRACE
   25         | FOR LPAR . assign-expr SEMI SEMI expr RPAR LBRACE line RBRACE
   26         | FOR LPAR . assign-expr SEMI SEMI assign-expr RPAR LBRACE line RBRACE
   27         | FOR LPAR . assign-expr SEMI SEMI RPAR LBRACE line RBRACE
   28         | FOR LPAR . var-declr SEMI expr SEMI expr RPAR LBRACE line RBRACE
   29         | FOR LPAR . var-declr SEMI expr SEMI assign-expr RPAR LBRACE line RBRACE
   30         | FOR LPAR . var-declr SEMI expr SEMI RPAR LBRACE line RBRACE
   31         | FOR LPAR . var-declr SEMI SEMI expr RPAR LBRACE line RBRACE
   32         | FOR LPAR . var-declr SEMI SEMI assign-expr RPAR LBRACE line RBRACE
   33         | FOR LPAR . var-declr SEMI SEMI RPAR LBRACE line RBRACE
   34         | FOR LPAR . SEMI expr SEMI expr RPAR LBRACE line RBRACE
   35         | FOR LPAR . SEMI expr SEMI assign-expr RPAR LBRACE line RBRACE
   36         | FOR LPAR . SEMI expr SEMI RPAR LBRACE line RBRACE
   37         | FOR LPAR . SEMI SEMI expr RPAR LBRACE line RBRACE
   38         | FOR LPAR . SEMI SEMI assign-expr RPAR LBRACE line RBRACE
   39         | FOR LPAR . SEMI SEMI RPAR LBRACE line RBRACE

    SEMI      shift, and go to state 176
    ID        shift, and go to state 177
    CONST_RW  shift, and go to state 14
    LET       shift, and go to state 21
    VAR       shift, and go to state 26

    assign-expr  go to state 178
    var-declr    go to state 179
    vet-idx      go to state 180
    var-att      go to state 181
    var-met      go to state 51


State 103

   90 func-def: FUNCTION ID . LPAR params RPAR LBRACE line RBRACE
   91         | FUNCTION ID . LPAR params RPAR COLON var-type LBRACE line RBRACE

    LPAR  shift, and go to state 182


State 104

   60 if-stmt: IF LPAR . expr RPAR LBRACE line RBRACE
   61        | IF LPAR . expr RPAR LBRACE line RBRACE ELSE LBRACE line RBRACE
   62        | IF LPAR . expr RPAR LBRACE line RBRACE ELSE stmt
   63        | IF LPAR . assign-expr RPAR LBRACE line RBRACE
   64        | IF LPAR . assign-expr RPAR LBRACE line RBRACE ELSE LBRACE line RBRACE
   65        | IF LPAR . assign-expr RPAR LBRACE line RBRACE ELSE stmt

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    assign-expr      go to state 183
    logic-expr       go to state 38
    expr             go to state 184
    idx-unsafe-expr  go to state 43
    idx-safe-expr    go to state 44
    vet-idx          go to state 45
    unary-expr       go to state 46
    arit-expr        go to state 47
    bitw-expr        go to state 48
    shift-expr       go to state 49
    var-att          go to state 50
    var-met          go to state 51
    var-obj          go to state 52
    var-val          go to state 53
    array-expr       go to state 54


State 105

  103 var-declr: LET ID . COLON var-type
  104          | LET ID . COLON var-type ASSIGN expr
  105          | LET ID . COLON var-type LBRACKET RBRACKET
  106          | LET ID . COLON var-type LBRACKET RBRACKET ASSIGN expr
  118 id-list: ID . COMMA id-list
  119        | ID .

    COMMA  shift, and go to state 172
    COLON  shift, and go to state 185

    $default  reduce using rule 119 (id-list)


State 106

  100 var-declr: LET id-list .
  101          | LET id-list . ASSIGN expr
  102          | LET id-list . ASSIGN obj-def

    ASSIGN  shift, and go to state 186

    $default  reduce using rule 100 (var-declr)


State 107

  186 var-obj: NEW ID . LPAR args-list RPAR
  187        | NEW ID . LT var-type GT LPAR args-list RPAR

    LT    shift, and go to state 187
    LPAR  shift, and go to state 188


State 108

   15 stmt: RETURN SEMI .

    $default  reduce using rule 15 (stmt)


State 109

   16 stmt: RETURN expr . SEMI
   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  158 arit-expr: expr . PLUS expr
  159          | expr . SUB expr
  160          | expr . MULT expr
  161          | expr . DIV expr
  162          | expr . EXP expr
  163          | expr . REM expr
  164 bitw-expr: expr . BITWISE_AND expr
  165          | expr . BITWISE_OR expr
  166          | expr . BITWISE_XOR expr
  167 shift-expr: expr . LSHIFT expr
  168           | expr . RSHIFT expr
  169           | expr . RSHIFT_UNSIGNED expr

    SEMI             shift, and go to state 189
    PLUS             shift, and go to state 118
    SUB              shift, and go to state 119
    MULT             shift, and go to state 120
    DIV              shift, and go to state 121
    EXP              shift, and go to state 122
    REM              shift, and go to state 123
    BITWISE_AND      shift, and go to state 124
    BITWISE_OR       shift, and go to state 125
    BITWISE_XOR      shift, and go to state 126
    LOGICAL_NULL     shift, and go to state 127
    LOGICAL_AND      shift, and go to state 128
    LOGICAL_OR       shift, and go to state 129
    EQ               shift, and go to state 130
    EQ_STRICT        shift, and go to state 131
    INEQ             shift, and go to state 132
    INEQ_STRICT      shift, and go to state 133
    LT               shift, and go to state 134
    LT_EQ            shift, and go to state 135
    GT               shift, and go to state 136
    GT_EQ            shift, and go to state 137
    LSHIFT           shift, and go to state 138
    RSHIFT           shift, and go to state 139
    RSHIFT_UNSIGNED  shift, and go to state 140


State 110

  110 var-declr: VAR ID . COLON var-type
  111          | VAR ID . COLON var-type ASSIGN expr
  112          | VAR ID . COLON var-type LBRACKET RBRACKET
  113          | VAR ID . COLON var-type LBRACKET RBRACKET ASSIGN expr
  118 id-list: ID . COMMA id-list
  119        | ID .

    COMMA  shift, and go to state 172
    COLON  shift, and go to state 190

    $default  reduce using rule 119 (id-list)


State 111

  107 var-declr: VAR id-list .
  108          | VAR id-list . ASSIGN expr
  109          | VAR id-list . ASSIGN obj-def

    ASSIGN  shift, and go to state 191

    $default  reduce using rule 107 (var-declr)


State 112

   58 while-stmt: WHILE LPAR . expr RPAR LBRACE line RBRACE
   59           | WHILE LPAR . assign-expr RPAR LBRACE line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    assign-expr      go to state 192
    logic-expr       go to state 38
    expr             go to state 193
    idx-unsafe-expr  go to state 43
    idx-safe-expr    go to state 44
    vet-idx          go to state 45
    unary-expr       go to state 46
    arit-expr        go to state 47
    bitw-expr        go to state 48
    shift-expr       go to state 49
    var-att          go to state 50
    var-met          go to state 51
    var-obj          go to state 52
    var-val          go to state 53
    array-expr       go to state 54


State 113

    0 $accept: begin $end .

    $default  accept


State 114

    4 stmt-list: stmt-list stmt .

    $default  reduce using rule 4 (stmt-list)


State 115

   10 stmt: assign-expr SEMI .

    $default  reduce using rule 10 (stmt)


State 116

    6 stmt: var-declr SEMI .

    $default  reduce using rule 6 (stmt)


State 117

    9 stmt: expr SEMI .

    $default  reduce using rule 9 (stmt)


State 118

  158 arit-expr: expr PLUS . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 64
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 38
    expr             go to state 194
    idx-unsafe-expr  go to state 43
    idx-safe-expr    go to state 44
    vet-idx          go to state 66
    unary-expr       go to state 46
    arit-expr        go to state 47
    bitw-expr        go to state 48
    shift-expr       go to state 49
    var-att          go to state 67
    var-met          go to state 51
    var-obj          go to state 52
    var-val          go to state 53
    array-expr       go to state 54


State 119

  159 arit-expr: expr SUB . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 64
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 38
    expr             go to state 195
    idx-unsafe-expr  go to state 43
    idx-safe-expr    go to state 44
    vet-idx          go to state 66
    unary-expr       go to state 46
    arit-expr        go to state 47
    bitw-expr        go to state 48
    shift-expr       go to state 49
    var-att          go to state 67
    var-met          go to state 51
    var-obj          go to state 52
    var-val          go to state 53
    array-expr       go to state 54


State 120

  160 arit-expr: expr MULT . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 64
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 38
    expr             go to state 196
    idx-unsafe-expr  go to state 43
    idx-safe-expr    go to state 44
    vet-idx          go to state 66
    unary-expr       go to state 46
    arit-expr        go to state 47
    bitw-expr        go to state 48
    shift-expr       go to state 49
    var-att          go to state 67
    var-met          go to state 51
    var-obj          go to state 52
    var-val          go to state 53
    array-expr       go to state 54


State 121

  161 arit-expr: expr DIV . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 64
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 38
    expr             go to state 197
    idx-unsafe-expr  go to state 43
    idx-safe-expr    go to state 44
    vet-idx          go to state 66
    unary-expr       go to state 46
    arit-expr        go to state 47
    bitw-expr        go to state 48
    shift-expr       go to state 49
    var-att          go to state 67
    var-met          go to state 51
    var-obj          go to state 52
    var-val          go to state 53
    array-expr       go to state 54


State 122

  162 arit-expr: expr EXP . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 64
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 38
    expr             go to state 198
    idx-unsafe-expr  go to state 43
    idx-safe-expr    go to state 44
    vet-idx          go to state 66
    unary-expr       go to state 46
    arit-expr        go to state 47
    bitw-expr        go to state 48
    shift-expr       go to state 49
    var-att          go to state 67
    var-met          go to state 51
    var-obj          go to state 52
    var-val          go to state 53
    array-expr       go to state 54


State 123

  163 arit-expr: expr REM . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 64
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 38
    expr             go to state 199
    idx-unsafe-expr  go to state 43
    idx-safe-expr    go to state 44
    vet-idx          go to state 66
    unary-expr       go to state 46
    arit-expr        go to state 47
    bitw-expr        go to state 48
    shift-expr       go to state 49
    var-att          go to state 67
    var-met          go to state 51
    var-obj          go to state 52
    var-val          go to state 53
    array-expr       go to state 54


State 124

  164 bitw-expr: expr BITWISE_AND . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 64
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 38
    expr             go to state 200
    idx-unsafe-expr  go to state 43
    idx-safe-expr    go to state 44
    vet-idx          go to state 66
    unary-expr       go to state 46
    arit-expr        go to state 47
    bitw-expr        go to state 48
    shift-expr       go to state 49
    var-att          go to state 67
    var-met          go to state 51
    var-obj          go to state 52
    var-val          go to state 53
    array-expr       go to state 54


State 125

  165 bitw-expr: expr BITWISE_OR . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 64
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 38
    expr             go to state 201
    idx-unsafe-expr  go to state 43
    idx-safe-expr    go to state 44
    vet-idx          go to state 66
    unary-expr       go to state 46
    arit-expr        go to state 47
    bitw-expr        go to state 48
    shift-expr       go to state 49
    var-att          go to state 67
    var-met          go to state 51
    var-obj          go to state 52
    var-val          go to state 53
    array-expr       go to state 54


State 126

  166 bitw-expr: expr BITWISE_XOR . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 64
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 38
    expr             go to state 202
    idx-unsafe-expr  go to state 43
    idx-safe-expr    go to state 44
    vet-idx          go to state 66
    unary-expr       go to state 46
    arit-expr        go to state 47
    bitw-expr        go to state 48
    shift-expr       go to state 49
    var-att          go to state 67
    var-met          go to state 51
    var-obj          go to state 52
    var-val          go to state 53
    array-expr       go to state 54


State 127

   75 logic-expr: expr LOGICAL_NULL . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 64
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 38
    expr             go to state 203
    idx-unsafe-expr  go to state 43
    idx-safe-expr    go to state 44
    vet-idx          go to state 66
    unary-expr       go to state 46
    arit-expr        go to state 47
    bitw-expr        go to state 48
    shift-expr       go to state 49
    var-att          go to state 67
    var-met          go to state 51
    var-obj          go to state 52
    var-val          go to state 53
    array-expr       go to state 54


State 128

   76 logic-expr: expr LOGICAL_AND . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 64
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 38
    expr             go to state 204
    idx-unsafe-expr  go to state 43
    idx-safe-expr    go to state 44
    vet-idx          go to state 66
    unary-expr       go to state 46
    arit-expr        go to state 47
    bitw-expr        go to state 48
    shift-expr       go to state 49
    var-att          go to state 67
    var-met          go to state 51
    var-obj          go to state 52
    var-val          go to state 53
    array-expr       go to state 54


State 129

   77 logic-expr: expr LOGICAL_OR . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 64
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 38
    expr             go to state 205
    idx-unsafe-expr  go to state 43
    idx-safe-expr    go to state 44
    vet-idx          go to state 66
    unary-expr       go to state 46
    arit-expr        go to state 47
    bitw-expr        go to state 48
    shift-expr       go to state 49
    var-att          go to state 67
    var-met          go to state 51
    var-obj          go to state 52
    var-val          go to state 53
    array-expr       go to state 54


State 130

   66 logic-expr: expr EQ . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 64
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 38
    expr             go to state 206
    idx-unsafe-expr  go to state 43
    idx-safe-expr    go to state 44
    vet-idx          go to state 66
    unary-expr       go to state 46
    arit-expr        go to state 47
    bitw-expr        go to state 48
    shift-expr       go to state 49
    var-att          go to state 67
    var-met          go to state 51
    var-obj          go to state 52
    var-val          go to state 53
    array-expr       go to state 54


State 131

   67 logic-expr: expr EQ_STRICT . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 64
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 38
    expr             go to state 207
    idx-unsafe-expr  go to state 43
    idx-safe-expr    go to state 44
    vet-idx          go to state 66
    unary-expr       go to state 46
    arit-expr        go to state 47
    bitw-expr        go to state 48
    shift-expr       go to state 49
    var-att          go to state 67
    var-met          go to state 51
    var-obj          go to state 52
    var-val          go to state 53
    array-expr       go to state 54


State 132

   68 logic-expr: expr INEQ . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 64
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 38
    expr             go to state 208
    idx-unsafe-expr  go to state 43
    idx-safe-expr    go to state 44
    vet-idx          go to state 66
    unary-expr       go to state 46
    arit-expr        go to state 47
    bitw-expr        go to state 48
    shift-expr       go to state 49
    var-att          go to state 67
    var-met          go to state 51
    var-obj          go to state 52
    var-val          go to state 53
    array-expr       go to state 54


State 133

   69 logic-expr: expr INEQ_STRICT . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 64
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 38
    expr             go to state 209
    idx-unsafe-expr  go to state 43
    idx-safe-expr    go to state 44
    vet-idx          go to state 66
    unary-expr       go to state 46
    arit-expr        go to state 47
    bitw-expr        go to state 48
    shift-expr       go to state 49
    var-att          go to state 67
    var-met          go to state 51
    var-obj          go to state 52
    var-val          go to state 53
    array-expr       go to state 54


State 134

   70 logic-expr: expr LT . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 64
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 38
    expr             go to state 210
    idx-unsafe-expr  go to state 43
    idx-safe-expr    go to state 44
    vet-idx          go to state 66
    unary-expr       go to state 46
    arit-expr        go to state 47
    bitw-expr        go to state 48
    shift-expr       go to state 49
    var-att          go to state 67
    var-met          go to state 51
    var-obj          go to state 52
    var-val          go to state 53
    array-expr       go to state 54


State 135

   72 logic-expr: expr LT_EQ . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 64
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 38
    expr             go to state 211
    idx-unsafe-expr  go to state 43
    idx-safe-expr    go to state 44
    vet-idx          go to state 66
    unary-expr       go to state 46
    arit-expr        go to state 47
    bitw-expr        go to state 48
    shift-expr       go to state 49
    var-att          go to state 67
    var-met          go to state 51
    var-obj          go to state 52
    var-val          go to state 53
    array-expr       go to state 54


State 136

   73 logic-expr: expr GT . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 64
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 38
    expr             go to state 212
    idx-unsafe-expr  go to state 43
    idx-safe-expr    go to state 44
    vet-idx          go to state 66
    unary-expr       go to state 46
    arit-expr        go to state 47
    bitw-expr        go to state 48
    shift-expr       go to state 49
    var-att          go to state 67
    var-met          go to state 51
    var-obj          go to state 52
    var-val          go to state 53
    array-expr       go to state 54


State 137

   74 logic-expr: expr GT_EQ . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 64
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 38
    expr             go to state 213
    idx-unsafe-expr  go to state 43
    idx-safe-expr    go to state 44
    vet-idx          go to state 66
    unary-expr       go to state 46
    arit-expr        go to state 47
    bitw-expr        go to state 48
    shift-expr       go to state 49
    var-att          go to state 67
    var-met          go to state 51
    var-obj          go to state 52
    var-val          go to state 53
    array-expr       go to state 54


State 138

  167 shift-expr: expr LSHIFT . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 64
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 38
    expr             go to state 214
    idx-unsafe-expr  go to state 43
    idx-safe-expr    go to state 44
    vet-idx          go to state 66
    unary-expr       go to state 46
    arit-expr        go to state 47
    bitw-expr        go to state 48
    shift-expr       go to state 49
    var-att          go to state 67
    var-met          go to state 51
    var-obj          go to state 52
    var-val          go to state 53
    array-expr       go to state 54


State 139

  168 shift-expr: expr RSHIFT . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 64
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 38
    expr             go to state 215
    idx-unsafe-expr  go to state 43
    idx-safe-expr    go to state 44
    vet-idx          go to state 66
    unary-expr       go to state 46
    arit-expr        go to state 47
    bitw-expr        go to state 48
    shift-expr       go to state 49
    var-att          go to state 67
    var-met          go to state 51
    var-obj          go to state 52
    var-val          go to state 53
    array-expr       go to state 54


State 140

  169 shift-expr: expr RSHIFT_UNSIGNED . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 64
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 38
    expr             go to state 216
    idx-unsafe-expr  go to state 43
    idx-safe-expr    go to state 44
    vet-idx          go to state 66
    unary-expr       go to state 46
    arit-expr        go to state 47
    bitw-expr        go to state 48
    shift-expr       go to state 49
    var-att          go to state 67
    var-met          go to state 51
    var-obj          go to state 52
    var-val          go to state 53
    array-expr       go to state 54


State 141

   21 assign-expr: vet-idx assignment . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 64
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 38
    expr             go to state 217
    idx-unsafe-expr  go to state 43
    idx-safe-expr    go to state 44
    vet-idx          go to state 66
    unary-expr       go to state 46
    arit-expr        go to state 47
    bitw-expr        go to state 48
    shift-expr       go to state 49
    var-att          go to state 67
    var-met          go to state 51
    var-obj          go to state 52
    var-val          go to state 53
    array-expr       go to state 54


State 142

  171 var-att: var-att DOT . ID
  175        | var-att DOT . var-met

    ID  shift, and go to state 218

    var-met  go to state 219


State 143

  153 unary-expr: var-att INCREMENT .

    $default  reduce using rule 153 (unary-expr)


State 144

  155 unary-expr: var-att DECREMENT .

    $default  reduce using rule 155 (unary-expr)


State 145

   19 assign-expr: var-att assignment . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 64
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 38
    expr             go to state 220
    idx-unsafe-expr  go to state 43
    idx-safe-expr    go to state 44
    vet-idx          go to state 66
    unary-expr       go to state 46
    arit-expr        go to state 47
    bitw-expr        go to state 48
    shift-expr       go to state 49
    var-att          go to state 67
    var-met          go to state 51
    var-obj          go to state 52
    var-val          go to state 53
    array-expr       go to state 54


State 146

  173 var-att: var-met DOT . ID
  174        | var-met DOT . var-att

    ID  shift, and go to state 221

    var-att  go to state 222
    var-met  go to state 51


State 147

  177 var-met: ID LPAR . args-list RPAR

    COMMA        shift, and go to state 164
    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 183 (args-list)

    assign-expr      go to state 165
    logic-expr       go to state 38
    expr             go to state 166
    idx-unsafe-expr  go to state 43
    idx-safe-expr    go to state 44
    vet-idx          go to state 45
    unary-expr       go to state 46
    arit-expr        go to state 47
    bitw-expr        go to state 48
    shift-expr       go to state 49
    var-att          go to state 50
    var-met          go to state 51
    args-list        go to state 223
    var-obj          go to state 52
    var-val          go to state 53
    array-expr       go to state 54


State 148

  135 expr: LPAR expr RPAR .

    $default  reduce using rule 135 (expr)


State 149

  201 elmts-list: COMMA elmts-list .

    $default  reduce using rule 201 (elmts-list)


State 150

  202 elmts-list: var-val COMMA . elmts-list

    COMMA      shift, and go to state 70
    SUB        shift, and go to state 2
    INT_VAL    shift, and go to state 8
    REAL_VAL   shift, and go to state 9
    STR_VAL    shift, and go to state 10
    FALSE_RW   shift, and go to state 17
    NULL_RW    shift, and go to state 23
    TRUE_RW    shift, and go to state 25
    UNDEFINED  shift, and go to state 28

    $default  reduce using rule 204 (elmts-list)

    var-val     go to state 71
    elmts-list  go to state 224


State 151

  200 array-expr: LBRACKET elmts-list RBRACKET .

    $default  reduce using rule 200 (array-expr)


State 152

  170 var-att: ID . DOT var-att
  172        | ID . DOT var-met
  176        | ID . DOT ID
  176        | ID DOT ID .
  177 var-met: ID . LPAR args-list RPAR

    DOT   shift, and go to state 74
    LPAR  shift, and go to state 147

    $default  reduce using rule 176 (var-att)


State 153

  170 var-att: ID DOT var-att .
  171        | var-att . DOT ID
  175        | var-att . DOT var-met

    DOT  shift, and go to state 142

    $default  reduce using rule 170 (var-att)


State 154

  172 var-att: ID DOT var-met .
  173        | var-met . DOT ID
  174        | var-met . DOT var-att

    DOT  shift, and go to state 146

    $default  reduce using rule 172 (var-att)


State 155

  131 var-type: VOID_RW .

    $default  reduce using rule 131 (var-type)


State 156

  130 var-type: ANY .

    $default  reduce using rule 130 (var-type)


State 157

  129 var-type: BOOLTYPE .

    $default  reduce using rule 129 (var-type)


State 158

  132 var-type: NEVER .

    $default  reduce using rule 132 (var-type)


State 159

  126 var-type: NUMBER .

    $default  reduce using rule 126 (var-type)


State 160

  127 var-type: STRING .

    $default  reduce using rule 127 (var-type)


State 161

  128 var-type: UNKNOWN .

    $default  reduce using rule 128 (var-type)


State 162

  185 var-obj: ID LT var-type . GT LPAR args-list RPAR

    GT  shift, and go to state 225


State 163

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   71           | ID LT expr .
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  158 arit-expr: expr . PLUS expr
  159          | expr . SUB expr
  160          | expr . MULT expr
  161          | expr . DIV expr
  162          | expr . EXP expr
  163          | expr . REM expr
  164 bitw-expr: expr . BITWISE_AND expr
  165          | expr . BITWISE_OR expr
  166          | expr . BITWISE_XOR expr
  167 shift-expr: expr . LSHIFT expr
  168           | expr . RSHIFT expr
  169           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 118
    SUB              shift, and go to state 119
    MULT             shift, and go to state 120
    DIV              shift, and go to state 121
    EXP              shift, and go to state 122
    REM              shift, and go to state 123
    BITWISE_AND      shift, and go to state 124
    BITWISE_OR       shift, and go to state 125
    BITWISE_XOR      shift, and go to state 126
    LSHIFT           shift, and go to state 138
    RSHIFT           shift, and go to state 139
    RSHIFT_UNSIGNED  shift, and go to state 140

    $default  reduce using rule 71 (logic-expr)


State 164

  178 args-list: COMMA . args-list

    COMMA        shift, and go to state 164
    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 183 (args-list)

    assign-expr      go to state 165
    logic-expr       go to state 38
    expr             go to state 166
    idx-unsafe-expr  go to state 43
    idx-safe-expr    go to state 44
    vet-idx          go to state 45
    unary-expr       go to state 46
    arit-expr        go to state 47
    bitw-expr        go to state 48
    shift-expr       go to state 49
    var-att          go to state 50
    var-met          go to state 51
    args-list        go to state 226
    var-obj          go to state 52
    var-val          go to state 53
    array-expr       go to state 54


State 165

  180 args-list: assign-expr . COMMA args-list
  182          | assign-expr .

    COMMA  shift, and go to state 227

    $default  reduce using rule 182 (args-list)


State 166

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  158 arit-expr: expr . PLUS expr
  159          | expr . SUB expr
  160          | expr . MULT expr
  161          | expr . DIV expr
  162          | expr . EXP expr
  163          | expr . REM expr
  164 bitw-expr: expr . BITWISE_AND expr
  165          | expr . BITWISE_OR expr
  166          | expr . BITWISE_XOR expr
  167 shift-expr: expr . LSHIFT expr
  168           | expr . RSHIFT expr
  169           | expr . RSHIFT_UNSIGNED expr
  179 args-list: expr . COMMA args-list
  181          | expr .

    COMMA            shift, and go to state 228
    PLUS             shift, and go to state 118
    SUB              shift, and go to state 119
    MULT             shift, and go to state 120
    DIV              shift, and go to state 121
    EXP              shift, and go to state 122
    REM              shift, and go to state 123
    BITWISE_AND      shift, and go to state 124
    BITWISE_OR       shift, and go to state 125
    BITWISE_XOR      shift, and go to state 126
    LOGICAL_NULL     shift, and go to state 127
    LOGICAL_AND      shift, and go to state 128
    LOGICAL_OR       shift, and go to state 129
    EQ               shift, and go to state 130
    EQ_STRICT        shift, and go to state 131
    INEQ             shift, and go to state 132
    INEQ_STRICT      shift, and go to state 133
    LT               shift, and go to state 134
    LT_EQ            shift, and go to state 135
    GT               shift, and go to state 136
    GT_EQ            shift, and go to state 137
    LSHIFT           shift, and go to state 138
    RSHIFT           shift, and go to state 139
    RSHIFT_UNSIGNED  shift, and go to state 140

    $default  reduce using rule 181 (args-list)


State 167

  177 var-met: ID LPAR args-list . RPAR
  184 var-obj: ID LPAR args-list . RPAR

    RPAR  shift, and go to state 229


State 168

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  158 arit-expr: expr . PLUS expr
  159          | expr . SUB expr
  160          | expr . MULT expr
  161          | expr . DIV expr
  162          | expr . EXP expr
  163          | expr . REM expr
  164 bitw-expr: expr . BITWISE_AND expr
  165          | expr . BITWISE_OR expr
  166          | expr . BITWISE_XOR expr
  167 shift-expr: expr . LSHIFT expr
  168           | expr . RSHIFT expr
  169           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 118
    SUB              shift, and go to state 119
    MULT             shift, and go to state 120
    DIV              shift, and go to state 121
    EXP              shift, and go to state 122
    REM              shift, and go to state 123
    BITWISE_AND      shift, and go to state 124
    BITWISE_OR       shift, and go to state 125
    BITWISE_XOR      shift, and go to state 126
    LOGICAL_NULL     shift, and go to state 127
    LOGICAL_AND      shift, and go to state 128
    LOGICAL_OR       shift, and go to state 129
    EQ               shift, and go to state 130
    EQ_STRICT        shift, and go to state 131
    INEQ             shift, and go to state 132
    INEQ_STRICT      shift, and go to state 133
    LT               shift, and go to state 134
    LT_EQ            shift, and go to state 135
    GT               shift, and go to state 136
    GT_EQ            shift, and go to state 137
    LSHIFT           shift, and go to state 138
    RSHIFT           shift, and go to state 139
    RSHIFT_UNSIGNED  shift, and go to state 140


State 169

  133 expr: idx-safe-expr .
  147 vet-idx: ID LBRACKET idx-safe-expr . RBRACKET

    RBRACKET  shift, and go to state 230

    $default  reduce using rule 133 (expr)


State 170

   20 assign-expr: ID assignment expr .
   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  158 arit-expr: expr . PLUS expr
  159          | expr . SUB expr
  160          | expr . MULT expr
  161          | expr . DIV expr
  162          | expr . EXP expr
  163          | expr . REM expr
  164 bitw-expr: expr . BITWISE_AND expr
  165          | expr . BITWISE_OR expr
  166          | expr . BITWISE_XOR expr
  167 shift-expr: expr . LSHIFT expr
  168           | expr . RSHIFT expr
  169           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 118
    SUB              shift, and go to state 119
    MULT             shift, and go to state 120
    DIV              shift, and go to state 121
    EXP              shift, and go to state 122
    REM              shift, and go to state 123
    BITWISE_AND      shift, and go to state 124
    BITWISE_OR       shift, and go to state 125
    BITWISE_XOR      shift, and go to state 126
    LOGICAL_NULL     shift, and go to state 127
    LOGICAL_AND      shift, and go to state 128
    LOGICAL_OR       shift, and go to state 129
    EQ               shift, and go to state 130
    EQ_STRICT        shift, and go to state 131
    INEQ             shift, and go to state 132
    INEQ_STRICT      shift, and go to state 133
    LT               shift, and go to state 134
    LT_EQ            shift, and go to state 135
    GT               shift, and go to state 136
    GT_EQ            shift, and go to state 137
    LSHIFT           shift, and go to state 138
    RSHIFT           shift, and go to state 139
    RSHIFT_UNSIGNED  shift, and go to state 140

    $default  reduce using rule 20 (assign-expr)


State 171

   78 class-def: CLASS ID LBRACE . class-att-list RBRACE

    SEMI       shift, and go to state 231
    ID         shift, and go to state 232
    PRIVATE    shift, and go to state 233
    PROTECTED  shift, and go to state 234
    PUBLIC     shift, and go to state 235

    $default  reduce using rule 82 (class-att-list)

    class-att-list  go to state 236
    class-att       go to state 237
    access-modif    go to state 238


State 172

  118 id-list: ID COMMA . id-list

    ID  shift, and go to state 239

    id-list  go to state 240


State 173

  115 var-declr: CONST_RW ID COLON . var-type ASSIGN expr
  116          | CONST_RW ID COLON . var-type LBRACKET RBRACKET ASSIGN expr

    VOID_RW   shift, and go to state 155
    ANY       shift, and go to state 156
    BOOLTYPE  shift, and go to state 157
    NEVER     shift, and go to state 158
    NUMBER    shift, and go to state 159
    STRING    shift, and go to state 160
    UNKNOWN   shift, and go to state 161

    var-type  go to state 241


State 174

  114 var-declr: CONST_RW id-list ASSIGN . expr
  117          | CONST_RW id-list ASSIGN . obj-def

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACE       shift, and go to state 242
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 64
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 38
    obj-def          go to state 243
    expr             go to state 244
    idx-unsafe-expr  go to state 43
    idx-safe-expr    go to state 44
    vet-idx          go to state 66
    unary-expr       go to state 46
    arit-expr        go to state 47
    bitw-expr        go to state 48
    shift-expr       go to state 49
    var-att          go to state 67
    var-met          go to state 51
    var-obj          go to state 52
    var-val          go to state 53
    array-expr       go to state 54


State 175

   56 do-while-stmt: DO LBRACE line . RBRACE WHILE LPAR expr RPAR
   57              | DO LBRACE line . RBRACE WHILE LPAR assign-expr RPAR

    RBRACE  shift, and go to state 245


State 176

   34 for-stmt: FOR LPAR SEMI . expr SEMI expr RPAR LBRACE line RBRACE
   35         | FOR LPAR SEMI . expr SEMI assign-expr RPAR LBRACE line RBRACE
   36         | FOR LPAR SEMI . expr SEMI RPAR LBRACE line RBRACE
   37         | FOR LPAR SEMI . SEMI expr RPAR LBRACE line RBRACE
   38         | FOR LPAR SEMI . SEMI assign-expr RPAR LBRACE line RBRACE
   39         | FOR LPAR SEMI . SEMI RPAR LBRACE line RBRACE

    SEMI         shift, and go to state 246
    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 64
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 38
    expr             go to state 247
    idx-unsafe-expr  go to state 43
    idx-safe-expr    go to state 44
    vet-idx          go to state 66
    unary-expr       go to state 46
    arit-expr        go to state 47
    bitw-expr        go to state 48
    shift-expr       go to state 49
    var-att          go to state 67
    var-met          go to state 51
    var-obj          go to state 52
    var-val          go to state 53
    array-expr       go to state 54


State 177

   20 assign-expr: ID . assignment expr
  147 vet-idx: ID . LBRACKET idx-safe-expr RBRACKET
  170 var-att: ID . DOT var-att
  172        | ID . DOT var-met
  176        | ID . DOT ID
  177 var-met: ID . LPAR args-list RPAR

    ASSIGN                  shift, and go to state 73
    DOT                     shift, and go to state 74
    PLUS_ASSIGN             shift, and go to state 76
    SUB_ASSIGN              shift, and go to state 78
    MULT_ASSIGN             shift, and go to state 79
    DIV_ASSIGN              shift, and go to state 80
    EXP_ASSIGN              shift, and go to state 81
    REM_ASSIGN              shift, and go to state 82
    BITWISE_AND_ASSIGN      shift, and go to state 83
    BITWISE_OR_ASSIGN       shift, and go to state 84
    BITWISE_XOR_ASSIGN      shift, and go to state 85
    LOGICAL_NULL_ASSIGN     shift, and go to state 86
    LOGICAL_AND_ASSIGN      shift, and go to state 87
    LOGICAL_OR_ASSIGN       shift, and go to state 88
    LSHIFT_ASSIGN           shift, and go to state 90
    RSHIFT_ASSIGN           shift, and go to state 91
    RSHIFT_UNSIGNED_ASSIGN  shift, and go to state 92
    LPAR                    shift, and go to state 147
    LBRACKET                shift, and go to state 94

    assignment  go to state 95


State 178

   22 for-stmt: FOR LPAR assign-expr . SEMI expr SEMI expr RPAR LBRACE line RBRACE
   23         | FOR LPAR assign-expr . SEMI expr SEMI assign-expr RPAR LBRACE line RBRACE
   24         | FOR LPAR assign-expr . SEMI expr SEMI RPAR LBRACE line RBRACE
   25         | FOR LPAR assign-expr . SEMI SEMI expr RPAR LBRACE line RBRACE
   26         | FOR LPAR assign-expr . SEMI SEMI assign-expr RPAR LBRACE line RBRACE
   27         | FOR LPAR assign-expr . SEMI SEMI RPAR LBRACE line RBRACE

    SEMI  shift, and go to state 248


State 179

   28 for-stmt: FOR LPAR var-declr . SEMI expr SEMI expr RPAR LBRACE line RBRACE
   29         | FOR LPAR var-declr . SEMI expr SEMI assign-expr RPAR LBRACE line RBRACE
   30         | FOR LPAR var-declr . SEMI expr SEMI RPAR LBRACE line RBRACE
   31         | FOR LPAR var-declr . SEMI SEMI expr RPAR LBRACE line RBRACE
   32         | FOR LPAR var-declr . SEMI SEMI assign-expr RPAR LBRACE line RBRACE
   33         | FOR LPAR var-declr . SEMI SEMI RPAR LBRACE line RBRACE

    SEMI  shift, and go to state 249


State 180

   21 assign-expr: vet-idx . assignment expr

    ASSIGN                  shift, and go to state 73
    PLUS_ASSIGN             shift, and go to state 76
    SUB_ASSIGN              shift, and go to state 78
    MULT_ASSIGN             shift, and go to state 79
    DIV_ASSIGN              shift, and go to state 80
    EXP_ASSIGN              shift, and go to state 81
    REM_ASSIGN              shift, and go to state 82
    BITWISE_AND_ASSIGN      shift, and go to state 83
    BITWISE_OR_ASSIGN       shift, and go to state 84
    BITWISE_XOR_ASSIGN      shift, and go to state 85
    LOGICAL_NULL_ASSIGN     shift, and go to state 86
    LOGICAL_AND_ASSIGN      shift, and go to state 87
    LOGICAL_OR_ASSIGN       shift, and go to state 88
    LSHIFT_ASSIGN           shift, and go to state 90
    RSHIFT_ASSIGN           shift, and go to state 91
    RSHIFT_UNSIGNED_ASSIGN  shift, and go to state 92

    assignment  go to state 141


State 181

   19 assign-expr: var-att . assignment expr
  171 var-att: var-att . DOT ID
  175        | var-att . DOT var-met

    ASSIGN                  shift, and go to state 73
    DOT                     shift, and go to state 142
    PLUS_ASSIGN             shift, and go to state 76
    SUB_ASSIGN              shift, and go to state 78
    MULT_ASSIGN             shift, and go to state 79
    DIV_ASSIGN              shift, and go to state 80
    EXP_ASSIGN              shift, and go to state 81
    REM_ASSIGN              shift, and go to state 82
    BITWISE_AND_ASSIGN      shift, and go to state 83
    BITWISE_OR_ASSIGN       shift, and go to state 84
    BITWISE_XOR_ASSIGN      shift, and go to state 85
    LOGICAL_NULL_ASSIGN     shift, and go to state 86
    LOGICAL_AND_ASSIGN      shift, and go to state 87
    LOGICAL_OR_ASSIGN       shift, and go to state 88
    LSHIFT_ASSIGN           shift, and go to state 90
    RSHIFT_ASSIGN           shift, and go to state 91
    RSHIFT_UNSIGNED_ASSIGN  shift, and go to state 92

    assignment  go to state 145


State 182

   90 func-def: FUNCTION ID LPAR . params RPAR LBRACE line RBRACE
   91         | FUNCTION ID LPAR . params RPAR COLON var-type LBRACE line RBRACE

    COMMA  shift, and go to state 250
    ID     shift, and go to state 251

    $default  reduce using rule 99 (params)

    params  go to state 252


State 183

   63 if-stmt: IF LPAR assign-expr . RPAR LBRACE line RBRACE
   64        | IF LPAR assign-expr . RPAR LBRACE line RBRACE ELSE LBRACE line RBRACE
   65        | IF LPAR assign-expr . RPAR LBRACE line RBRACE ELSE stmt

    RPAR  shift, and go to state 253


State 184

   60 if-stmt: IF LPAR expr . RPAR LBRACE line RBRACE
   61        | IF LPAR expr . RPAR LBRACE line RBRACE ELSE LBRACE line RBRACE
   62        | IF LPAR expr . RPAR LBRACE line RBRACE ELSE stmt
   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  158 arit-expr: expr . PLUS expr
  159          | expr . SUB expr
  160          | expr . MULT expr
  161          | expr . DIV expr
  162          | expr . EXP expr
  163          | expr . REM expr
  164 bitw-expr: expr . BITWISE_AND expr
  165          | expr . BITWISE_OR expr
  166          | expr . BITWISE_XOR expr
  167 shift-expr: expr . LSHIFT expr
  168           | expr . RSHIFT expr
  169           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 118
    SUB              shift, and go to state 119
    MULT             shift, and go to state 120
    DIV              shift, and go to state 121
    EXP              shift, and go to state 122
    REM              shift, and go to state 123
    BITWISE_AND      shift, and go to state 124
    BITWISE_OR       shift, and go to state 125
    BITWISE_XOR      shift, and go to state 126
    LOGICAL_NULL     shift, and go to state 127
    LOGICAL_AND      shift, and go to state 128
    LOGICAL_OR       shift, and go to state 129
    EQ               shift, and go to state 130
    EQ_STRICT        shift, and go to state 131
    INEQ             shift, and go to state 132
    INEQ_STRICT      shift, and go to state 133
    LT               shift, and go to state 134
    LT_EQ            shift, and go to state 135
    GT               shift, and go to state 136
    GT_EQ            shift, and go to state 137
    LSHIFT           shift, and go to state 138
    RSHIFT           shift, and go to state 139
    RSHIFT_UNSIGNED  shift, and go to state 140
    RPAR             shift, and go to state 254


State 185

  103 var-declr: LET ID COLON . var-type
  104          | LET ID COLON . var-type ASSIGN expr
  105          | LET ID COLON . var-type LBRACKET RBRACKET
  106          | LET ID COLON . var-type LBRACKET RBRACKET ASSIGN expr

    VOID_RW   shift, and go to state 155
    ANY       shift, and go to state 156
    BOOLTYPE  shift, and go to state 157
    NEVER     shift, and go to state 158
    NUMBER    shift, and go to state 159
    STRING    shift, and go to state 160
    UNKNOWN   shift, and go to state 161

    var-type  go to state 255


State 186

  101 var-declr: LET id-list ASSIGN . expr
  102          | LET id-list ASSIGN . obj-def

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACE       shift, and go to state 242
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 64
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 38
    obj-def          go to state 256
    expr             go to state 257
    idx-unsafe-expr  go to state 43
    idx-safe-expr    go to state 44
    vet-idx          go to state 66
    unary-expr       go to state 46
    arit-expr        go to state 47
    bitw-expr        go to state 48
    shift-expr       go to state 49
    var-att          go to state 67
    var-met          go to state 51
    var-obj          go to state 52
    var-val          go to state 53
    array-expr       go to state 54


State 187

  187 var-obj: NEW ID LT . var-type GT LPAR args-list RPAR

    VOID_RW   shift, and go to state 155
    ANY       shift, and go to state 156
    BOOLTYPE  shift, and go to state 157
    NEVER     shift, and go to state 158
    NUMBER    shift, and go to state 159
    STRING    shift, and go to state 160
    UNKNOWN   shift, and go to state 161

    var-type  go to state 258


State 188

  186 var-obj: NEW ID LPAR . args-list RPAR

    COMMA        shift, and go to state 164
    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 183 (args-list)

    assign-expr      go to state 165
    logic-expr       go to state 38
    expr             go to state 166
    idx-unsafe-expr  go to state 43
    idx-safe-expr    go to state 44
    vet-idx          go to state 45
    unary-expr       go to state 46
    arit-expr        go to state 47
    bitw-expr        go to state 48
    shift-expr       go to state 49
    var-att          go to state 50
    var-met          go to state 51
    args-list        go to state 259
    var-obj          go to state 52
    var-val          go to state 53
    array-expr       go to state 54


State 189

   16 stmt: RETURN expr SEMI .

    $default  reduce using rule 16 (stmt)


State 190

  110 var-declr: VAR ID COLON . var-type
  111          | VAR ID COLON . var-type ASSIGN expr
  112          | VAR ID COLON . var-type LBRACKET RBRACKET
  113          | VAR ID COLON . var-type LBRACKET RBRACKET ASSIGN expr

    VOID_RW   shift, and go to state 155
    ANY       shift, and go to state 156
    BOOLTYPE  shift, and go to state 157
    NEVER     shift, and go to state 158
    NUMBER    shift, and go to state 159
    STRING    shift, and go to state 160
    UNKNOWN   shift, and go to state 161

    var-type  go to state 260


State 191

  108 var-declr: VAR id-list ASSIGN . expr
  109          | VAR id-list ASSIGN . obj-def

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACE       shift, and go to state 242
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 64
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 38
    obj-def          go to state 261
    expr             go to state 262
    idx-unsafe-expr  go to state 43
    idx-safe-expr    go to state 44
    vet-idx          go to state 66
    unary-expr       go to state 46
    arit-expr        go to state 47
    bitw-expr        go to state 48
    shift-expr       go to state 49
    var-att          go to state 67
    var-met          go to state 51
    var-obj          go to state 52
    var-val          go to state 53
    array-expr       go to state 54


State 192

   59 while-stmt: WHILE LPAR assign-expr . RPAR LBRACE line RBRACE

    RPAR  shift, and go to state 263


State 193

   58 while-stmt: WHILE LPAR expr . RPAR LBRACE line RBRACE
   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  158 arit-expr: expr . PLUS expr
  159          | expr . SUB expr
  160          | expr . MULT expr
  161          | expr . DIV expr
  162          | expr . EXP expr
  163          | expr . REM expr
  164 bitw-expr: expr . BITWISE_AND expr
  165          | expr . BITWISE_OR expr
  166          | expr . BITWISE_XOR expr
  167 shift-expr: expr . LSHIFT expr
  168           | expr . RSHIFT expr
  169           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 118
    SUB              shift, and go to state 119
    MULT             shift, and go to state 120
    DIV              shift, and go to state 121
    EXP              shift, and go to state 122
    REM              shift, and go to state 123
    BITWISE_AND      shift, and go to state 124
    BITWISE_OR       shift, and go to state 125
    BITWISE_XOR      shift, and go to state 126
    LOGICAL_NULL     shift, and go to state 127
    LOGICAL_AND      shift, and go to state 128
    LOGICAL_OR       shift, and go to state 129
    EQ               shift, and go to state 130
    EQ_STRICT        shift, and go to state 131
    INEQ             shift, and go to state 132
    INEQ_STRICT      shift, and go to state 133
    LT               shift, and go to state 134
    LT_EQ            shift, and go to state 135
    GT               shift, and go to state 136
    GT_EQ            shift, and go to state 137
    LSHIFT           shift, and go to state 138
    RSHIFT           shift, and go to state 139
    RSHIFT_UNSIGNED  shift, and go to state 140
    RPAR             shift, and go to state 264


State 194

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  158 arit-expr: expr . PLUS expr
  158          | expr PLUS expr .
  159          | expr . SUB expr
  160          | expr . MULT expr
  161          | expr . DIV expr
  162          | expr . EXP expr
  163          | expr . REM expr
  164 bitw-expr: expr . BITWISE_AND expr
  165          | expr . BITWISE_OR expr
  166          | expr . BITWISE_XOR expr
  167 shift-expr: expr . LSHIFT expr
  168           | expr . RSHIFT expr
  169           | expr . RSHIFT_UNSIGNED expr

    MULT  shift, and go to state 120
    DIV   shift, and go to state 121
    EXP   shift, and go to state 122
    REM   shift, and go to state 123

    $default  reduce using rule 158 (arit-expr)


State 195

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  158 arit-expr: expr . PLUS expr
  159          | expr . SUB expr
  159          | expr SUB expr .
  160          | expr . MULT expr
  161          | expr . DIV expr
  162          | expr . EXP expr
  163          | expr . REM expr
  164 bitw-expr: expr . BITWISE_AND expr
  165          | expr . BITWISE_OR expr
  166          | expr . BITWISE_XOR expr
  167 shift-expr: expr . LSHIFT expr
  168           | expr . RSHIFT expr
  169           | expr . RSHIFT_UNSIGNED expr

    MULT  shift, and go to state 120
    DIV   shift, and go to state 121
    EXP   shift, and go to state 122
    REM   shift, and go to state 123

    $default  reduce using rule 159 (arit-expr)


State 196

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  158 arit-expr: expr . PLUS expr
  159          | expr . SUB expr
  160          | expr . MULT expr
  160          | expr MULT expr .
  161          | expr . DIV expr
  162          | expr . EXP expr
  163          | expr . REM expr
  164 bitw-expr: expr . BITWISE_AND expr
  165          | expr . BITWISE_OR expr
  166          | expr . BITWISE_XOR expr
  167 shift-expr: expr . LSHIFT expr
  168           | expr . RSHIFT expr
  169           | expr . RSHIFT_UNSIGNED expr

    EXP  shift, and go to state 122

    $default  reduce using rule 160 (arit-expr)


State 197

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  158 arit-expr: expr . PLUS expr
  159          | expr . SUB expr
  160          | expr . MULT expr
  161          | expr . DIV expr
  161          | expr DIV expr .
  162          | expr . EXP expr
  163          | expr . REM expr
  164 bitw-expr: expr . BITWISE_AND expr
  165          | expr . BITWISE_OR expr
  166          | expr . BITWISE_XOR expr
  167 shift-expr: expr . LSHIFT expr
  168           | expr . RSHIFT expr
  169           | expr . RSHIFT_UNSIGNED expr

    EXP  shift, and go to state 122

    $default  reduce using rule 161 (arit-expr)


State 198

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  158 arit-expr: expr . PLUS expr
  159          | expr . SUB expr
  160          | expr . MULT expr
  161          | expr . DIV expr
  162          | expr . EXP expr
  162          | expr EXP expr .
  163          | expr . REM expr
  164 bitw-expr: expr . BITWISE_AND expr
  165          | expr . BITWISE_OR expr
  166          | expr . BITWISE_XOR expr
  167 shift-expr: expr . LSHIFT expr
  168           | expr . RSHIFT expr
  169           | expr . RSHIFT_UNSIGNED expr

    EXP  shift, and go to state 122

    $default  reduce using rule 162 (arit-expr)


State 199

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  158 arit-expr: expr . PLUS expr
  159          | expr . SUB expr
  160          | expr . MULT expr
  161          | expr . DIV expr
  162          | expr . EXP expr
  163          | expr . REM expr
  163          | expr REM expr .
  164 bitw-expr: expr . BITWISE_AND expr
  165          | expr . BITWISE_OR expr
  166          | expr . BITWISE_XOR expr
  167 shift-expr: expr . LSHIFT expr
  168           | expr . RSHIFT expr
  169           | expr . RSHIFT_UNSIGNED expr

    EXP  shift, and go to state 122

    $default  reduce using rule 163 (arit-expr)


State 200

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  158 arit-expr: expr . PLUS expr
  159          | expr . SUB expr
  160          | expr . MULT expr
  161          | expr . DIV expr
  162          | expr . EXP expr
  163          | expr . REM expr
  164 bitw-expr: expr . BITWISE_AND expr
  164          | expr BITWISE_AND expr .
  165          | expr . BITWISE_OR expr
  166          | expr . BITWISE_XOR expr
  167 shift-expr: expr . LSHIFT expr
  168           | expr . RSHIFT expr
  169           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 118
    SUB              shift, and go to state 119
    MULT             shift, and go to state 120
    DIV              shift, and go to state 121
    EXP              shift, and go to state 122
    REM              shift, and go to state 123
    LSHIFT           shift, and go to state 138
    RSHIFT           shift, and go to state 139
    RSHIFT_UNSIGNED  shift, and go to state 140

    $default  reduce using rule 164 (bitw-expr)


State 201

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  158 arit-expr: expr . PLUS expr
  159          | expr . SUB expr
  160          | expr . MULT expr
  161          | expr . DIV expr
  162          | expr . EXP expr
  163          | expr . REM expr
  164 bitw-expr: expr . BITWISE_AND expr
  165          | expr . BITWISE_OR expr
  165          | expr BITWISE_OR expr .
  166          | expr . BITWISE_XOR expr
  167 shift-expr: expr . LSHIFT expr
  168           | expr . RSHIFT expr
  169           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 118
    SUB              shift, and go to state 119
    MULT             shift, and go to state 120
    DIV              shift, and go to state 121
    EXP              shift, and go to state 122
    REM              shift, and go to state 123
    BITWISE_AND      shift, and go to state 124
    BITWISE_XOR      shift, and go to state 126
    LSHIFT           shift, and go to state 138
    RSHIFT           shift, and go to state 139
    RSHIFT_UNSIGNED  shift, and go to state 140

    $default  reduce using rule 165 (bitw-expr)


State 202

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  158 arit-expr: expr . PLUS expr
  159          | expr . SUB expr
  160          | expr . MULT expr
  161          | expr . DIV expr
  162          | expr . EXP expr
  163          | expr . REM expr
  164 bitw-expr: expr . BITWISE_AND expr
  165          | expr . BITWISE_OR expr
  166          | expr . BITWISE_XOR expr
  166          | expr BITWISE_XOR expr .
  167 shift-expr: expr . LSHIFT expr
  168           | expr . RSHIFT expr
  169           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 118
    SUB              shift, and go to state 119
    MULT             shift, and go to state 120
    DIV              shift, and go to state 121
    EXP              shift, and go to state 122
    REM              shift, and go to state 123
    BITWISE_AND      shift, and go to state 124
    LSHIFT           shift, and go to state 138
    RSHIFT           shift, and go to state 139
    RSHIFT_UNSIGNED  shift, and go to state 140

    $default  reduce using rule 166 (bitw-expr)


State 203

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   75           | expr LOGICAL_NULL expr .
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  158 arit-expr: expr . PLUS expr
  159          | expr . SUB expr
  160          | expr . MULT expr
  161          | expr . DIV expr
  162          | expr . EXP expr
  163          | expr . REM expr
  164 bitw-expr: expr . BITWISE_AND expr
  165          | expr . BITWISE_OR expr
  166          | expr . BITWISE_XOR expr
  167 shift-expr: expr . LSHIFT expr
  168           | expr . RSHIFT expr
  169           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 118
    SUB              shift, and go to state 119
    MULT             shift, and go to state 120
    DIV              shift, and go to state 121
    EXP              shift, and go to state 122
    REM              shift, and go to state 123
    BITWISE_AND      shift, and go to state 124
    BITWISE_OR       shift, and go to state 125
    BITWISE_XOR      shift, and go to state 126
    LSHIFT           shift, and go to state 138
    RSHIFT           shift, and go to state 139
    RSHIFT_UNSIGNED  shift, and go to state 140

    $default  reduce using rule 75 (logic-expr)


State 204

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   76           | expr LOGICAL_AND expr .
   77           | expr . LOGICAL_OR expr
  158 arit-expr: expr . PLUS expr
  159          | expr . SUB expr
  160          | expr . MULT expr
  161          | expr . DIV expr
  162          | expr . EXP expr
  163          | expr . REM expr
  164 bitw-expr: expr . BITWISE_AND expr
  165          | expr . BITWISE_OR expr
  166          | expr . BITWISE_XOR expr
  167 shift-expr: expr . LSHIFT expr
  168           | expr . RSHIFT expr
  169           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 118
    SUB              shift, and go to state 119
    MULT             shift, and go to state 120
    DIV              shift, and go to state 121
    EXP              shift, and go to state 122
    REM              shift, and go to state 123
    BITWISE_AND      shift, and go to state 124
    BITWISE_OR       shift, and go to state 125
    BITWISE_XOR      shift, and go to state 126
    LSHIFT           shift, and go to state 138
    RSHIFT           shift, and go to state 139
    RSHIFT_UNSIGNED  shift, and go to state 140

    $default  reduce using rule 76 (logic-expr)


State 205

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
   77           | expr LOGICAL_OR expr .
  158 arit-expr: expr . PLUS expr
  159          | expr . SUB expr
  160          | expr . MULT expr
  161          | expr . DIV expr
  162          | expr . EXP expr
  163          | expr . REM expr
  164 bitw-expr: expr . BITWISE_AND expr
  165          | expr . BITWISE_OR expr
  166          | expr . BITWISE_XOR expr
  167 shift-expr: expr . LSHIFT expr
  168           | expr . RSHIFT expr
  169           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 118
    SUB              shift, and go to state 119
    MULT             shift, and go to state 120
    DIV              shift, and go to state 121
    EXP              shift, and go to state 122
    REM              shift, and go to state 123
    BITWISE_AND      shift, and go to state 124
    BITWISE_OR       shift, and go to state 125
    BITWISE_XOR      shift, and go to state 126
    LSHIFT           shift, and go to state 138
    RSHIFT           shift, and go to state 139
    RSHIFT_UNSIGNED  shift, and go to state 140

    $default  reduce using rule 77 (logic-expr)


State 206

   66 logic-expr: expr . EQ expr
   66           | expr EQ expr .
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  158 arit-expr: expr . PLUS expr
  159          | expr . SUB expr
  160          | expr . MULT expr
  161          | expr . DIV expr
  162          | expr . EXP expr
  163          | expr . REM expr
  164 bitw-expr: expr . BITWISE_AND expr
  165          | expr . BITWISE_OR expr
  166          | expr . BITWISE_XOR expr
  167 shift-expr: expr . LSHIFT expr
  168           | expr . RSHIFT expr
  169           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 118
    SUB              shift, and go to state 119
    MULT             shift, and go to state 120
    DIV              shift, and go to state 121
    EXP              shift, and go to state 122
    REM              shift, and go to state 123
    BITWISE_AND      shift, and go to state 124
    BITWISE_OR       shift, and go to state 125
    BITWISE_XOR      shift, and go to state 126
    LSHIFT           shift, and go to state 138
    RSHIFT           shift, and go to state 139
    RSHIFT_UNSIGNED  shift, and go to state 140

    $default  reduce using rule 66 (logic-expr)


State 207

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   67           | expr EQ_STRICT expr .
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  158 arit-expr: expr . PLUS expr
  159          | expr . SUB expr
  160          | expr . MULT expr
  161          | expr . DIV expr
  162          | expr . EXP expr
  163          | expr . REM expr
  164 bitw-expr: expr . BITWISE_AND expr
  165          | expr . BITWISE_OR expr
  166          | expr . BITWISE_XOR expr
  167 shift-expr: expr . LSHIFT expr
  168           | expr . RSHIFT expr
  169           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 118
    SUB              shift, and go to state 119
    MULT             shift, and go to state 120
    DIV              shift, and go to state 121
    EXP              shift, and go to state 122
    REM              shift, and go to state 123
    BITWISE_AND      shift, and go to state 124
    BITWISE_OR       shift, and go to state 125
    BITWISE_XOR      shift, and go to state 126
    LSHIFT           shift, and go to state 138
    RSHIFT           shift, and go to state 139
    RSHIFT_UNSIGNED  shift, and go to state 140

    $default  reduce using rule 67 (logic-expr)


State 208

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   68           | expr INEQ expr .
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  158 arit-expr: expr . PLUS expr
  159          | expr . SUB expr
  160          | expr . MULT expr
  161          | expr . DIV expr
  162          | expr . EXP expr
  163          | expr . REM expr
  164 bitw-expr: expr . BITWISE_AND expr
  165          | expr . BITWISE_OR expr
  166          | expr . BITWISE_XOR expr
  167 shift-expr: expr . LSHIFT expr
  168           | expr . RSHIFT expr
  169           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 118
    SUB              shift, and go to state 119
    MULT             shift, and go to state 120
    DIV              shift, and go to state 121
    EXP              shift, and go to state 122
    REM              shift, and go to state 123
    BITWISE_AND      shift, and go to state 124
    BITWISE_OR       shift, and go to state 125
    BITWISE_XOR      shift, and go to state 126
    LSHIFT           shift, and go to state 138
    RSHIFT           shift, and go to state 139
    RSHIFT_UNSIGNED  shift, and go to state 140

    $default  reduce using rule 68 (logic-expr)


State 209

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   69           | expr INEQ_STRICT expr .
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  158 arit-expr: expr . PLUS expr
  159          | expr . SUB expr
  160          | expr . MULT expr
  161          | expr . DIV expr
  162          | expr . EXP expr
  163          | expr . REM expr
  164 bitw-expr: expr . BITWISE_AND expr
  165          | expr . BITWISE_OR expr
  166          | expr . BITWISE_XOR expr
  167 shift-expr: expr . LSHIFT expr
  168           | expr . RSHIFT expr
  169           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 118
    SUB              shift, and go to state 119
    MULT             shift, and go to state 120
    DIV              shift, and go to state 121
    EXP              shift, and go to state 122
    REM              shift, and go to state 123
    BITWISE_AND      shift, and go to state 124
    BITWISE_OR       shift, and go to state 125
    BITWISE_XOR      shift, and go to state 126
    LSHIFT           shift, and go to state 138
    RSHIFT           shift, and go to state 139
    RSHIFT_UNSIGNED  shift, and go to state 140

    $default  reduce using rule 69 (logic-expr)


State 210

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   70           | expr LT expr .
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  158 arit-expr: expr . PLUS expr
  159          | expr . SUB expr
  160          | expr . MULT expr
  161          | expr . DIV expr
  162          | expr . EXP expr
  163          | expr . REM expr
  164 bitw-expr: expr . BITWISE_AND expr
  165          | expr . BITWISE_OR expr
  166          | expr . BITWISE_XOR expr
  167 shift-expr: expr . LSHIFT expr
  168           | expr . RSHIFT expr
  169           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 118
    SUB              shift, and go to state 119
    MULT             shift, and go to state 120
    DIV              shift, and go to state 121
    EXP              shift, and go to state 122
    REM              shift, and go to state 123
    BITWISE_AND      shift, and go to state 124
    BITWISE_OR       shift, and go to state 125
    BITWISE_XOR      shift, and go to state 126
    LSHIFT           shift, and go to state 138
    RSHIFT           shift, and go to state 139
    RSHIFT_UNSIGNED  shift, and go to state 140

    $default  reduce using rule 70 (logic-expr)


State 211

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   72           | expr LT_EQ expr .
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  158 arit-expr: expr . PLUS expr
  159          | expr . SUB expr
  160          | expr . MULT expr
  161          | expr . DIV expr
  162          | expr . EXP expr
  163          | expr . REM expr
  164 bitw-expr: expr . BITWISE_AND expr
  165          | expr . BITWISE_OR expr
  166          | expr . BITWISE_XOR expr
  167 shift-expr: expr . LSHIFT expr
  168           | expr . RSHIFT expr
  169           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 118
    SUB              shift, and go to state 119
    MULT             shift, and go to state 120
    DIV              shift, and go to state 121
    EXP              shift, and go to state 122
    REM              shift, and go to state 123
    BITWISE_AND      shift, and go to state 124
    BITWISE_OR       shift, and go to state 125
    BITWISE_XOR      shift, and go to state 126
    LSHIFT           shift, and go to state 138
    RSHIFT           shift, and go to state 139
    RSHIFT_UNSIGNED  shift, and go to state 140

    $default  reduce using rule 72 (logic-expr)


State 212

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   73           | expr GT expr .
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  158 arit-expr: expr . PLUS expr
  159          | expr . SUB expr
  160          | expr . MULT expr
  161          | expr . DIV expr
  162          | expr . EXP expr
  163          | expr . REM expr
  164 bitw-expr: expr . BITWISE_AND expr
  165          | expr . BITWISE_OR expr
  166          | expr . BITWISE_XOR expr
  167 shift-expr: expr . LSHIFT expr
  168           | expr . RSHIFT expr
  169           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 118
    SUB              shift, and go to state 119
    MULT             shift, and go to state 120
    DIV              shift, and go to state 121
    EXP              shift, and go to state 122
    REM              shift, and go to state 123
    BITWISE_AND      shift, and go to state 124
    BITWISE_OR       shift, and go to state 125
    BITWISE_XOR      shift, and go to state 126
    LSHIFT           shift, and go to state 138
    RSHIFT           shift, and go to state 139
    RSHIFT_UNSIGNED  shift, and go to state 140

    $default  reduce using rule 73 (logic-expr)


State 213

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   74           | expr GT_EQ expr .
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  158 arit-expr: expr . PLUS expr
  159          | expr . SUB expr
  160          | expr . MULT expr
  161          | expr . DIV expr
  162          | expr . EXP expr
  163          | expr . REM expr
  164 bitw-expr: expr . BITWISE_AND expr
  165          | expr . BITWISE_OR expr
  166          | expr . BITWISE_XOR expr
  167 shift-expr: expr . LSHIFT expr
  168           | expr . RSHIFT expr
  169           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 118
    SUB              shift, and go to state 119
    MULT             shift, and go to state 120
    DIV              shift, and go to state 121
    EXP              shift, and go to state 122
    REM              shift, and go to state 123
    BITWISE_AND      shift, and go to state 124
    BITWISE_OR       shift, and go to state 125
    BITWISE_XOR      shift, and go to state 126
    LSHIFT           shift, and go to state 138
    RSHIFT           shift, and go to state 139
    RSHIFT_UNSIGNED  shift, and go to state 140

    $default  reduce using rule 74 (logic-expr)


State 214

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  158 arit-expr: expr . PLUS expr
  159          | expr . SUB expr
  160          | expr . MULT expr
  161          | expr . DIV expr
  162          | expr . EXP expr
  163          | expr . REM expr
  164 bitw-expr: expr . BITWISE_AND expr
  165          | expr . BITWISE_OR expr
  166          | expr . BITWISE_XOR expr
  167 shift-expr: expr . LSHIFT expr
  167           | expr LSHIFT expr .
  168           | expr . RSHIFT expr
  169           | expr . RSHIFT_UNSIGNED expr

    PLUS  shift, and go to state 118
    SUB   shift, and go to state 119
    MULT  shift, and go to state 120
    DIV   shift, and go to state 121
    EXP   shift, and go to state 122
    REM   shift, and go to state 123

    $default  reduce using rule 167 (shift-expr)


State 215

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  158 arit-expr: expr . PLUS expr
  159          | expr . SUB expr
  160          | expr . MULT expr
  161          | expr . DIV expr
  162          | expr . EXP expr
  163          | expr . REM expr
  164 bitw-expr: expr . BITWISE_AND expr
  165          | expr . BITWISE_OR expr
  166          | expr . BITWISE_XOR expr
  167 shift-expr: expr . LSHIFT expr
  168           | expr . RSHIFT expr
  168           | expr RSHIFT expr .
  169           | expr . RSHIFT_UNSIGNED expr

    PLUS  shift, and go to state 118
    SUB   shift, and go to state 119
    MULT  shift, and go to state 120
    DIV   shift, and go to state 121
    EXP   shift, and go to state 122
    REM   shift, and go to state 123

    $default  reduce using rule 168 (shift-expr)


State 216

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  158 arit-expr: expr . PLUS expr
  159          | expr . SUB expr
  160          | expr . MULT expr
  161          | expr . DIV expr
  162          | expr . EXP expr
  163          | expr . REM expr
  164 bitw-expr: expr . BITWISE_AND expr
  165          | expr . BITWISE_OR expr
  166          | expr . BITWISE_XOR expr
  167 shift-expr: expr . LSHIFT expr
  168           | expr . RSHIFT expr
  169           | expr . RSHIFT_UNSIGNED expr
  169           | expr RSHIFT_UNSIGNED expr .

    PLUS  shift, and go to state 118
    SUB   shift, and go to state 119
    MULT  shift, and go to state 120
    DIV   shift, and go to state 121
    EXP   shift, and go to state 122
    REM   shift, and go to state 123

    $default  reduce using rule 169 (shift-expr)


State 217

   21 assign-expr: vet-idx assignment expr .
   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  158 arit-expr: expr . PLUS expr
  159          | expr . SUB expr
  160          | expr . MULT expr
  161          | expr . DIV expr
  162          | expr . EXP expr
  163          | expr . REM expr
  164 bitw-expr: expr . BITWISE_AND expr
  165          | expr . BITWISE_OR expr
  166          | expr . BITWISE_XOR expr
  167 shift-expr: expr . LSHIFT expr
  168           | expr . RSHIFT expr
  169           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 118
    SUB              shift, and go to state 119
    MULT             shift, and go to state 120
    DIV              shift, and go to state 121
    EXP              shift, and go to state 122
    REM              shift, and go to state 123
    BITWISE_AND      shift, and go to state 124
    BITWISE_OR       shift, and go to state 125
    BITWISE_XOR      shift, and go to state 126
    LOGICAL_NULL     shift, and go to state 127
    LOGICAL_AND      shift, and go to state 128
    LOGICAL_OR       shift, and go to state 129
    EQ               shift, and go to state 130
    EQ_STRICT        shift, and go to state 131
    INEQ             shift, and go to state 132
    INEQ_STRICT      shift, and go to state 133
    LT               shift, and go to state 134
    LT_EQ            shift, and go to state 135
    GT               shift, and go to state 136
    GT_EQ            shift, and go to state 137
    LSHIFT           shift, and go to state 138
    RSHIFT           shift, and go to state 139
    RSHIFT_UNSIGNED  shift, and go to state 140

    $default  reduce using rule 21 (assign-expr)


State 218

  171 var-att: var-att DOT ID .
  177 var-met: ID . LPAR args-list RPAR

    LPAR  shift, and go to state 147

    $default  reduce using rule 171 (var-att)


State 219

  175 var-att: var-att DOT var-met .

    $default  reduce using rule 175 (var-att)


State 220

   19 assign-expr: var-att assignment expr .
   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  158 arit-expr: expr . PLUS expr
  159          | expr . SUB expr
  160          | expr . MULT expr
  161          | expr . DIV expr
  162          | expr . EXP expr
  163          | expr . REM expr
  164 bitw-expr: expr . BITWISE_AND expr
  165          | expr . BITWISE_OR expr
  166          | expr . BITWISE_XOR expr
  167 shift-expr: expr . LSHIFT expr
  168           | expr . RSHIFT expr
  169           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 118
    SUB              shift, and go to state 119
    MULT             shift, and go to state 120
    DIV              shift, and go to state 121
    EXP              shift, and go to state 122
    REM              shift, and go to state 123
    BITWISE_AND      shift, and go to state 124
    BITWISE_OR       shift, and go to state 125
    BITWISE_XOR      shift, and go to state 126
    LOGICAL_NULL     shift, and go to state 127
    LOGICAL_AND      shift, and go to state 128
    LOGICAL_OR       shift, and go to state 129
    EQ               shift, and go to state 130
    EQ_STRICT        shift, and go to state 131
    INEQ             shift, and go to state 132
    INEQ_STRICT      shift, and go to state 133
    LT               shift, and go to state 134
    LT_EQ            shift, and go to state 135
    GT               shift, and go to state 136
    GT_EQ            shift, and go to state 137
    LSHIFT           shift, and go to state 138
    RSHIFT           shift, and go to state 139
    RSHIFT_UNSIGNED  shift, and go to state 140

    $default  reduce using rule 19 (assign-expr)


State 221

  170 var-att: ID . DOT var-att
  172        | ID . DOT var-met
  173        | var-met DOT ID .
  176        | ID . DOT ID
  177 var-met: ID . LPAR args-list RPAR

    DOT   shift, and go to state 74
    LPAR  shift, and go to state 147

    $default  reduce using rule 173 (var-att)


State 222

  171 var-att: var-att . DOT ID
  174        | var-met DOT var-att .
  175        | var-att . DOT var-met

    DOT  shift, and go to state 142

    $default  reduce using rule 174 (var-att)


State 223

  177 var-met: ID LPAR args-list . RPAR

    RPAR  shift, and go to state 265


State 224

  202 elmts-list: var-val COMMA elmts-list .

    $default  reduce using rule 202 (elmts-list)


State 225

  185 var-obj: ID LT var-type GT . LPAR args-list RPAR

    LPAR  shift, and go to state 266


State 226

  178 args-list: COMMA args-list .

    $default  reduce using rule 178 (args-list)


State 227

  180 args-list: assign-expr COMMA . args-list

    COMMA        shift, and go to state 164
    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 183 (args-list)

    assign-expr      go to state 165
    logic-expr       go to state 38
    expr             go to state 166
    idx-unsafe-expr  go to state 43
    idx-safe-expr    go to state 44
    vet-idx          go to state 45
    unary-expr       go to state 46
    arit-expr        go to state 47
    bitw-expr        go to state 48
    shift-expr       go to state 49
    var-att          go to state 50
    var-met          go to state 51
    args-list        go to state 267
    var-obj          go to state 52
    var-val          go to state 53
    array-expr       go to state 54


State 228

  179 args-list: expr COMMA . args-list

    COMMA        shift, and go to state 164
    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 183 (args-list)

    assign-expr      go to state 165
    logic-expr       go to state 38
    expr             go to state 166
    idx-unsafe-expr  go to state 43
    idx-safe-expr    go to state 44
    vet-idx          go to state 45
    unary-expr       go to state 46
    arit-expr        go to state 47
    bitw-expr        go to state 48
    shift-expr       go to state 49
    var-att          go to state 50
    var-met          go to state 51
    args-list        go to state 268
    var-obj          go to state 52
    var-val          go to state 53
    array-expr       go to state 54


State 229

  177 var-met: ID LPAR args-list RPAR .
  184 var-obj: ID LPAR args-list RPAR .

    DOT       reduce using rule 177 (var-met)
    $default  reduce using rule 184 (var-obj)


State 230

  147 vet-idx: ID LBRACKET idx-safe-expr RBRACKET .

    $default  reduce using rule 147 (vet-idx)


State 231

   79 class-att-list: SEMI . class-att-list

    SEMI       shift, and go to state 231
    ID         shift, and go to state 232
    PRIVATE    shift, and go to state 233
    PROTECTED  shift, and go to state 234
    PUBLIC     shift, and go to state 235

    $default  reduce using rule 82 (class-att-list)

    class-att-list  go to state 269
    class-att       go to state 237
    access-modif    go to state 238


State 232

   83 class-att: ID . COLON var-type
   85          | ID . LPAR params RPAR LBRACE line RBRACE
   86          | ID . LPAR params RPAR COLON var-type LBRACE line RBRACE

    COLON  shift, and go to state 270
    LPAR   shift, and go to state 271


State 233

   88 access-modif: PRIVATE .

    $default  reduce using rule 88 (access-modif)


State 234

   89 access-modif: PROTECTED .

    $default  reduce using rule 89 (access-modif)


State 235

   87 access-modif: PUBLIC .

    $default  reduce using rule 87 (access-modif)


State 236

   78 class-def: CLASS ID LBRACE class-att-list . RBRACE

    RBRACE  shift, and go to state 272


State 237

   80 class-att-list: class-att . SEMI class-att-list
   81               | class-att .

    SEMI  shift, and go to state 273

    $default  reduce using rule 81 (class-att-list)


State 238

   84 class-att: access-modif . ID COLON var-type

    ID  shift, and go to state 274


State 239

  118 id-list: ID . COMMA id-list
  119        | ID .

    COMMA  shift, and go to state 172

    $default  reduce using rule 119 (id-list)


State 240

  118 id-list: ID COMMA id-list .

    $default  reduce using rule 118 (id-list)


State 241

  115 var-declr: CONST_RW ID COLON var-type . ASSIGN expr
  116          | CONST_RW ID COLON var-type . LBRACKET RBRACKET ASSIGN expr

    ASSIGN    shift, and go to state 275
    LBRACKET  shift, and go to state 276


State 242

  120 obj-def: LBRACE . obj-att-list RBRACE

    COMMA  shift, and go to state 277
    ID     shift, and go to state 278

    $default  reduce using rule 124 (obj-att-list)

    obj-att-list  go to state 279
    obj-att       go to state 280


State 243

  117 var-declr: CONST_RW id-list ASSIGN obj-def .

    $default  reduce using rule 117 (var-declr)


State 244

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  114 var-declr: CONST_RW id-list ASSIGN expr .
  158 arit-expr: expr . PLUS expr
  159          | expr . SUB expr
  160          | expr . MULT expr
  161          | expr . DIV expr
  162          | expr . EXP expr
  163          | expr . REM expr
  164 bitw-expr: expr . BITWISE_AND expr
  165          | expr . BITWISE_OR expr
  166          | expr . BITWISE_XOR expr
  167 shift-expr: expr . LSHIFT expr
  168           | expr . RSHIFT expr
  169           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 118
    SUB              shift, and go to state 119
    MULT             shift, and go to state 120
    DIV              shift, and go to state 121
    EXP              shift, and go to state 122
    REM              shift, and go to state 123
    BITWISE_AND      shift, and go to state 124
    BITWISE_OR       shift, and go to state 125
    BITWISE_XOR      shift, and go to state 126
    LOGICAL_NULL     shift, and go to state 127
    LOGICAL_AND      shift, and go to state 128
    LOGICAL_OR       shift, and go to state 129
    EQ               shift, and go to state 130
    EQ_STRICT        shift, and go to state 131
    INEQ             shift, and go to state 132
    INEQ_STRICT      shift, and go to state 133
    LT               shift, and go to state 134
    LT_EQ            shift, and go to state 135
    GT               shift, and go to state 136
    GT_EQ            shift, and go to state 137
    LSHIFT           shift, and go to state 138
    RSHIFT           shift, and go to state 139
    RSHIFT_UNSIGNED  shift, and go to state 140

    $default  reduce using rule 114 (var-declr)


State 245

   56 do-while-stmt: DO LBRACE line RBRACE . WHILE LPAR expr RPAR
   57              | DO LBRACE line RBRACE . WHILE LPAR assign-expr RPAR

    WHILE  shift, and go to state 281


State 246

   37 for-stmt: FOR LPAR SEMI SEMI . expr RPAR LBRACE line RBRACE
   38         | FOR LPAR SEMI SEMI . assign-expr RPAR LBRACE line RBRACE
   39         | FOR LPAR SEMI SEMI . RPAR LBRACE line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    RPAR         shift, and go to state 282
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    assign-expr      go to state 283
    logic-expr       go to state 38
    expr             go to state 284
    idx-unsafe-expr  go to state 43
    idx-safe-expr    go to state 44
    vet-idx          go to state 45
    unary-expr       go to state 46
    arit-expr        go to state 47
    bitw-expr        go to state 48
    shift-expr       go to state 49
    var-att          go to state 50
    var-met          go to state 51
    var-obj          go to state 52
    var-val          go to state 53
    array-expr       go to state 54


State 247

   34 for-stmt: FOR LPAR SEMI expr . SEMI expr RPAR LBRACE line RBRACE
   35         | FOR LPAR SEMI expr . SEMI assign-expr RPAR LBRACE line RBRACE
   36         | FOR LPAR SEMI expr . SEMI RPAR LBRACE line RBRACE
   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  158 arit-expr: expr . PLUS expr
  159          | expr . SUB expr
  160          | expr . MULT expr
  161          | expr . DIV expr
  162          | expr . EXP expr
  163          | expr . REM expr
  164 bitw-expr: expr . BITWISE_AND expr
  165          | expr . BITWISE_OR expr
  166          | expr . BITWISE_XOR expr
  167 shift-expr: expr . LSHIFT expr
  168           | expr . RSHIFT expr
  169           | expr . RSHIFT_UNSIGNED expr

    SEMI             shift, and go to state 285
    PLUS             shift, and go to state 118
    SUB              shift, and go to state 119
    MULT             shift, and go to state 120
    DIV              shift, and go to state 121
    EXP              shift, and go to state 122
    REM              shift, and go to state 123
    BITWISE_AND      shift, and go to state 124
    BITWISE_OR       shift, and go to state 125
    BITWISE_XOR      shift, and go to state 126
    LOGICAL_NULL     shift, and go to state 127
    LOGICAL_AND      shift, and go to state 128
    LOGICAL_OR       shift, and go to state 129
    EQ               shift, and go to state 130
    EQ_STRICT        shift, and go to state 131
    INEQ             shift, and go to state 132
    INEQ_STRICT      shift, and go to state 133
    LT               shift, and go to state 134
    LT_EQ            shift, and go to state 135
    GT               shift, and go to state 136
    GT_EQ            shift, and go to state 137
    LSHIFT           shift, and go to state 138
    RSHIFT           shift, and go to state 139
    RSHIFT_UNSIGNED  shift, and go to state 140


State 248

   22 for-stmt: FOR LPAR assign-expr SEMI . expr SEMI expr RPAR LBRACE line RBRACE
   23         | FOR LPAR assign-expr SEMI . expr SEMI assign-expr RPAR LBRACE line RBRACE
   24         | FOR LPAR assign-expr SEMI . expr SEMI RPAR LBRACE line RBRACE
   25         | FOR LPAR assign-expr SEMI . SEMI expr RPAR LBRACE line RBRACE
   26         | FOR LPAR assign-expr SEMI . SEMI assign-expr RPAR LBRACE line RBRACE
   27         | FOR LPAR assign-expr SEMI . SEMI RPAR LBRACE line RBRACE

    SEMI         shift, and go to state 286
    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 64
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 38
    expr             go to state 287
    idx-unsafe-expr  go to state 43
    idx-safe-expr    go to state 44
    vet-idx          go to state 66
    unary-expr       go to state 46
    arit-expr        go to state 47
    bitw-expr        go to state 48
    shift-expr       go to state 49
    var-att          go to state 67
    var-met          go to state 51
    var-obj          go to state 52
    var-val          go to state 53
    array-expr       go to state 54


State 249

   28 for-stmt: FOR LPAR var-declr SEMI . expr SEMI expr RPAR LBRACE line RBRACE
   29         | FOR LPAR var-declr SEMI . expr SEMI assign-expr RPAR LBRACE line RBRACE
   30         | FOR LPAR var-declr SEMI . expr SEMI RPAR LBRACE line RBRACE
   31         | FOR LPAR var-declr SEMI . SEMI expr RPAR LBRACE line RBRACE
   32         | FOR LPAR var-declr SEMI . SEMI assign-expr RPAR LBRACE line RBRACE
   33         | FOR LPAR var-declr SEMI . SEMI RPAR LBRACE line RBRACE

    SEMI         shift, and go to state 288
    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 64
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 38
    expr             go to state 289
    idx-unsafe-expr  go to state 43
    idx-safe-expr    go to state 44
    vet-idx          go to state 66
    unary-expr       go to state 46
    arit-expr        go to state 47
    bitw-expr        go to state 48
    shift-expr       go to state 49
    var-att          go to state 67
    var-met          go to state 51
    var-obj          go to state 52
    var-val          go to state 53
    array-expr       go to state 54


State 250

   92 params: COMMA . ID
   93       | COMMA . ID COLON var-type

    ID  shift, and go to state 290


State 251

   94 params: ID . COMMA ID
   95       | ID . COLON var-type COMMA ID COLON var-type
   96       | ID . COLON var-type COMMA ID
   97       | ID . COLON var-type
   98       | ID . COMMA ID COLON var-type

    COMMA  shift, and go to state 291
    COLON  shift, and go to state 292


State 252

   90 func-def: FUNCTION ID LPAR params . RPAR LBRACE line RBRACE
   91         | FUNCTION ID LPAR params . RPAR COLON var-type LBRACE line RBRACE

    RPAR  shift, and go to state 293


State 253

   63 if-stmt: IF LPAR assign-expr RPAR . LBRACE line RBRACE
   64        | IF LPAR assign-expr RPAR . LBRACE line RBRACE ELSE LBRACE line RBRACE
   65        | IF LPAR assign-expr RPAR . LBRACE line RBRACE ELSE stmt

    LBRACE  shift, and go to state 294


State 254

   60 if-stmt: IF LPAR expr RPAR . LBRACE line RBRACE
   61        | IF LPAR expr RPAR . LBRACE line RBRACE ELSE LBRACE line RBRACE
   62        | IF LPAR expr RPAR . LBRACE line RBRACE ELSE stmt

    LBRACE  shift, and go to state 295


State 255

  103 var-declr: LET ID COLON var-type .
  104          | LET ID COLON var-type . ASSIGN expr
  105          | LET ID COLON var-type . LBRACKET RBRACKET
  106          | LET ID COLON var-type . LBRACKET RBRACKET ASSIGN expr

    ASSIGN    shift, and go to state 296
    LBRACKET  shift, and go to state 297

    $default  reduce using rule 103 (var-declr)


State 256

  102 var-declr: LET id-list ASSIGN obj-def .

    $default  reduce using rule 102 (var-declr)


State 257

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  101 var-declr: LET id-list ASSIGN expr .
  158 arit-expr: expr . PLUS expr
  159          | expr . SUB expr
  160          | expr . MULT expr
  161          | expr . DIV expr
  162          | expr . EXP expr
  163          | expr . REM expr
  164 bitw-expr: expr . BITWISE_AND expr
  165          | expr . BITWISE_OR expr
  166          | expr . BITWISE_XOR expr
  167 shift-expr: expr . LSHIFT expr
  168           | expr . RSHIFT expr
  169           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 118
    SUB              shift, and go to state 119
    MULT             shift, and go to state 120
    DIV              shift, and go to state 121
    EXP              shift, and go to state 122
    REM              shift, and go to state 123
    BITWISE_AND      shift, and go to state 124
    BITWISE_OR       shift, and go to state 125
    BITWISE_XOR      shift, and go to state 126
    LOGICAL_NULL     shift, and go to state 127
    LOGICAL_AND      shift, and go to state 128
    LOGICAL_OR       shift, and go to state 129
    EQ               shift, and go to state 130
    EQ_STRICT        shift, and go to state 131
    INEQ             shift, and go to state 132
    INEQ_STRICT      shift, and go to state 133
    LT               shift, and go to state 134
    LT_EQ            shift, and go to state 135
    GT               shift, and go to state 136
    GT_EQ            shift, and go to state 137
    LSHIFT           shift, and go to state 138
    RSHIFT           shift, and go to state 139
    RSHIFT_UNSIGNED  shift, and go to state 140

    $default  reduce using rule 101 (var-declr)


State 258

  187 var-obj: NEW ID LT var-type . GT LPAR args-list RPAR

    GT  shift, and go to state 298


State 259

  186 var-obj: NEW ID LPAR args-list . RPAR

    RPAR  shift, and go to state 299


State 260

  110 var-declr: VAR ID COLON var-type .
  111          | VAR ID COLON var-type . ASSIGN expr
  112          | VAR ID COLON var-type . LBRACKET RBRACKET
  113          | VAR ID COLON var-type . LBRACKET RBRACKET ASSIGN expr

    ASSIGN    shift, and go to state 300
    LBRACKET  shift, and go to state 301

    $default  reduce using rule 110 (var-declr)


State 261

  109 var-declr: VAR id-list ASSIGN obj-def .

    $default  reduce using rule 109 (var-declr)


State 262

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  108 var-declr: VAR id-list ASSIGN expr .
  158 arit-expr: expr . PLUS expr
  159          | expr . SUB expr
  160          | expr . MULT expr
  161          | expr . DIV expr
  162          | expr . EXP expr
  163          | expr . REM expr
  164 bitw-expr: expr . BITWISE_AND expr
  165          | expr . BITWISE_OR expr
  166          | expr . BITWISE_XOR expr
  167 shift-expr: expr . LSHIFT expr
  168           | expr . RSHIFT expr
  169           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 118
    SUB              shift, and go to state 119
    MULT             shift, and go to state 120
    DIV              shift, and go to state 121
    EXP              shift, and go to state 122
    REM              shift, and go to state 123
    BITWISE_AND      shift, and go to state 124
    BITWISE_OR       shift, and go to state 125
    BITWISE_XOR      shift, and go to state 126
    LOGICAL_NULL     shift, and go to state 127
    LOGICAL_AND      shift, and go to state 128
    LOGICAL_OR       shift, and go to state 129
    EQ               shift, and go to state 130
    EQ_STRICT        shift, and go to state 131
    INEQ             shift, and go to state 132
    INEQ_STRICT      shift, and go to state 133
    LT               shift, and go to state 134
    LT_EQ            shift, and go to state 135
    GT               shift, and go to state 136
    GT_EQ            shift, and go to state 137
    LSHIFT           shift, and go to state 138
    RSHIFT           shift, and go to state 139
    RSHIFT_UNSIGNED  shift, and go to state 140

    $default  reduce using rule 108 (var-declr)


State 263

   59 while-stmt: WHILE LPAR assign-expr RPAR . LBRACE line RBRACE

    LBRACE  shift, and go to state 302


State 264

   58 while-stmt: WHILE LPAR expr RPAR . LBRACE line RBRACE

    LBRACE  shift, and go to state 303


State 265

  177 var-met: ID LPAR args-list RPAR .

    $default  reduce using rule 177 (var-met)


State 266

  185 var-obj: ID LT var-type GT LPAR . args-list RPAR

    COMMA        shift, and go to state 164
    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 183 (args-list)

    assign-expr      go to state 165
    logic-expr       go to state 38
    expr             go to state 166
    idx-unsafe-expr  go to state 43
    idx-safe-expr    go to state 44
    vet-idx          go to state 45
    unary-expr       go to state 46
    arit-expr        go to state 47
    bitw-expr        go to state 48
    shift-expr       go to state 49
    var-att          go to state 50
    var-met          go to state 51
    args-list        go to state 304
    var-obj          go to state 52
    var-val          go to state 53
    array-expr       go to state 54


State 267

  180 args-list: assign-expr COMMA args-list .

    $default  reduce using rule 180 (args-list)


State 268

  179 args-list: expr COMMA args-list .

    $default  reduce using rule 179 (args-list)


State 269

   79 class-att-list: SEMI class-att-list .

    $default  reduce using rule 79 (class-att-list)


State 270

   83 class-att: ID COLON . var-type

    VOID_RW   shift, and go to state 155
    ANY       shift, and go to state 156
    BOOLTYPE  shift, and go to state 157
    NEVER     shift, and go to state 158
    NUMBER    shift, and go to state 159
    STRING    shift, and go to state 160
    UNKNOWN   shift, and go to state 161

    var-type  go to state 305


State 271

   85 class-att: ID LPAR . params RPAR LBRACE line RBRACE
   86          | ID LPAR . params RPAR COLON var-type LBRACE line RBRACE

    COMMA  shift, and go to state 250
    ID     shift, and go to state 251

    $default  reduce using rule 99 (params)

    params  go to state 306


State 272

   78 class-def: CLASS ID LBRACE class-att-list RBRACE .

    $default  reduce using rule 78 (class-def)


State 273

   80 class-att-list: class-att SEMI . class-att-list

    SEMI       shift, and go to state 231
    ID         shift, and go to state 232
    PRIVATE    shift, and go to state 233
    PROTECTED  shift, and go to state 234
    PUBLIC     shift, and go to state 235

    $default  reduce using rule 82 (class-att-list)

    class-att-list  go to state 307
    class-att       go to state 237
    access-modif    go to state 238


State 274

   84 class-att: access-modif ID . COLON var-type

    COLON  shift, and go to state 308


State 275

  115 var-declr: CONST_RW ID COLON var-type ASSIGN . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 64
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 38
    expr             go to state 309
    idx-unsafe-expr  go to state 43
    idx-safe-expr    go to state 44
    vet-idx          go to state 66
    unary-expr       go to state 46
    arit-expr        go to state 47
    bitw-expr        go to state 48
    shift-expr       go to state 49
    var-att          go to state 67
    var-met          go to state 51
    var-obj          go to state 52
    var-val          go to state 53
    array-expr       go to state 54


State 276

  116 var-declr: CONST_RW ID COLON var-type LBRACKET . RBRACKET ASSIGN expr

    RBRACKET  shift, and go to state 310


State 277

  121 obj-att-list: COMMA . obj-att-list

    COMMA  shift, and go to state 277
    ID     shift, and go to state 278

    $default  reduce using rule 124 (obj-att-list)

    obj-att-list  go to state 311
    obj-att       go to state 280


State 278

  125 obj-att: ID . COLON var-val

    COLON  shift, and go to state 312


State 279

  120 obj-def: LBRACE obj-att-list . RBRACE

    RBRACE  shift, and go to state 313


State 280

  122 obj-att-list: obj-att . COMMA obj-att-list
  123             | obj-att .

    COMMA  shift, and go to state 314

    $default  reduce using rule 123 (obj-att-list)


State 281

   56 do-while-stmt: DO LBRACE line RBRACE WHILE . LPAR expr RPAR
   57              | DO LBRACE line RBRACE WHILE . LPAR assign-expr RPAR

    LPAR  shift, and go to state 315


State 282

   39 for-stmt: FOR LPAR SEMI SEMI RPAR . LBRACE line RBRACE

    LBRACE  shift, and go to state 316


State 283

   38 for-stmt: FOR LPAR SEMI SEMI assign-expr . RPAR LBRACE line RBRACE

    RPAR  shift, and go to state 317


State 284

   37 for-stmt: FOR LPAR SEMI SEMI expr . RPAR LBRACE line RBRACE
   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  158 arit-expr: expr . PLUS expr
  159          | expr . SUB expr
  160          | expr . MULT expr
  161          | expr . DIV expr
  162          | expr . EXP expr
  163          | expr . REM expr
  164 bitw-expr: expr . BITWISE_AND expr
  165          | expr . BITWISE_OR expr
  166          | expr . BITWISE_XOR expr
  167 shift-expr: expr . LSHIFT expr
  168           | expr . RSHIFT expr
  169           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 118
    SUB              shift, and go to state 119
    MULT             shift, and go to state 120
    DIV              shift, and go to state 121
    EXP              shift, and go to state 122
    REM              shift, and go to state 123
    BITWISE_AND      shift, and go to state 124
    BITWISE_OR       shift, and go to state 125
    BITWISE_XOR      shift, and go to state 126
    LOGICAL_NULL     shift, and go to state 127
    LOGICAL_AND      shift, and go to state 128
    LOGICAL_OR       shift, and go to state 129
    EQ               shift, and go to state 130
    EQ_STRICT        shift, and go to state 131
    INEQ             shift, and go to state 132
    INEQ_STRICT      shift, and go to state 133
    LT               shift, and go to state 134
    LT_EQ            shift, and go to state 135
    GT               shift, and go to state 136
    GT_EQ            shift, and go to state 137
    LSHIFT           shift, and go to state 138
    RSHIFT           shift, and go to state 139
    RSHIFT_UNSIGNED  shift, and go to state 140
    RPAR             shift, and go to state 318


State 285

   34 for-stmt: FOR LPAR SEMI expr SEMI . expr RPAR LBRACE line RBRACE
   35         | FOR LPAR SEMI expr SEMI . assign-expr RPAR LBRACE line RBRACE
   36         | FOR LPAR SEMI expr SEMI . RPAR LBRACE line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    RPAR         shift, and go to state 319
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    assign-expr      go to state 320
    logic-expr       go to state 38
    expr             go to state 321
    idx-unsafe-expr  go to state 43
    idx-safe-expr    go to state 44
    vet-idx          go to state 45
    unary-expr       go to state 46
    arit-expr        go to state 47
    bitw-expr        go to state 48
    shift-expr       go to state 49
    var-att          go to state 50
    var-met          go to state 51
    var-obj          go to state 52
    var-val          go to state 53
    array-expr       go to state 54


State 286

   25 for-stmt: FOR LPAR assign-expr SEMI SEMI . expr RPAR LBRACE line RBRACE
   26         | FOR LPAR assign-expr SEMI SEMI . assign-expr RPAR LBRACE line RBRACE
   27         | FOR LPAR assign-expr SEMI SEMI . RPAR LBRACE line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    RPAR         shift, and go to state 322
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    assign-expr      go to state 323
    logic-expr       go to state 38
    expr             go to state 324
    idx-unsafe-expr  go to state 43
    idx-safe-expr    go to state 44
    vet-idx          go to state 45
    unary-expr       go to state 46
    arit-expr        go to state 47
    bitw-expr        go to state 48
    shift-expr       go to state 49
    var-att          go to state 50
    var-met          go to state 51
    var-obj          go to state 52
    var-val          go to state 53
    array-expr       go to state 54


State 287

   22 for-stmt: FOR LPAR assign-expr SEMI expr . SEMI expr RPAR LBRACE line RBRACE
   23         | FOR LPAR assign-expr SEMI expr . SEMI assign-expr RPAR LBRACE line RBRACE
   24         | FOR LPAR assign-expr SEMI expr . SEMI RPAR LBRACE line RBRACE
   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  158 arit-expr: expr . PLUS expr
  159          | expr . SUB expr
  160          | expr . MULT expr
  161          | expr . DIV expr
  162          | expr . EXP expr
  163          | expr . REM expr
  164 bitw-expr: expr . BITWISE_AND expr
  165          | expr . BITWISE_OR expr
  166          | expr . BITWISE_XOR expr
  167 shift-expr: expr . LSHIFT expr
  168           | expr . RSHIFT expr
  169           | expr . RSHIFT_UNSIGNED expr

    SEMI             shift, and go to state 325
    PLUS             shift, and go to state 118
    SUB              shift, and go to state 119
    MULT             shift, and go to state 120
    DIV              shift, and go to state 121
    EXP              shift, and go to state 122
    REM              shift, and go to state 123
    BITWISE_AND      shift, and go to state 124
    BITWISE_OR       shift, and go to state 125
    BITWISE_XOR      shift, and go to state 126
    LOGICAL_NULL     shift, and go to state 127
    LOGICAL_AND      shift, and go to state 128
    LOGICAL_OR       shift, and go to state 129
    EQ               shift, and go to state 130
    EQ_STRICT        shift, and go to state 131
    INEQ             shift, and go to state 132
    INEQ_STRICT      shift, and go to state 133
    LT               shift, and go to state 134
    LT_EQ            shift, and go to state 135
    GT               shift, and go to state 136
    GT_EQ            shift, and go to state 137
    LSHIFT           shift, and go to state 138
    RSHIFT           shift, and go to state 139
    RSHIFT_UNSIGNED  shift, and go to state 140


State 288

   31 for-stmt: FOR LPAR var-declr SEMI SEMI . expr RPAR LBRACE line RBRACE
   32         | FOR LPAR var-declr SEMI SEMI . assign-expr RPAR LBRACE line RBRACE
   33         | FOR LPAR var-declr SEMI SEMI . RPAR LBRACE line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    RPAR         shift, and go to state 326
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    assign-expr      go to state 327
    logic-expr       go to state 38
    expr             go to state 328
    idx-unsafe-expr  go to state 43
    idx-safe-expr    go to state 44
    vet-idx          go to state 45
    unary-expr       go to state 46
    arit-expr        go to state 47
    bitw-expr        go to state 48
    shift-expr       go to state 49
    var-att          go to state 50
    var-met          go to state 51
    var-obj          go to state 52
    var-val          go to state 53
    array-expr       go to state 54


State 289

   28 for-stmt: FOR LPAR var-declr SEMI expr . SEMI expr RPAR LBRACE line RBRACE
   29         | FOR LPAR var-declr SEMI expr . SEMI assign-expr RPAR LBRACE line RBRACE
   30         | FOR LPAR var-declr SEMI expr . SEMI RPAR LBRACE line RBRACE
   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  158 arit-expr: expr . PLUS expr
  159          | expr . SUB expr
  160          | expr . MULT expr
  161          | expr . DIV expr
  162          | expr . EXP expr
  163          | expr . REM expr
  164 bitw-expr: expr . BITWISE_AND expr
  165          | expr . BITWISE_OR expr
  166          | expr . BITWISE_XOR expr
  167 shift-expr: expr . LSHIFT expr
  168           | expr . RSHIFT expr
  169           | expr . RSHIFT_UNSIGNED expr

    SEMI             shift, and go to state 329
    PLUS             shift, and go to state 118
    SUB              shift, and go to state 119
    MULT             shift, and go to state 120
    DIV              shift, and go to state 121
    EXP              shift, and go to state 122
    REM              shift, and go to state 123
    BITWISE_AND      shift, and go to state 124
    BITWISE_OR       shift, and go to state 125
    BITWISE_XOR      shift, and go to state 126
    LOGICAL_NULL     shift, and go to state 127
    LOGICAL_AND      shift, and go to state 128
    LOGICAL_OR       shift, and go to state 129
    EQ               shift, and go to state 130
    EQ_STRICT        shift, and go to state 131
    INEQ             shift, and go to state 132
    INEQ_STRICT      shift, and go to state 133
    LT               shift, and go to state 134
    LT_EQ            shift, and go to state 135
    GT               shift, and go to state 136
    GT_EQ            shift, and go to state 137
    LSHIFT           shift, and go to state 138
    RSHIFT           shift, and go to state 139
    RSHIFT_UNSIGNED  shift, and go to state 140


State 290

   92 params: COMMA ID .
   93       | COMMA ID . COLON var-type

    COLON  shift, and go to state 330

    $default  reduce using rule 92 (params)


State 291

   94 params: ID COMMA . ID
   98       | ID COMMA . ID COLON var-type

    ID  shift, and go to state 331


State 292

   95 params: ID COLON . var-type COMMA ID COLON var-type
   96       | ID COLON . var-type COMMA ID
   97       | ID COLON . var-type

    VOID_RW   shift, and go to state 155
    ANY       shift, and go to state 156
    BOOLTYPE  shift, and go to state 157
    NEVER     shift, and go to state 158
    NUMBER    shift, and go to state 159
    STRING    shift, and go to state 160
    UNKNOWN   shift, and go to state 161

    var-type  go to state 332


State 293

   90 func-def: FUNCTION ID LPAR params RPAR . LBRACE line RBRACE
   91         | FUNCTION ID LPAR params RPAR . COLON var-type LBRACE line RBRACE

    COLON   shift, and go to state 333
    LBRACE  shift, and go to state 334


State 294

   63 if-stmt: IF LPAR assign-expr RPAR LBRACE . line RBRACE
   64        | IF LPAR assign-expr RPAR LBRACE . line RBRACE ELSE LBRACE line RBRACE
   65        | IF LPAR assign-expr RPAR LBRACE . line RBRACE ELSE stmt

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 3 (line)

    line             go to state 335
    stmt-list        go to state 31
    stmt             go to state 32
    assign-expr      go to state 33
    for-stmt         go to state 34
    do-while-stmt    go to state 35
    while-stmt       go to state 36
    if-stmt          go to state 37
    logic-expr       go to state 38
    class-def        go to state 39
    func-def         go to state 40
    var-declr        go to state 41
    expr             go to state 42
    idx-unsafe-expr  go to state 43
    idx-safe-expr    go to state 44
    vet-idx          go to state 45
    unary-expr       go to state 46
    arit-expr        go to state 47
    bitw-expr        go to state 48
    shift-expr       go to state 49
    var-att          go to state 50
    var-met          go to state 51
    var-obj          go to state 52
    var-val          go to state 53
    array-expr       go to state 54


State 295

   60 if-stmt: IF LPAR expr RPAR LBRACE . line RBRACE
   61        | IF LPAR expr RPAR LBRACE . line RBRACE ELSE LBRACE line RBRACE
   62        | IF LPAR expr RPAR LBRACE . line RBRACE ELSE stmt

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 3 (line)

    line             go to state 336
    stmt-list        go to state 31
    stmt             go to state 32
    assign-expr      go to state 33
    for-stmt         go to state 34
    do-while-stmt    go to state 35
    while-stmt       go to state 36
    if-stmt          go to state 37
    logic-expr       go to state 38
    class-def        go to state 39
    func-def         go to state 40
    var-declr        go to state 41
    expr             go to state 42
    idx-unsafe-expr  go to state 43
    idx-safe-expr    go to state 44
    vet-idx          go to state 45
    unary-expr       go to state 46
    arit-expr        go to state 47
    bitw-expr        go to state 48
    shift-expr       go to state 49
    var-att          go to state 50
    var-met          go to state 51
    var-obj          go to state 52
    var-val          go to state 53
    array-expr       go to state 54


State 296

  104 var-declr: LET ID COLON var-type ASSIGN . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 64
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 38
    expr             go to state 337
    idx-unsafe-expr  go to state 43
    idx-safe-expr    go to state 44
    vet-idx          go to state 66
    unary-expr       go to state 46
    arit-expr        go to state 47
    bitw-expr        go to state 48
    shift-expr       go to state 49
    var-att          go to state 67
    var-met          go to state 51
    var-obj          go to state 52
    var-val          go to state 53
    array-expr       go to state 54


State 297

  105 var-declr: LET ID COLON var-type LBRACKET . RBRACKET
  106          | LET ID COLON var-type LBRACKET . RBRACKET ASSIGN expr

    RBRACKET  shift, and go to state 338


State 298

  187 var-obj: NEW ID LT var-type GT . LPAR args-list RPAR

    LPAR  shift, and go to state 339


State 299

  186 var-obj: NEW ID LPAR args-list RPAR .

    $default  reduce using rule 186 (var-obj)


State 300

  111 var-declr: VAR ID COLON var-type ASSIGN . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 64
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 38
    expr             go to state 340
    idx-unsafe-expr  go to state 43
    idx-safe-expr    go to state 44
    vet-idx          go to state 66
    unary-expr       go to state 46
    arit-expr        go to state 47
    bitw-expr        go to state 48
    shift-expr       go to state 49
    var-att          go to state 67
    var-met          go to state 51
    var-obj          go to state 52
    var-val          go to state 53
    array-expr       go to state 54


State 301

  112 var-declr: VAR ID COLON var-type LBRACKET . RBRACKET
  113          | VAR ID COLON var-type LBRACKET . RBRACKET ASSIGN expr

    RBRACKET  shift, and go to state 341


State 302

   59 while-stmt: WHILE LPAR assign-expr RPAR LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 3 (line)

    line             go to state 342
    stmt-list        go to state 31
    stmt             go to state 32
    assign-expr      go to state 33
    for-stmt         go to state 34
    do-while-stmt    go to state 35
    while-stmt       go to state 36
    if-stmt          go to state 37
    logic-expr       go to state 38
    class-def        go to state 39
    func-def         go to state 40
    var-declr        go to state 41
    expr             go to state 42
    idx-unsafe-expr  go to state 43
    idx-safe-expr    go to state 44
    vet-idx          go to state 45
    unary-expr       go to state 46
    arit-expr        go to state 47
    bitw-expr        go to state 48
    shift-expr       go to state 49
    var-att          go to state 50
    var-met          go to state 51
    var-obj          go to state 52
    var-val          go to state 53
    array-expr       go to state 54


State 303

   58 while-stmt: WHILE LPAR expr RPAR LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 3 (line)

    line             go to state 343
    stmt-list        go to state 31
    stmt             go to state 32
    assign-expr      go to state 33
    for-stmt         go to state 34
    do-while-stmt    go to state 35
    while-stmt       go to state 36
    if-stmt          go to state 37
    logic-expr       go to state 38
    class-def        go to state 39
    func-def         go to state 40
    var-declr        go to state 41
    expr             go to state 42
    idx-unsafe-expr  go to state 43
    idx-safe-expr    go to state 44
    vet-idx          go to state 45
    unary-expr       go to state 46
    arit-expr        go to state 47
    bitw-expr        go to state 48
    shift-expr       go to state 49
    var-att          go to state 50
    var-met          go to state 51
    var-obj          go to state 52
    var-val          go to state 53
    array-expr       go to state 54


State 304

  185 var-obj: ID LT var-type GT LPAR args-list . RPAR

    RPAR  shift, and go to state 344


State 305

   83 class-att: ID COLON var-type .

    $default  reduce using rule 83 (class-att)


State 306

   85 class-att: ID LPAR params . RPAR LBRACE line RBRACE
   86          | ID LPAR params . RPAR COLON var-type LBRACE line RBRACE

    RPAR  shift, and go to state 345


State 307

   80 class-att-list: class-att SEMI class-att-list .

    $default  reduce using rule 80 (class-att-list)


State 308

   84 class-att: access-modif ID COLON . var-type

    VOID_RW   shift, and go to state 155
    ANY       shift, and go to state 156
    BOOLTYPE  shift, and go to state 157
    NEVER     shift, and go to state 158
    NUMBER    shift, and go to state 159
    STRING    shift, and go to state 160
    UNKNOWN   shift, and go to state 161

    var-type  go to state 346


State 309

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  115 var-declr: CONST_RW ID COLON var-type ASSIGN expr .
  158 arit-expr: expr . PLUS expr
  159          | expr . SUB expr
  160          | expr . MULT expr
  161          | expr . DIV expr
  162          | expr . EXP expr
  163          | expr . REM expr
  164 bitw-expr: expr . BITWISE_AND expr
  165          | expr . BITWISE_OR expr
  166          | expr . BITWISE_XOR expr
  167 shift-expr: expr . LSHIFT expr
  168           | expr . RSHIFT expr
  169           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 118
    SUB              shift, and go to state 119
    MULT             shift, and go to state 120
    DIV              shift, and go to state 121
    EXP              shift, and go to state 122
    REM              shift, and go to state 123
    BITWISE_AND      shift, and go to state 124
    BITWISE_OR       shift, and go to state 125
    BITWISE_XOR      shift, and go to state 126
    LOGICAL_NULL     shift, and go to state 127
    LOGICAL_AND      shift, and go to state 128
    LOGICAL_OR       shift, and go to state 129
    EQ               shift, and go to state 130
    EQ_STRICT        shift, and go to state 131
    INEQ             shift, and go to state 132
    INEQ_STRICT      shift, and go to state 133
    LT               shift, and go to state 134
    LT_EQ            shift, and go to state 135
    GT               shift, and go to state 136
    GT_EQ            shift, and go to state 137
    LSHIFT           shift, and go to state 138
    RSHIFT           shift, and go to state 139
    RSHIFT_UNSIGNED  shift, and go to state 140

    $default  reduce using rule 115 (var-declr)


State 310

  116 var-declr: CONST_RW ID COLON var-type LBRACKET RBRACKET . ASSIGN expr

    ASSIGN  shift, and go to state 347


State 311

  121 obj-att-list: COMMA obj-att-list .

    $default  reduce using rule 121 (obj-att-list)


State 312

  125 obj-att: ID COLON . var-val

    SUB        shift, and go to state 2
    INT_VAL    shift, and go to state 8
    REAL_VAL   shift, and go to state 9
    STR_VAL    shift, and go to state 10
    FALSE_RW   shift, and go to state 17
    NULL_RW    shift, and go to state 23
    TRUE_RW    shift, and go to state 25
    UNDEFINED  shift, and go to state 28

    var-val  go to state 348


State 313

  120 obj-def: LBRACE obj-att-list RBRACE .

    $default  reduce using rule 120 (obj-def)


State 314

  122 obj-att-list: obj-att COMMA . obj-att-list

    COMMA  shift, and go to state 277
    ID     shift, and go to state 278

    $default  reduce using rule 124 (obj-att-list)

    obj-att-list  go to state 349
    obj-att       go to state 280


State 315

   56 do-while-stmt: DO LBRACE line RBRACE WHILE LPAR . expr RPAR
   57              | DO LBRACE line RBRACE WHILE LPAR . assign-expr RPAR

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    assign-expr      go to state 350
    logic-expr       go to state 38
    expr             go to state 351
    idx-unsafe-expr  go to state 43
    idx-safe-expr    go to state 44
    vet-idx          go to state 45
    unary-expr       go to state 46
    arit-expr        go to state 47
    bitw-expr        go to state 48
    shift-expr       go to state 49
    var-att          go to state 50
    var-met          go to state 51
    var-obj          go to state 52
    var-val          go to state 53
    array-expr       go to state 54


State 316

   39 for-stmt: FOR LPAR SEMI SEMI RPAR LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 3 (line)

    line             go to state 352
    stmt-list        go to state 31
    stmt             go to state 32
    assign-expr      go to state 33
    for-stmt         go to state 34
    do-while-stmt    go to state 35
    while-stmt       go to state 36
    if-stmt          go to state 37
    logic-expr       go to state 38
    class-def        go to state 39
    func-def         go to state 40
    var-declr        go to state 41
    expr             go to state 42
    idx-unsafe-expr  go to state 43
    idx-safe-expr    go to state 44
    vet-idx          go to state 45
    unary-expr       go to state 46
    arit-expr        go to state 47
    bitw-expr        go to state 48
    shift-expr       go to state 49
    var-att          go to state 50
    var-met          go to state 51
    var-obj          go to state 52
    var-val          go to state 53
    array-expr       go to state 54


State 317

   38 for-stmt: FOR LPAR SEMI SEMI assign-expr RPAR . LBRACE line RBRACE

    LBRACE  shift, and go to state 353


State 318

   37 for-stmt: FOR LPAR SEMI SEMI expr RPAR . LBRACE line RBRACE

    LBRACE  shift, and go to state 354


State 319

   36 for-stmt: FOR LPAR SEMI expr SEMI RPAR . LBRACE line RBRACE

    LBRACE  shift, and go to state 355


State 320

   35 for-stmt: FOR LPAR SEMI expr SEMI assign-expr . RPAR LBRACE line RBRACE

    RPAR  shift, and go to state 356


State 321

   34 for-stmt: FOR LPAR SEMI expr SEMI expr . RPAR LBRACE line RBRACE
   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  158 arit-expr: expr . PLUS expr
  159          | expr . SUB expr
  160          | expr . MULT expr
  161          | expr . DIV expr
  162          | expr . EXP expr
  163          | expr . REM expr
  164 bitw-expr: expr . BITWISE_AND expr
  165          | expr . BITWISE_OR expr
  166          | expr . BITWISE_XOR expr
  167 shift-expr: expr . LSHIFT expr
  168           | expr . RSHIFT expr
  169           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 118
    SUB              shift, and go to state 119
    MULT             shift, and go to state 120
    DIV              shift, and go to state 121
    EXP              shift, and go to state 122
    REM              shift, and go to state 123
    BITWISE_AND      shift, and go to state 124
    BITWISE_OR       shift, and go to state 125
    BITWISE_XOR      shift, and go to state 126
    LOGICAL_NULL     shift, and go to state 127
    LOGICAL_AND      shift, and go to state 128
    LOGICAL_OR       shift, and go to state 129
    EQ               shift, and go to state 130
    EQ_STRICT        shift, and go to state 131
    INEQ             shift, and go to state 132
    INEQ_STRICT      shift, and go to state 133
    LT               shift, and go to state 134
    LT_EQ            shift, and go to state 135
    GT               shift, and go to state 136
    GT_EQ            shift, and go to state 137
    LSHIFT           shift, and go to state 138
    RSHIFT           shift, and go to state 139
    RSHIFT_UNSIGNED  shift, and go to state 140
    RPAR             shift, and go to state 357


State 322

   27 for-stmt: FOR LPAR assign-expr SEMI SEMI RPAR . LBRACE line RBRACE

    LBRACE  shift, and go to state 358


State 323

   26 for-stmt: FOR LPAR assign-expr SEMI SEMI assign-expr . RPAR LBRACE line RBRACE

    RPAR  shift, and go to state 359


State 324

   25 for-stmt: FOR LPAR assign-expr SEMI SEMI expr . RPAR LBRACE line RBRACE
   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  158 arit-expr: expr . PLUS expr
  159          | expr . SUB expr
  160          | expr . MULT expr
  161          | expr . DIV expr
  162          | expr . EXP expr
  163          | expr . REM expr
  164 bitw-expr: expr . BITWISE_AND expr
  165          | expr . BITWISE_OR expr
  166          | expr . BITWISE_XOR expr
  167 shift-expr: expr . LSHIFT expr
  168           | expr . RSHIFT expr
  169           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 118
    SUB              shift, and go to state 119
    MULT             shift, and go to state 120
    DIV              shift, and go to state 121
    EXP              shift, and go to state 122
    REM              shift, and go to state 123
    BITWISE_AND      shift, and go to state 124
    BITWISE_OR       shift, and go to state 125
    BITWISE_XOR      shift, and go to state 126
    LOGICAL_NULL     shift, and go to state 127
    LOGICAL_AND      shift, and go to state 128
    LOGICAL_OR       shift, and go to state 129
    EQ               shift, and go to state 130
    EQ_STRICT        shift, and go to state 131
    INEQ             shift, and go to state 132
    INEQ_STRICT      shift, and go to state 133
    LT               shift, and go to state 134
    LT_EQ            shift, and go to state 135
    GT               shift, and go to state 136
    GT_EQ            shift, and go to state 137
    LSHIFT           shift, and go to state 138
    RSHIFT           shift, and go to state 139
    RSHIFT_UNSIGNED  shift, and go to state 140
    RPAR             shift, and go to state 360


State 325

   22 for-stmt: FOR LPAR assign-expr SEMI expr SEMI . expr RPAR LBRACE line RBRACE
   23         | FOR LPAR assign-expr SEMI expr SEMI . assign-expr RPAR LBRACE line RBRACE
   24         | FOR LPAR assign-expr SEMI expr SEMI . RPAR LBRACE line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    RPAR         shift, and go to state 361
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    assign-expr      go to state 362
    logic-expr       go to state 38
    expr             go to state 363
    idx-unsafe-expr  go to state 43
    idx-safe-expr    go to state 44
    vet-idx          go to state 45
    unary-expr       go to state 46
    arit-expr        go to state 47
    bitw-expr        go to state 48
    shift-expr       go to state 49
    var-att          go to state 50
    var-met          go to state 51
    var-obj          go to state 52
    var-val          go to state 53
    array-expr       go to state 54


State 326

   33 for-stmt: FOR LPAR var-declr SEMI SEMI RPAR . LBRACE line RBRACE

    LBRACE  shift, and go to state 364


State 327

   32 for-stmt: FOR LPAR var-declr SEMI SEMI assign-expr . RPAR LBRACE line RBRACE

    RPAR  shift, and go to state 365


State 328

   31 for-stmt: FOR LPAR var-declr SEMI SEMI expr . RPAR LBRACE line RBRACE
   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  158 arit-expr: expr . PLUS expr
  159          | expr . SUB expr
  160          | expr . MULT expr
  161          | expr . DIV expr
  162          | expr . EXP expr
  163          | expr . REM expr
  164 bitw-expr: expr . BITWISE_AND expr
  165          | expr . BITWISE_OR expr
  166          | expr . BITWISE_XOR expr
  167 shift-expr: expr . LSHIFT expr
  168           | expr . RSHIFT expr
  169           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 118
    SUB              shift, and go to state 119
    MULT             shift, and go to state 120
    DIV              shift, and go to state 121
    EXP              shift, and go to state 122
    REM              shift, and go to state 123
    BITWISE_AND      shift, and go to state 124
    BITWISE_OR       shift, and go to state 125
    BITWISE_XOR      shift, and go to state 126
    LOGICAL_NULL     shift, and go to state 127
    LOGICAL_AND      shift, and go to state 128
    LOGICAL_OR       shift, and go to state 129
    EQ               shift, and go to state 130
    EQ_STRICT        shift, and go to state 131
    INEQ             shift, and go to state 132
    INEQ_STRICT      shift, and go to state 133
    LT               shift, and go to state 134
    LT_EQ            shift, and go to state 135
    GT               shift, and go to state 136
    GT_EQ            shift, and go to state 137
    LSHIFT           shift, and go to state 138
    RSHIFT           shift, and go to state 139
    RSHIFT_UNSIGNED  shift, and go to state 140
    RPAR             shift, and go to state 366


State 329

   28 for-stmt: FOR LPAR var-declr SEMI expr SEMI . expr RPAR LBRACE line RBRACE
   29         | FOR LPAR var-declr SEMI expr SEMI . assign-expr RPAR LBRACE line RBRACE
   30         | FOR LPAR var-declr SEMI expr SEMI . RPAR LBRACE line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    RPAR         shift, and go to state 367
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    assign-expr      go to state 368
    logic-expr       go to state 38
    expr             go to state 369
    idx-unsafe-expr  go to state 43
    idx-safe-expr    go to state 44
    vet-idx          go to state 45
    unary-expr       go to state 46
    arit-expr        go to state 47
    bitw-expr        go to state 48
    shift-expr       go to state 49
    var-att          go to state 50
    var-met          go to state 51
    var-obj          go to state 52
    var-val          go to state 53
    array-expr       go to state 54


State 330

   93 params: COMMA ID COLON . var-type

    VOID_RW   shift, and go to state 155
    ANY       shift, and go to state 156
    BOOLTYPE  shift, and go to state 157
    NEVER     shift, and go to state 158
    NUMBER    shift, and go to state 159
    STRING    shift, and go to state 160
    UNKNOWN   shift, and go to state 161

    var-type  go to state 370


State 331

   94 params: ID COMMA ID .
   98       | ID COMMA ID . COLON var-type

    COLON  shift, and go to state 371

    $default  reduce using rule 94 (params)


State 332

   95 params: ID COLON var-type . COMMA ID COLON var-type
   96       | ID COLON var-type . COMMA ID
   97       | ID COLON var-type .

    COMMA  shift, and go to state 372

    $default  reduce using rule 97 (params)


State 333

   91 func-def: FUNCTION ID LPAR params RPAR COLON . var-type LBRACE line RBRACE

    VOID_RW   shift, and go to state 155
    ANY       shift, and go to state 156
    BOOLTYPE  shift, and go to state 157
    NEVER     shift, and go to state 158
    NUMBER    shift, and go to state 159
    STRING    shift, and go to state 160
    UNKNOWN   shift, and go to state 161

    var-type  go to state 373


State 334

   90 func-def: FUNCTION ID LPAR params RPAR LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 3 (line)

    line             go to state 374
    stmt-list        go to state 31
    stmt             go to state 32
    assign-expr      go to state 33
    for-stmt         go to state 34
    do-while-stmt    go to state 35
    while-stmt       go to state 36
    if-stmt          go to state 37
    logic-expr       go to state 38
    class-def        go to state 39
    func-def         go to state 40
    var-declr        go to state 41
    expr             go to state 42
    idx-unsafe-expr  go to state 43
    idx-safe-expr    go to state 44
    vet-idx          go to state 45
    unary-expr       go to state 46
    arit-expr        go to state 47
    bitw-expr        go to state 48
    shift-expr       go to state 49
    var-att          go to state 50
    var-met          go to state 51
    var-obj          go to state 52
    var-val          go to state 53
    array-expr       go to state 54


State 335

   63 if-stmt: IF LPAR assign-expr RPAR LBRACE line . RBRACE
   64        | IF LPAR assign-expr RPAR LBRACE line . RBRACE ELSE LBRACE line RBRACE
   65        | IF LPAR assign-expr RPAR LBRACE line . RBRACE ELSE stmt

    RBRACE  shift, and go to state 375


State 336

   60 if-stmt: IF LPAR expr RPAR LBRACE line . RBRACE
   61        | IF LPAR expr RPAR LBRACE line . RBRACE ELSE LBRACE line RBRACE
   62        | IF LPAR expr RPAR LBRACE line . RBRACE ELSE stmt

    RBRACE  shift, and go to state 376


State 337

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  104 var-declr: LET ID COLON var-type ASSIGN expr .
  158 arit-expr: expr . PLUS expr
  159          | expr . SUB expr
  160          | expr . MULT expr
  161          | expr . DIV expr
  162          | expr . EXP expr
  163          | expr . REM expr
  164 bitw-expr: expr . BITWISE_AND expr
  165          | expr . BITWISE_OR expr
  166          | expr . BITWISE_XOR expr
  167 shift-expr: expr . LSHIFT expr
  168           | expr . RSHIFT expr
  169           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 118
    SUB              shift, and go to state 119
    MULT             shift, and go to state 120
    DIV              shift, and go to state 121
    EXP              shift, and go to state 122
    REM              shift, and go to state 123
    BITWISE_AND      shift, and go to state 124
    BITWISE_OR       shift, and go to state 125
    BITWISE_XOR      shift, and go to state 126
    LOGICAL_NULL     shift, and go to state 127
    LOGICAL_AND      shift, and go to state 128
    LOGICAL_OR       shift, and go to state 129
    EQ               shift, and go to state 130
    EQ_STRICT        shift, and go to state 131
    INEQ             shift, and go to state 132
    INEQ_STRICT      shift, and go to state 133
    LT               shift, and go to state 134
    LT_EQ            shift, and go to state 135
    GT               shift, and go to state 136
    GT_EQ            shift, and go to state 137
    LSHIFT           shift, and go to state 138
    RSHIFT           shift, and go to state 139
    RSHIFT_UNSIGNED  shift, and go to state 140

    $default  reduce using rule 104 (var-declr)


State 338

  105 var-declr: LET ID COLON var-type LBRACKET RBRACKET .
  106          | LET ID COLON var-type LBRACKET RBRACKET . ASSIGN expr

    ASSIGN  shift, and go to state 377

    $default  reduce using rule 105 (var-declr)


State 339

  187 var-obj: NEW ID LT var-type GT LPAR . args-list RPAR

    COMMA        shift, and go to state 164
    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 183 (args-list)

    assign-expr      go to state 165
    logic-expr       go to state 38
    expr             go to state 166
    idx-unsafe-expr  go to state 43
    idx-safe-expr    go to state 44
    vet-idx          go to state 45
    unary-expr       go to state 46
    arit-expr        go to state 47
    bitw-expr        go to state 48
    shift-expr       go to state 49
    var-att          go to state 50
    var-met          go to state 51
    args-list        go to state 378
    var-obj          go to state 52
    var-val          go to state 53
    array-expr       go to state 54


State 340

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  111 var-declr: VAR ID COLON var-type ASSIGN expr .
  158 arit-expr: expr . PLUS expr
  159          | expr . SUB expr
  160          | expr . MULT expr
  161          | expr . DIV expr
  162          | expr . EXP expr
  163          | expr . REM expr
  164 bitw-expr: expr . BITWISE_AND expr
  165          | expr . BITWISE_OR expr
  166          | expr . BITWISE_XOR expr
  167 shift-expr: expr . LSHIFT expr
  168           | expr . RSHIFT expr
  169           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 118
    SUB              shift, and go to state 119
    MULT             shift, and go to state 120
    DIV              shift, and go to state 121
    EXP              shift, and go to state 122
    REM              shift, and go to state 123
    BITWISE_AND      shift, and go to state 124
    BITWISE_OR       shift, and go to state 125
    BITWISE_XOR      shift, and go to state 126
    LOGICAL_NULL     shift, and go to state 127
    LOGICAL_AND      shift, and go to state 128
    LOGICAL_OR       shift, and go to state 129
    EQ               shift, and go to state 130
    EQ_STRICT        shift, and go to state 131
    INEQ             shift, and go to state 132
    INEQ_STRICT      shift, and go to state 133
    LT               shift, and go to state 134
    LT_EQ            shift, and go to state 135
    GT               shift, and go to state 136
    GT_EQ            shift, and go to state 137
    LSHIFT           shift, and go to state 138
    RSHIFT           shift, and go to state 139
    RSHIFT_UNSIGNED  shift, and go to state 140

    $default  reduce using rule 111 (var-declr)


State 341

  112 var-declr: VAR ID COLON var-type LBRACKET RBRACKET .
  113          | VAR ID COLON var-type LBRACKET RBRACKET . ASSIGN expr

    ASSIGN  shift, and go to state 379

    $default  reduce using rule 112 (var-declr)


State 342

   59 while-stmt: WHILE LPAR assign-expr RPAR LBRACE line . RBRACE

    RBRACE  shift, and go to state 380


State 343

   58 while-stmt: WHILE LPAR expr RPAR LBRACE line . RBRACE

    RBRACE  shift, and go to state 381


State 344

  185 var-obj: ID LT var-type GT LPAR args-list RPAR .

    $default  reduce using rule 185 (var-obj)


State 345

   85 class-att: ID LPAR params RPAR . LBRACE line RBRACE
   86          | ID LPAR params RPAR . COLON var-type LBRACE line RBRACE

    COLON   shift, and go to state 382
    LBRACE  shift, and go to state 383


State 346

   84 class-att: access-modif ID COLON var-type .

    $default  reduce using rule 84 (class-att)


State 347

  116 var-declr: CONST_RW ID COLON var-type LBRACKET RBRACKET ASSIGN . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 64
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 38
    expr             go to state 384
    idx-unsafe-expr  go to state 43
    idx-safe-expr    go to state 44
    vet-idx          go to state 66
    unary-expr       go to state 46
    arit-expr        go to state 47
    bitw-expr        go to state 48
    shift-expr       go to state 49
    var-att          go to state 67
    var-met          go to state 51
    var-obj          go to state 52
    var-val          go to state 53
    array-expr       go to state 54


State 348

  125 obj-att: ID COLON var-val .

    $default  reduce using rule 125 (obj-att)


State 349

  122 obj-att-list: obj-att COMMA obj-att-list .

    $default  reduce using rule 122 (obj-att-list)


State 350

   57 do-while-stmt: DO LBRACE line RBRACE WHILE LPAR assign-expr . RPAR

    RPAR  shift, and go to state 385


State 351

   56 do-while-stmt: DO LBRACE line RBRACE WHILE LPAR expr . RPAR
   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  158 arit-expr: expr . PLUS expr
  159          | expr . SUB expr
  160          | expr . MULT expr
  161          | expr . DIV expr
  162          | expr . EXP expr
  163          | expr . REM expr
  164 bitw-expr: expr . BITWISE_AND expr
  165          | expr . BITWISE_OR expr
  166          | expr . BITWISE_XOR expr
  167 shift-expr: expr . LSHIFT expr
  168           | expr . RSHIFT expr
  169           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 118
    SUB              shift, and go to state 119
    MULT             shift, and go to state 120
    DIV              shift, and go to state 121
    EXP              shift, and go to state 122
    REM              shift, and go to state 123
    BITWISE_AND      shift, and go to state 124
    BITWISE_OR       shift, and go to state 125
    BITWISE_XOR      shift, and go to state 126
    LOGICAL_NULL     shift, and go to state 127
    LOGICAL_AND      shift, and go to state 128
    LOGICAL_OR       shift, and go to state 129
    EQ               shift, and go to state 130
    EQ_STRICT        shift, and go to state 131
    INEQ             shift, and go to state 132
    INEQ_STRICT      shift, and go to state 133
    LT               shift, and go to state 134
    LT_EQ            shift, and go to state 135
    GT               shift, and go to state 136
    GT_EQ            shift, and go to state 137
    LSHIFT           shift, and go to state 138
    RSHIFT           shift, and go to state 139
    RSHIFT_UNSIGNED  shift, and go to state 140
    RPAR             shift, and go to state 386


State 352

   39 for-stmt: FOR LPAR SEMI SEMI RPAR LBRACE line . RBRACE

    RBRACE  shift, and go to state 387


State 353

   38 for-stmt: FOR LPAR SEMI SEMI assign-expr RPAR LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 3 (line)

    line             go to state 388
    stmt-list        go to state 31
    stmt             go to state 32
    assign-expr      go to state 33
    for-stmt         go to state 34
    do-while-stmt    go to state 35
    while-stmt       go to state 36
    if-stmt          go to state 37
    logic-expr       go to state 38
    class-def        go to state 39
    func-def         go to state 40
    var-declr        go to state 41
    expr             go to state 42
    idx-unsafe-expr  go to state 43
    idx-safe-expr    go to state 44
    vet-idx          go to state 45
    unary-expr       go to state 46
    arit-expr        go to state 47
    bitw-expr        go to state 48
    shift-expr       go to state 49
    var-att          go to state 50
    var-met          go to state 51
    var-obj          go to state 52
    var-val          go to state 53
    array-expr       go to state 54


State 354

   37 for-stmt: FOR LPAR SEMI SEMI expr RPAR LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 3 (line)

    line             go to state 389
    stmt-list        go to state 31
    stmt             go to state 32
    assign-expr      go to state 33
    for-stmt         go to state 34
    do-while-stmt    go to state 35
    while-stmt       go to state 36
    if-stmt          go to state 37
    logic-expr       go to state 38
    class-def        go to state 39
    func-def         go to state 40
    var-declr        go to state 41
    expr             go to state 42
    idx-unsafe-expr  go to state 43
    idx-safe-expr    go to state 44
    vet-idx          go to state 45
    unary-expr       go to state 46
    arit-expr        go to state 47
    bitw-expr        go to state 48
    shift-expr       go to state 49
    var-att          go to state 50
    var-met          go to state 51
    var-obj          go to state 52
    var-val          go to state 53
    array-expr       go to state 54


State 355

   36 for-stmt: FOR LPAR SEMI expr SEMI RPAR LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 3 (line)

    line             go to state 390
    stmt-list        go to state 31
    stmt             go to state 32
    assign-expr      go to state 33
    for-stmt         go to state 34
    do-while-stmt    go to state 35
    while-stmt       go to state 36
    if-stmt          go to state 37
    logic-expr       go to state 38
    class-def        go to state 39
    func-def         go to state 40
    var-declr        go to state 41
    expr             go to state 42
    idx-unsafe-expr  go to state 43
    idx-safe-expr    go to state 44
    vet-idx          go to state 45
    unary-expr       go to state 46
    arit-expr        go to state 47
    bitw-expr        go to state 48
    shift-expr       go to state 49
    var-att          go to state 50
    var-met          go to state 51
    var-obj          go to state 52
    var-val          go to state 53
    array-expr       go to state 54


State 356

   35 for-stmt: FOR LPAR SEMI expr SEMI assign-expr RPAR . LBRACE line RBRACE

    LBRACE  shift, and go to state 391


State 357

   34 for-stmt: FOR LPAR SEMI expr SEMI expr RPAR . LBRACE line RBRACE

    LBRACE  shift, and go to state 392


State 358

   27 for-stmt: FOR LPAR assign-expr SEMI SEMI RPAR LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 3 (line)

    line             go to state 393
    stmt-list        go to state 31
    stmt             go to state 32
    assign-expr      go to state 33
    for-stmt         go to state 34
    do-while-stmt    go to state 35
    while-stmt       go to state 36
    if-stmt          go to state 37
    logic-expr       go to state 38
    class-def        go to state 39
    func-def         go to state 40
    var-declr        go to state 41
    expr             go to state 42
    idx-unsafe-expr  go to state 43
    idx-safe-expr    go to state 44
    vet-idx          go to state 45
    unary-expr       go to state 46
    arit-expr        go to state 47
    bitw-expr        go to state 48
    shift-expr       go to state 49
    var-att          go to state 50
    var-met          go to state 51
    var-obj          go to state 52
    var-val          go to state 53
    array-expr       go to state 54


State 359

   26 for-stmt: FOR LPAR assign-expr SEMI SEMI assign-expr RPAR . LBRACE line RBRACE

    LBRACE  shift, and go to state 394


State 360

   25 for-stmt: FOR LPAR assign-expr SEMI SEMI expr RPAR . LBRACE line RBRACE

    LBRACE  shift, and go to state 395


State 361

   24 for-stmt: FOR LPAR assign-expr SEMI expr SEMI RPAR . LBRACE line RBRACE

    LBRACE  shift, and go to state 396


State 362

   23 for-stmt: FOR LPAR assign-expr SEMI expr SEMI assign-expr . RPAR LBRACE line RBRACE

    RPAR  shift, and go to state 397


State 363

   22 for-stmt: FOR LPAR assign-expr SEMI expr SEMI expr . RPAR LBRACE line RBRACE
   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  158 arit-expr: expr . PLUS expr
  159          | expr . SUB expr
  160          | expr . MULT expr
  161          | expr . DIV expr
  162          | expr . EXP expr
  163          | expr . REM expr
  164 bitw-expr: expr . BITWISE_AND expr
  165          | expr . BITWISE_OR expr
  166          | expr . BITWISE_XOR expr
  167 shift-expr: expr . LSHIFT expr
  168           | expr . RSHIFT expr
  169           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 118
    SUB              shift, and go to state 119
    MULT             shift, and go to state 120
    DIV              shift, and go to state 121
    EXP              shift, and go to state 122
    REM              shift, and go to state 123
    BITWISE_AND      shift, and go to state 124
    BITWISE_OR       shift, and go to state 125
    BITWISE_XOR      shift, and go to state 126
    LOGICAL_NULL     shift, and go to state 127
    LOGICAL_AND      shift, and go to state 128
    LOGICAL_OR       shift, and go to state 129
    EQ               shift, and go to state 130
    EQ_STRICT        shift, and go to state 131
    INEQ             shift, and go to state 132
    INEQ_STRICT      shift, and go to state 133
    LT               shift, and go to state 134
    LT_EQ            shift, and go to state 135
    GT               shift, and go to state 136
    GT_EQ            shift, and go to state 137
    LSHIFT           shift, and go to state 138
    RSHIFT           shift, and go to state 139
    RSHIFT_UNSIGNED  shift, and go to state 140
    RPAR             shift, and go to state 398


State 364

   33 for-stmt: FOR LPAR var-declr SEMI SEMI RPAR LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 3 (line)

    line             go to state 399
    stmt-list        go to state 31
    stmt             go to state 32
    assign-expr      go to state 33
    for-stmt         go to state 34
    do-while-stmt    go to state 35
    while-stmt       go to state 36
    if-stmt          go to state 37
    logic-expr       go to state 38
    class-def        go to state 39
    func-def         go to state 40
    var-declr        go to state 41
    expr             go to state 42
    idx-unsafe-expr  go to state 43
    idx-safe-expr    go to state 44
    vet-idx          go to state 45
    unary-expr       go to state 46
    arit-expr        go to state 47
    bitw-expr        go to state 48
    shift-expr       go to state 49
    var-att          go to state 50
    var-met          go to state 51
    var-obj          go to state 52
    var-val          go to state 53
    array-expr       go to state 54


State 365

   32 for-stmt: FOR LPAR var-declr SEMI SEMI assign-expr RPAR . LBRACE line RBRACE

    LBRACE  shift, and go to state 400


State 366

   31 for-stmt: FOR LPAR var-declr SEMI SEMI expr RPAR . LBRACE line RBRACE

    LBRACE  shift, and go to state 401


State 367

   30 for-stmt: FOR LPAR var-declr SEMI expr SEMI RPAR . LBRACE line RBRACE

    LBRACE  shift, and go to state 402


State 368

   29 for-stmt: FOR LPAR var-declr SEMI expr SEMI assign-expr . RPAR LBRACE line RBRACE

    RPAR  shift, and go to state 403


State 369

   28 for-stmt: FOR LPAR var-declr SEMI expr SEMI expr . RPAR LBRACE line RBRACE
   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  158 arit-expr: expr . PLUS expr
  159          | expr . SUB expr
  160          | expr . MULT expr
  161          | expr . DIV expr
  162          | expr . EXP expr
  163          | expr . REM expr
  164 bitw-expr: expr . BITWISE_AND expr
  165          | expr . BITWISE_OR expr
  166          | expr . BITWISE_XOR expr
  167 shift-expr: expr . LSHIFT expr
  168           | expr . RSHIFT expr
  169           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 118
    SUB              shift, and go to state 119
    MULT             shift, and go to state 120
    DIV              shift, and go to state 121
    EXP              shift, and go to state 122
    REM              shift, and go to state 123
    BITWISE_AND      shift, and go to state 124
    BITWISE_OR       shift, and go to state 125
    BITWISE_XOR      shift, and go to state 126
    LOGICAL_NULL     shift, and go to state 127
    LOGICAL_AND      shift, and go to state 128
    LOGICAL_OR       shift, and go to state 129
    EQ               shift, and go to state 130
    EQ_STRICT        shift, and go to state 131
    INEQ             shift, and go to state 132
    INEQ_STRICT      shift, and go to state 133
    LT               shift, and go to state 134
    LT_EQ            shift, and go to state 135
    GT               shift, and go to state 136
    GT_EQ            shift, and go to state 137
    LSHIFT           shift, and go to state 138
    RSHIFT           shift, and go to state 139
    RSHIFT_UNSIGNED  shift, and go to state 140
    RPAR             shift, and go to state 404


State 370

   93 params: COMMA ID COLON var-type .

    $default  reduce using rule 93 (params)


State 371

   98 params: ID COMMA ID COLON . var-type

    VOID_RW   shift, and go to state 155
    ANY       shift, and go to state 156
    BOOLTYPE  shift, and go to state 157
    NEVER     shift, and go to state 158
    NUMBER    shift, and go to state 159
    STRING    shift, and go to state 160
    UNKNOWN   shift, and go to state 161

    var-type  go to state 405


State 372

   95 params: ID COLON var-type COMMA . ID COLON var-type
   96       | ID COLON var-type COMMA . ID

    ID  shift, and go to state 406


State 373

   91 func-def: FUNCTION ID LPAR params RPAR COLON var-type . LBRACE line RBRACE

    LBRACE  shift, and go to state 407


State 374

   90 func-def: FUNCTION ID LPAR params RPAR LBRACE line . RBRACE

    RBRACE  shift, and go to state 408


State 375

   63 if-stmt: IF LPAR assign-expr RPAR LBRACE line RBRACE .
   64        | IF LPAR assign-expr RPAR LBRACE line RBRACE . ELSE LBRACE line RBRACE
   65        | IF LPAR assign-expr RPAR LBRACE line RBRACE . ELSE stmt

    ELSE  shift, and go to state 409

    $default  reduce using rule 63 (if-stmt)


State 376

   60 if-stmt: IF LPAR expr RPAR LBRACE line RBRACE .
   61        | IF LPAR expr RPAR LBRACE line RBRACE . ELSE LBRACE line RBRACE
   62        | IF LPAR expr RPAR LBRACE line RBRACE . ELSE stmt

    ELSE  shift, and go to state 410

    $default  reduce using rule 60 (if-stmt)


State 377

  106 var-declr: LET ID COLON var-type LBRACKET RBRACKET ASSIGN . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 64
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 38
    expr             go to state 411
    idx-unsafe-expr  go to state 43
    idx-safe-expr    go to state 44
    vet-idx          go to state 66
    unary-expr       go to state 46
    arit-expr        go to state 47
    bitw-expr        go to state 48
    shift-expr       go to state 49
    var-att          go to state 67
    var-met          go to state 51
    var-obj          go to state 52
    var-val          go to state 53
    array-expr       go to state 54


State 378

  187 var-obj: NEW ID LT var-type GT LPAR args-list . RPAR

    RPAR  shift, and go to state 412


State 379

  113 var-declr: VAR ID COLON var-type LBRACKET RBRACKET ASSIGN . expr

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 64
    FALSE_RW     shift, and go to state 17
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    TRUE_RW      shift, and go to state 25
    UNDEFINED    shift, and go to state 28

    logic-expr       go to state 38
    expr             go to state 413
    idx-unsafe-expr  go to state 43
    idx-safe-expr    go to state 44
    vet-idx          go to state 66
    unary-expr       go to state 46
    arit-expr        go to state 47
    bitw-expr        go to state 48
    shift-expr       go to state 49
    var-att          go to state 67
    var-met          go to state 51
    var-obj          go to state 52
    var-val          go to state 53
    array-expr       go to state 54


State 380

   59 while-stmt: WHILE LPAR assign-expr RPAR LBRACE line RBRACE .

    $default  reduce using rule 59 (while-stmt)


State 381

   58 while-stmt: WHILE LPAR expr RPAR LBRACE line RBRACE .

    $default  reduce using rule 58 (while-stmt)


State 382

   86 class-att: ID LPAR params RPAR COLON . var-type LBRACE line RBRACE

    VOID_RW   shift, and go to state 155
    ANY       shift, and go to state 156
    BOOLTYPE  shift, and go to state 157
    NEVER     shift, and go to state 158
    NUMBER    shift, and go to state 159
    STRING    shift, and go to state 160
    UNKNOWN   shift, and go to state 161

    var-type  go to state 414


State 383

   85 class-att: ID LPAR params RPAR LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 3 (line)

    line             go to state 415
    stmt-list        go to state 31
    stmt             go to state 32
    assign-expr      go to state 33
    for-stmt         go to state 34
    do-while-stmt    go to state 35
    while-stmt       go to state 36
    if-stmt          go to state 37
    logic-expr       go to state 38
    class-def        go to state 39
    func-def         go to state 40
    var-declr        go to state 41
    expr             go to state 42
    idx-unsafe-expr  go to state 43
    idx-safe-expr    go to state 44
    vet-idx          go to state 45
    unary-expr       go to state 46
    arit-expr        go to state 47
    bitw-expr        go to state 48
    shift-expr       go to state 49
    var-att          go to state 50
    var-met          go to state 51
    var-obj          go to state 52
    var-val          go to state 53
    array-expr       go to state 54


State 384

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  116 var-declr: CONST_RW ID COLON var-type LBRACKET RBRACKET ASSIGN expr .
  158 arit-expr: expr . PLUS expr
  159          | expr . SUB expr
  160          | expr . MULT expr
  161          | expr . DIV expr
  162          | expr . EXP expr
  163          | expr . REM expr
  164 bitw-expr: expr . BITWISE_AND expr
  165          | expr . BITWISE_OR expr
  166          | expr . BITWISE_XOR expr
  167 shift-expr: expr . LSHIFT expr
  168           | expr . RSHIFT expr
  169           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 118
    SUB              shift, and go to state 119
    MULT             shift, and go to state 120
    DIV              shift, and go to state 121
    EXP              shift, and go to state 122
    REM              shift, and go to state 123
    BITWISE_AND      shift, and go to state 124
    BITWISE_OR       shift, and go to state 125
    BITWISE_XOR      shift, and go to state 126
    LOGICAL_NULL     shift, and go to state 127
    LOGICAL_AND      shift, and go to state 128
    LOGICAL_OR       shift, and go to state 129
    EQ               shift, and go to state 130
    EQ_STRICT        shift, and go to state 131
    INEQ             shift, and go to state 132
    INEQ_STRICT      shift, and go to state 133
    LT               shift, and go to state 134
    LT_EQ            shift, and go to state 135
    GT               shift, and go to state 136
    GT_EQ            shift, and go to state 137
    LSHIFT           shift, and go to state 138
    RSHIFT           shift, and go to state 139
    RSHIFT_UNSIGNED  shift, and go to state 140

    $default  reduce using rule 116 (var-declr)


State 385

   57 do-while-stmt: DO LBRACE line RBRACE WHILE LPAR assign-expr RPAR .

    $default  reduce using rule 57 (do-while-stmt)


State 386

   56 do-while-stmt: DO LBRACE line RBRACE WHILE LPAR expr RPAR .

    $default  reduce using rule 56 (do-while-stmt)


State 387

   39 for-stmt: FOR LPAR SEMI SEMI RPAR LBRACE line RBRACE .

    $default  reduce using rule 39 (for-stmt)


State 388

   38 for-stmt: FOR LPAR SEMI SEMI assign-expr RPAR LBRACE line . RBRACE

    RBRACE  shift, and go to state 416


State 389

   37 for-stmt: FOR LPAR SEMI SEMI expr RPAR LBRACE line . RBRACE

    RBRACE  shift, and go to state 417


State 390

   36 for-stmt: FOR LPAR SEMI expr SEMI RPAR LBRACE line . RBRACE

    RBRACE  shift, and go to state 418


State 391

   35 for-stmt: FOR LPAR SEMI expr SEMI assign-expr RPAR LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 3 (line)

    line             go to state 419
    stmt-list        go to state 31
    stmt             go to state 32
    assign-expr      go to state 33
    for-stmt         go to state 34
    do-while-stmt    go to state 35
    while-stmt       go to state 36
    if-stmt          go to state 37
    logic-expr       go to state 38
    class-def        go to state 39
    func-def         go to state 40
    var-declr        go to state 41
    expr             go to state 42
    idx-unsafe-expr  go to state 43
    idx-safe-expr    go to state 44
    vet-idx          go to state 45
    unary-expr       go to state 46
    arit-expr        go to state 47
    bitw-expr        go to state 48
    shift-expr       go to state 49
    var-att          go to state 50
    var-met          go to state 51
    var-obj          go to state 52
    var-val          go to state 53
    array-expr       go to state 54


State 392

   34 for-stmt: FOR LPAR SEMI expr SEMI expr RPAR LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 3 (line)

    line             go to state 420
    stmt-list        go to state 31
    stmt             go to state 32
    assign-expr      go to state 33
    for-stmt         go to state 34
    do-while-stmt    go to state 35
    while-stmt       go to state 36
    if-stmt          go to state 37
    logic-expr       go to state 38
    class-def        go to state 39
    func-def         go to state 40
    var-declr        go to state 41
    expr             go to state 42
    idx-unsafe-expr  go to state 43
    idx-safe-expr    go to state 44
    vet-idx          go to state 45
    unary-expr       go to state 46
    arit-expr        go to state 47
    bitw-expr        go to state 48
    shift-expr       go to state 49
    var-att          go to state 50
    var-met          go to state 51
    var-obj          go to state 52
    var-val          go to state 53
    array-expr       go to state 54


State 393

   27 for-stmt: FOR LPAR assign-expr SEMI SEMI RPAR LBRACE line . RBRACE

    RBRACE  shift, and go to state 421


State 394

   26 for-stmt: FOR LPAR assign-expr SEMI SEMI assign-expr RPAR LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 3 (line)

    line             go to state 422
    stmt-list        go to state 31
    stmt             go to state 32
    assign-expr      go to state 33
    for-stmt         go to state 34
    do-while-stmt    go to state 35
    while-stmt       go to state 36
    if-stmt          go to state 37
    logic-expr       go to state 38
    class-def        go to state 39
    func-def         go to state 40
    var-declr        go to state 41
    expr             go to state 42
    idx-unsafe-expr  go to state 43
    idx-safe-expr    go to state 44
    vet-idx          go to state 45
    unary-expr       go to state 46
    arit-expr        go to state 47
    bitw-expr        go to state 48
    shift-expr       go to state 49
    var-att          go to state 50
    var-met          go to state 51
    var-obj          go to state 52
    var-val          go to state 53
    array-expr       go to state 54


State 395

   25 for-stmt: FOR LPAR assign-expr SEMI SEMI expr RPAR LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 3 (line)

    line             go to state 423
    stmt-list        go to state 31
    stmt             go to state 32
    assign-expr      go to state 33
    for-stmt         go to state 34
    do-while-stmt    go to state 35
    while-stmt       go to state 36
    if-stmt          go to state 37
    logic-expr       go to state 38
    class-def        go to state 39
    func-def         go to state 40
    var-declr        go to state 41
    expr             go to state 42
    idx-unsafe-expr  go to state 43
    idx-safe-expr    go to state 44
    vet-idx          go to state 45
    unary-expr       go to state 46
    arit-expr        go to state 47
    bitw-expr        go to state 48
    shift-expr       go to state 49
    var-att          go to state 50
    var-met          go to state 51
    var-obj          go to state 52
    var-val          go to state 53
    array-expr       go to state 54


State 396

   24 for-stmt: FOR LPAR assign-expr SEMI expr SEMI RPAR LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 3 (line)

    line             go to state 424
    stmt-list        go to state 31
    stmt             go to state 32
    assign-expr      go to state 33
    for-stmt         go to state 34
    do-while-stmt    go to state 35
    while-stmt       go to state 36
    if-stmt          go to state 37
    logic-expr       go to state 38
    class-def        go to state 39
    func-def         go to state 40
    var-declr        go to state 41
    expr             go to state 42
    idx-unsafe-expr  go to state 43
    idx-safe-expr    go to state 44
    vet-idx          go to state 45
    unary-expr       go to state 46
    arit-expr        go to state 47
    bitw-expr        go to state 48
    shift-expr       go to state 49
    var-att          go to state 50
    var-met          go to state 51
    var-obj          go to state 52
    var-val          go to state 53
    array-expr       go to state 54


State 397

   23 for-stmt: FOR LPAR assign-expr SEMI expr SEMI assign-expr RPAR . LBRACE line RBRACE

    LBRACE  shift, and go to state 425


State 398

   22 for-stmt: FOR LPAR assign-expr SEMI expr SEMI expr RPAR . LBRACE line RBRACE

    LBRACE  shift, and go to state 426


State 399

   33 for-stmt: FOR LPAR var-declr SEMI SEMI RPAR LBRACE line . RBRACE

    RBRACE  shift, and go to state 427


State 400

   32 for-stmt: FOR LPAR var-declr SEMI SEMI assign-expr RPAR LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 3 (line)

    line             go to state 428
    stmt-list        go to state 31
    stmt             go to state 32
    assign-expr      go to state 33
    for-stmt         go to state 34
    do-while-stmt    go to state 35
    while-stmt       go to state 36
    if-stmt          go to state 37
    logic-expr       go to state 38
    class-def        go to state 39
    func-def         go to state 40
    var-declr        go to state 41
    expr             go to state 42
    idx-unsafe-expr  go to state 43
    idx-safe-expr    go to state 44
    vet-idx          go to state 45
    unary-expr       go to state 46
    arit-expr        go to state 47
    bitw-expr        go to state 48
    shift-expr       go to state 49
    var-att          go to state 50
    var-met          go to state 51
    var-obj          go to state 52
    var-val          go to state 53
    array-expr       go to state 54


State 401

   31 for-stmt: FOR LPAR var-declr SEMI SEMI expr RPAR LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 3 (line)

    line             go to state 429
    stmt-list        go to state 31
    stmt             go to state 32
    assign-expr      go to state 33
    for-stmt         go to state 34
    do-while-stmt    go to state 35
    while-stmt       go to state 36
    if-stmt          go to state 37
    logic-expr       go to state 38
    class-def        go to state 39
    func-def         go to state 40
    var-declr        go to state 41
    expr             go to state 42
    idx-unsafe-expr  go to state 43
    idx-safe-expr    go to state 44
    vet-idx          go to state 45
    unary-expr       go to state 46
    arit-expr        go to state 47
    bitw-expr        go to state 48
    shift-expr       go to state 49
    var-att          go to state 50
    var-met          go to state 51
    var-obj          go to state 52
    var-val          go to state 53
    array-expr       go to state 54


State 402

   30 for-stmt: FOR LPAR var-declr SEMI expr SEMI RPAR LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 3 (line)

    line             go to state 430
    stmt-list        go to state 31
    stmt             go to state 32
    assign-expr      go to state 33
    for-stmt         go to state 34
    do-while-stmt    go to state 35
    while-stmt       go to state 36
    if-stmt          go to state 37
    logic-expr       go to state 38
    class-def        go to state 39
    func-def         go to state 40
    var-declr        go to state 41
    expr             go to state 42
    idx-unsafe-expr  go to state 43
    idx-safe-expr    go to state 44
    vet-idx          go to state 45
    unary-expr       go to state 46
    arit-expr        go to state 47
    bitw-expr        go to state 48
    shift-expr       go to state 49
    var-att          go to state 50
    var-met          go to state 51
    var-obj          go to state 52
    var-val          go to state 53
    array-expr       go to state 54


State 403

   29 for-stmt: FOR LPAR var-declr SEMI expr SEMI assign-expr RPAR . LBRACE line RBRACE

    LBRACE  shift, and go to state 431


State 404

   28 for-stmt: FOR LPAR var-declr SEMI expr SEMI expr RPAR . LBRACE line RBRACE

    LBRACE  shift, and go to state 432


State 405

   98 params: ID COMMA ID COLON var-type .

    $default  reduce using rule 98 (params)


State 406

   95 params: ID COLON var-type COMMA ID . COLON var-type
   96       | ID COLON var-type COMMA ID .

    COLON  shift, and go to state 433

    $default  reduce using rule 96 (params)


State 407

   91 func-def: FUNCTION ID LPAR params RPAR COLON var-type LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 3 (line)

    line             go to state 434
    stmt-list        go to state 31
    stmt             go to state 32
    assign-expr      go to state 33
    for-stmt         go to state 34
    do-while-stmt    go to state 35
    while-stmt       go to state 36
    if-stmt          go to state 37
    logic-expr       go to state 38
    class-def        go to state 39
    func-def         go to state 40
    var-declr        go to state 41
    expr             go to state 42
    idx-unsafe-expr  go to state 43
    idx-safe-expr    go to state 44
    vet-idx          go to state 45
    unary-expr       go to state 46
    arit-expr        go to state 47
    bitw-expr        go to state 48
    shift-expr       go to state 49
    var-att          go to state 50
    var-met          go to state 51
    var-obj          go to state 52
    var-val          go to state 53
    array-expr       go to state 54


State 408

   90 func-def: FUNCTION ID LPAR params RPAR LBRACE line RBRACE .

    $default  reduce using rule 90 (func-def)


State 409

   64 if-stmt: IF LPAR assign-expr RPAR LBRACE line RBRACE ELSE . LBRACE line RBRACE
   65        | IF LPAR assign-expr RPAR LBRACE line RBRACE ELSE . stmt

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACE       shift, and go to state 435
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    stmt             go to state 436
    assign-expr      go to state 33
    for-stmt         go to state 34
    do-while-stmt    go to state 35
    while-stmt       go to state 36
    if-stmt          go to state 37
    logic-expr       go to state 38
    class-def        go to state 39
    func-def         go to state 40
    var-declr        go to state 41
    expr             go to state 42
    idx-unsafe-expr  go to state 43
    idx-safe-expr    go to state 44
    vet-idx          go to state 45
    unary-expr       go to state 46
    arit-expr        go to state 47
    bitw-expr        go to state 48
    shift-expr       go to state 49
    var-att          go to state 50
    var-met          go to state 51
    var-obj          go to state 52
    var-val          go to state 53
    array-expr       go to state 54


State 410

   61 if-stmt: IF LPAR expr RPAR LBRACE line RBRACE ELSE . LBRACE line RBRACE
   62        | IF LPAR expr RPAR LBRACE line RBRACE ELSE . stmt

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACE       shift, and go to state 437
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    stmt             go to state 438
    assign-expr      go to state 33
    for-stmt         go to state 34
    do-while-stmt    go to state 35
    while-stmt       go to state 36
    if-stmt          go to state 37
    logic-expr       go to state 38
    class-def        go to state 39
    func-def         go to state 40
    var-declr        go to state 41
    expr             go to state 42
    idx-unsafe-expr  go to state 43
    idx-safe-expr    go to state 44
    vet-idx          go to state 45
    unary-expr       go to state 46
    arit-expr        go to state 47
    bitw-expr        go to state 48
    shift-expr       go to state 49
    var-att          go to state 50
    var-met          go to state 51
    var-obj          go to state 52
    var-val          go to state 53
    array-expr       go to state 54


State 411

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  106 var-declr: LET ID COLON var-type LBRACKET RBRACKET ASSIGN expr .
  158 arit-expr: expr . PLUS expr
  159          | expr . SUB expr
  160          | expr . MULT expr
  161          | expr . DIV expr
  162          | expr . EXP expr
  163          | expr . REM expr
  164 bitw-expr: expr . BITWISE_AND expr
  165          | expr . BITWISE_OR expr
  166          | expr . BITWISE_XOR expr
  167 shift-expr: expr . LSHIFT expr
  168           | expr . RSHIFT expr
  169           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 118
    SUB              shift, and go to state 119
    MULT             shift, and go to state 120
    DIV              shift, and go to state 121
    EXP              shift, and go to state 122
    REM              shift, and go to state 123
    BITWISE_AND      shift, and go to state 124
    BITWISE_OR       shift, and go to state 125
    BITWISE_XOR      shift, and go to state 126
    LOGICAL_NULL     shift, and go to state 127
    LOGICAL_AND      shift, and go to state 128
    LOGICAL_OR       shift, and go to state 129
    EQ               shift, and go to state 130
    EQ_STRICT        shift, and go to state 131
    INEQ             shift, and go to state 132
    INEQ_STRICT      shift, and go to state 133
    LT               shift, and go to state 134
    LT_EQ            shift, and go to state 135
    GT               shift, and go to state 136
    GT_EQ            shift, and go to state 137
    LSHIFT           shift, and go to state 138
    RSHIFT           shift, and go to state 139
    RSHIFT_UNSIGNED  shift, and go to state 140

    $default  reduce using rule 106 (var-declr)


State 412

  187 var-obj: NEW ID LT var-type GT LPAR args-list RPAR .

    $default  reduce using rule 187 (var-obj)


State 413

   66 logic-expr: expr . EQ expr
   67           | expr . EQ_STRICT expr
   68           | expr . INEQ expr
   69           | expr . INEQ_STRICT expr
   70           | expr . LT expr
   72           | expr . LT_EQ expr
   73           | expr . GT expr
   74           | expr . GT_EQ expr
   75           | expr . LOGICAL_NULL expr
   76           | expr . LOGICAL_AND expr
   77           | expr . LOGICAL_OR expr
  113 var-declr: VAR ID COLON var-type LBRACKET RBRACKET ASSIGN expr .
  158 arit-expr: expr . PLUS expr
  159          | expr . SUB expr
  160          | expr . MULT expr
  161          | expr . DIV expr
  162          | expr . EXP expr
  163          | expr . REM expr
  164 bitw-expr: expr . BITWISE_AND expr
  165          | expr . BITWISE_OR expr
  166          | expr . BITWISE_XOR expr
  167 shift-expr: expr . LSHIFT expr
  168           | expr . RSHIFT expr
  169           | expr . RSHIFT_UNSIGNED expr

    PLUS             shift, and go to state 118
    SUB              shift, and go to state 119
    MULT             shift, and go to state 120
    DIV              shift, and go to state 121
    EXP              shift, and go to state 122
    REM              shift, and go to state 123
    BITWISE_AND      shift, and go to state 124
    BITWISE_OR       shift, and go to state 125
    BITWISE_XOR      shift, and go to state 126
    LOGICAL_NULL     shift, and go to state 127
    LOGICAL_AND      shift, and go to state 128
    LOGICAL_OR       shift, and go to state 129
    EQ               shift, and go to state 130
    EQ_STRICT        shift, and go to state 131
    INEQ             shift, and go to state 132
    INEQ_STRICT      shift, and go to state 133
    LT               shift, and go to state 134
    LT_EQ            shift, and go to state 135
    GT               shift, and go to state 136
    GT_EQ            shift, and go to state 137
    LSHIFT           shift, and go to state 138
    RSHIFT           shift, and go to state 139
    RSHIFT_UNSIGNED  shift, and go to state 140

    $default  reduce using rule 113 (var-declr)


State 414

   86 class-att: ID LPAR params RPAR COLON var-type . LBRACE line RBRACE

    LBRACE  shift, and go to state 439


State 415

   85 class-att: ID LPAR params RPAR LBRACE line . RBRACE

    RBRACE  shift, and go to state 440


State 416

   38 for-stmt: FOR LPAR SEMI SEMI assign-expr RPAR LBRACE line RBRACE .

    $default  reduce using rule 38 (for-stmt)


State 417

   37 for-stmt: FOR LPAR SEMI SEMI expr RPAR LBRACE line RBRACE .

    $default  reduce using rule 37 (for-stmt)


State 418

   36 for-stmt: FOR LPAR SEMI expr SEMI RPAR LBRACE line RBRACE .

    $default  reduce using rule 36 (for-stmt)


State 419

   35 for-stmt: FOR LPAR SEMI expr SEMI assign-expr RPAR LBRACE line . RBRACE

    RBRACE  shift, and go to state 441


State 420

   34 for-stmt: FOR LPAR SEMI expr SEMI expr RPAR LBRACE line . RBRACE

    RBRACE  shift, and go to state 442


State 421

   27 for-stmt: FOR LPAR assign-expr SEMI SEMI RPAR LBRACE line RBRACE .

    $default  reduce using rule 27 (for-stmt)


State 422

   26 for-stmt: FOR LPAR assign-expr SEMI SEMI assign-expr RPAR LBRACE line . RBRACE

    RBRACE  shift, and go to state 443


State 423

   25 for-stmt: FOR LPAR assign-expr SEMI SEMI expr RPAR LBRACE line . RBRACE

    RBRACE  shift, and go to state 444


State 424

   24 for-stmt: FOR LPAR assign-expr SEMI expr SEMI RPAR LBRACE line . RBRACE

    RBRACE  shift, and go to state 445


State 425

   23 for-stmt: FOR LPAR assign-expr SEMI expr SEMI assign-expr RPAR LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 3 (line)

    line             go to state 446
    stmt-list        go to state 31
    stmt             go to state 32
    assign-expr      go to state 33
    for-stmt         go to state 34
    do-while-stmt    go to state 35
    while-stmt       go to state 36
    if-stmt          go to state 37
    logic-expr       go to state 38
    class-def        go to state 39
    func-def         go to state 40
    var-declr        go to state 41
    expr             go to state 42
    idx-unsafe-expr  go to state 43
    idx-safe-expr    go to state 44
    vet-idx          go to state 45
    unary-expr       go to state 46
    arit-expr        go to state 47
    bitw-expr        go to state 48
    shift-expr       go to state 49
    var-att          go to state 50
    var-met          go to state 51
    var-obj          go to state 52
    var-val          go to state 53
    array-expr       go to state 54


State 426

   22 for-stmt: FOR LPAR assign-expr SEMI expr SEMI expr RPAR LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 3 (line)

    line             go to state 447
    stmt-list        go to state 31
    stmt             go to state 32
    assign-expr      go to state 33
    for-stmt         go to state 34
    do-while-stmt    go to state 35
    while-stmt       go to state 36
    if-stmt          go to state 37
    logic-expr       go to state 38
    class-def        go to state 39
    func-def         go to state 40
    var-declr        go to state 41
    expr             go to state 42
    idx-unsafe-expr  go to state 43
    idx-safe-expr    go to state 44
    vet-idx          go to state 45
    unary-expr       go to state 46
    arit-expr        go to state 47
    bitw-expr        go to state 48
    shift-expr       go to state 49
    var-att          go to state 50
    var-met          go to state 51
    var-obj          go to state 52
    var-val          go to state 53
    array-expr       go to state 54


State 427

   33 for-stmt: FOR LPAR var-declr SEMI SEMI RPAR LBRACE line RBRACE .

    $default  reduce using rule 33 (for-stmt)


State 428

   32 for-stmt: FOR LPAR var-declr SEMI SEMI assign-expr RPAR LBRACE line . RBRACE

    RBRACE  shift, and go to state 448


State 429

   31 for-stmt: FOR LPAR var-declr SEMI SEMI expr RPAR LBRACE line . RBRACE

    RBRACE  shift, and go to state 449


State 430

   30 for-stmt: FOR LPAR var-declr SEMI expr SEMI RPAR LBRACE line . RBRACE

    RBRACE  shift, and go to state 450


State 431

   29 for-stmt: FOR LPAR var-declr SEMI expr SEMI assign-expr RPAR LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 3 (line)

    line             go to state 451
    stmt-list        go to state 31
    stmt             go to state 32
    assign-expr      go to state 33
    for-stmt         go to state 34
    do-while-stmt    go to state 35
    while-stmt       go to state 36
    if-stmt          go to state 37
    logic-expr       go to state 38
    class-def        go to state 39
    func-def         go to state 40
    var-declr        go to state 41
    expr             go to state 42
    idx-unsafe-expr  go to state 43
    idx-safe-expr    go to state 44
    vet-idx          go to state 45
    unary-expr       go to state 46
    arit-expr        go to state 47
    bitw-expr        go to state 48
    shift-expr       go to state 49
    var-att          go to state 50
    var-met          go to state 51
    var-obj          go to state 52
    var-val          go to state 53
    array-expr       go to state 54


State 432

   28 for-stmt: FOR LPAR var-declr SEMI expr SEMI expr RPAR LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 3 (line)

    line             go to state 452
    stmt-list        go to state 31
    stmt             go to state 32
    assign-expr      go to state 33
    for-stmt         go to state 34
    do-while-stmt    go to state 35
    while-stmt       go to state 36
    if-stmt          go to state 37
    logic-expr       go to state 38
    class-def        go to state 39
    func-def         go to state 40
    var-declr        go to state 41
    expr             go to state 42
    idx-unsafe-expr  go to state 43
    idx-safe-expr    go to state 44
    vet-idx          go to state 45
    unary-expr       go to state 46
    arit-expr        go to state 47
    bitw-expr        go to state 48
    shift-expr       go to state 49
    var-att          go to state 50
    var-met          go to state 51
    var-obj          go to state 52
    var-val          go to state 53
    array-expr       go to state 54


State 433

   95 params: ID COLON var-type COMMA ID COLON . var-type

    VOID_RW   shift, and go to state 155
    ANY       shift, and go to state 156
    BOOLTYPE  shift, and go to state 157
    NEVER     shift, and go to state 158
    NUMBER    shift, and go to state 159
    STRING    shift, and go to state 160
    UNKNOWN   shift, and go to state 161

    var-type  go to state 453


State 434

   91 func-def: FUNCTION ID LPAR params RPAR COLON var-type LBRACE line . RBRACE

    RBRACE  shift, and go to state 454


State 435

   64 if-stmt: IF LPAR assign-expr RPAR LBRACE line RBRACE ELSE LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 3 (line)

    line             go to state 455
    stmt-list        go to state 31
    stmt             go to state 32
    assign-expr      go to state 33
    for-stmt         go to state 34
    do-while-stmt    go to state 35
    while-stmt       go to state 36
    if-stmt          go to state 37
    logic-expr       go to state 38
    class-def        go to state 39
    func-def         go to state 40
    var-declr        go to state 41
    expr             go to state 42
    idx-unsafe-expr  go to state 43
    idx-safe-expr    go to state 44
    vet-idx          go to state 45
    unary-expr       go to state 46
    arit-expr        go to state 47
    bitw-expr        go to state 48
    shift-expr       go to state 49
    var-att          go to state 50
    var-met          go to state 51
    var-obj          go to state 52
    var-val          go to state 53
    array-expr       go to state 54


State 436

   65 if-stmt: IF LPAR assign-expr RPAR LBRACE line RBRACE ELSE stmt .

    $default  reduce using rule 65 (if-stmt)


State 437

   61 if-stmt: IF LPAR expr RPAR LBRACE line RBRACE ELSE LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 3 (line)

    line             go to state 456
    stmt-list        go to state 31
    stmt             go to state 32
    assign-expr      go to state 33
    for-stmt         go to state 34
    do-while-stmt    go to state 35
    while-stmt       go to state 36
    if-stmt          go to state 37
    logic-expr       go to state 38
    class-def        go to state 39
    func-def         go to state 40
    var-declr        go to state 41
    expr             go to state 42
    idx-unsafe-expr  go to state 43
    idx-safe-expr    go to state 44
    vet-idx          go to state 45
    unary-expr       go to state 46
    arit-expr        go to state 47
    bitw-expr        go to state 48
    shift-expr       go to state 49
    var-att          go to state 50
    var-met          go to state 51
    var-obj          go to state 52
    var-val          go to state 53
    array-expr       go to state 54


State 438

   62 if-stmt: IF LPAR expr RPAR LBRACE line RBRACE ELSE stmt .

    $default  reduce using rule 62 (if-stmt)


State 439

   86 class-att: ID LPAR params RPAR COLON var-type LBRACE . line RBRACE

    INCREMENT    shift, and go to state 1
    SUB          shift, and go to state 2
    DECREMENT    shift, and go to state 3
    BITWISE_NOT  shift, and go to state 4
    LOGICAL_NOT  shift, and go to state 5
    LPAR         shift, and go to state 6
    LBRACKET     shift, and go to state 7
    INT_VAL      shift, and go to state 8
    REAL_VAL     shift, and go to state 9
    STR_VAL      shift, and go to state 10
    ID           shift, and go to state 11
    BREAK        shift, and go to state 12
    CLASS        shift, and go to state 13
    CONST_RW     shift, and go to state 14
    CONTINUE     shift, and go to state 15
    DO           shift, and go to state 16
    FALSE_RW     shift, and go to state 17
    FOR          shift, and go to state 18
    FUNCTION     shift, and go to state 19
    IF           shift, and go to state 20
    LET          shift, and go to state 21
    NEW          shift, and go to state 22
    NULL_RW      shift, and go to state 23
    RETURN       shift, and go to state 24
    TRUE_RW      shift, and go to state 25
    VAR          shift, and go to state 26
    WHILE        shift, and go to state 27
    UNDEFINED    shift, and go to state 28

    $default  reduce using rule 3 (line)

    line             go to state 457
    stmt-list        go to state 31
    stmt             go to state 32
    assign-expr      go to state 33
    for-stmt         go to state 34
    do-while-stmt    go to state 35
    while-stmt       go to state 36
    if-stmt          go to state 37
    logic-expr       go to state 38
    class-def        go to state 39
    func-def         go to state 40
    var-declr        go to state 41
    expr             go to state 42
    idx-unsafe-expr  go to state 43
    idx-safe-expr    go to state 44
    vet-idx          go to state 45
    unary-expr       go to state 46
    arit-expr        go to state 47
    bitw-expr        go to state 48
    shift-expr       go to state 49
    var-att          go to state 50
    var-met          go to state 51
    var-obj          go to state 52
    var-val          go to state 53
    array-expr       go to state 54


State 440

   85 class-att: ID LPAR params RPAR LBRACE line RBRACE .

    $default  reduce using rule 85 (class-att)


State 441

   35 for-stmt: FOR LPAR SEMI expr SEMI assign-expr RPAR LBRACE line RBRACE .

    $default  reduce using rule 35 (for-stmt)


State 442

   34 for-stmt: FOR LPAR SEMI expr SEMI expr RPAR LBRACE line RBRACE .

    $default  reduce using rule 34 (for-stmt)


State 443

   26 for-stmt: FOR LPAR assign-expr SEMI SEMI assign-expr RPAR LBRACE line RBRACE .

    $default  reduce using rule 26 (for-stmt)


State 444

   25 for-stmt: FOR LPAR assign-expr SEMI SEMI expr RPAR LBRACE line RBRACE .

    $default  reduce using rule 25 (for-stmt)


State 445

   24 for-stmt: FOR LPAR assign-expr SEMI expr SEMI RPAR LBRACE line RBRACE .

    $default  reduce using rule 24 (for-stmt)


State 446

   23 for-stmt: FOR LPAR assign-expr SEMI expr SEMI assign-expr RPAR LBRACE line . RBRACE

    RBRACE  shift, and go to state 458


State 447

   22 for-stmt: FOR LPAR assign-expr SEMI expr SEMI expr RPAR LBRACE line . RBRACE

    RBRACE  shift, and go to state 459


State 448

   32 for-stmt: FOR LPAR var-declr SEMI SEMI assign-expr RPAR LBRACE line RBRACE .

    $default  reduce using rule 32 (for-stmt)


State 449

   31 for-stmt: FOR LPAR var-declr SEMI SEMI expr RPAR LBRACE line RBRACE .

    $default  reduce using rule 31 (for-stmt)


State 450

   30 for-stmt: FOR LPAR var-declr SEMI expr SEMI RPAR LBRACE line RBRACE .

    $default  reduce using rule 30 (for-stmt)


State 451

   29 for-stmt: FOR LPAR var-declr SEMI expr SEMI assign-expr RPAR LBRACE line . RBRACE

    RBRACE  shift, and go to state 460


State 452

   28 for-stmt: FOR LPAR var-declr SEMI expr SEMI expr RPAR LBRACE line . RBRACE

    RBRACE  shift, and go to state 461


State 453

   95 params: ID COLON var-type COMMA ID COLON var-type .

    $default  reduce using rule 95 (params)


State 454

   91 func-def: FUNCTION ID LPAR params RPAR COLON var-type LBRACE line RBRACE .

    $default  reduce using rule 91 (func-def)


State 455

   64 if-stmt: IF LPAR assign-expr RPAR LBRACE line RBRACE ELSE LBRACE line . RBRACE

    RBRACE  shift, and go to state 462


State 456

   61 if-stmt: IF LPAR expr RPAR LBRACE line RBRACE ELSE LBRACE line . RBRACE

    RBRACE  shift, and go to state 463


State 457

   86 class-att: ID LPAR params RPAR COLON var-type LBRACE line . RBRACE

    RBRACE  shift, and go to state 464


State 458

   23 for-stmt: FOR LPAR assign-expr SEMI expr SEMI assign-expr RPAR LBRACE line RBRACE .

    $default  reduce using rule 23 (for-stmt)


State 459

   22 for-stmt: FOR LPAR assign-expr SEMI expr SEMI expr RPAR LBRACE line RBRACE .

    $default  reduce using rule 22 (for-stmt)


State 460

   29 for-stmt: FOR LPAR var-declr SEMI expr SEMI assign-expr RPAR LBRACE line RBRACE .

    $default  reduce using rule 29 (for-stmt)


State 461

   28 for-stmt: FOR LPAR var-declr SEMI expr SEMI expr RPAR LBRACE line RBRACE .

    $default  reduce using rule 28 (for-stmt)


State 462

   64 if-stmt: IF LPAR assign-expr RPAR LBRACE line RBRACE ELSE LBRACE line RBRACE .

    $default  reduce using rule 64 (if-stmt)


State 463

   61 if-stmt: IF LPAR expr RPAR LBRACE line RBRACE ELSE LBRACE line RBRACE .

    $default  reduce using rule 61 (if-stmt)


State 464

   86 class-att: ID LPAR params RPAR COLON var-type LBRACE line RBRACE .

    $default  reduce using rule 86 (class-att)
